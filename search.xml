<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apriori（先验）算法关联规则</title>
    <url>/2020/04/08/Apriori/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#apriori-xian-yan-suan-fa-guan-lian-gui-ze">Apriori（先验）算法关联规则</a><ul>
<li><a href="#zhi-chi-du">支持度</a></li>
<li><a href="#zhi-xin-du">置信度</a></li>
<li><a href="#ti-sheng-du">提升度</a></li>
<li><a href="#apriori-suan-fa">Apriori算法</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
# Apriori（先验）算法关联规则
常用的评估标准由支持度、置信度、和提升度三个：

<a id="more"></a>

<h2><span id="zhi-chi-du">支持度</span><a href="#zhi-chi-du" class="header-anchor">#</a></h2><p>支持度就是数据在数据集中出现的次数（也可以是次数占总数据集的比重），或者说其在数据集中出现的概率：</p>
<p>以下面这张图为例子，这张图每一列代表商品是否被购买（1代表被购买，0代表否），每一行代表一次交易记录：</p>
<table>
<thead>
<tr>
<th>面包</th>
<th>牛奶</th>
<th>黄油</th>
<th>苹果</th>
<th>香蕉</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>下面的公式以所占比例来说明：</p>
<p>如果是一个数据X，则其支持度为：<br>support(X)=P(X)=num(X)/num(ALL)</p>
<p>如果数据是一个数据项集（X,Y）,则支持度为：<br>support(X,Y)=P(X,Y)=num(XY)/num(ALL)</p>
<p>如果数据是一个数据项集（X,Y,Z）,则支持度为：</p>
<p>support(X,Y,Z)=P(X,Y,Z)=num(XYZ)/num(ALL)(X,Y,Z代表的是X,Y,Z同时出现的次数)</p>
<p>以上面的交易为例：</p>
<p>我们来求 （黄油，苹果） 的支持度：<br>（黄油，苹果） 在第0，2，3中通过出现了，一共是5条数据，因此support(黄油,苹果)=3/5=0.6</p>
<p>一般来说，支持度高的不一定数据频繁，但是数据频繁的一定支持度高</p>
<h2><span id="zhi-xin-du">置信度</span><a href="#zhi-xin-du" class="header-anchor">#</a></h2><p>置信度代表的规则应验的准确性，也就是一个数据出现后，另外一个数据出现的概率，也就是条件概率。(以购买为例，就是已经购买Y的条件下，购买X的概率)公式如下：</p>
<p>设分析的数据是X,Y，则X对Y的置信度为：</p>
<p>confidence(X⇐Y)=P(X|Y)=P(XY)/P(Y)</p>
<p>设分析的数据是X,Y,Z，则X对Y和Z的置信度为：</p>
<p>confidence(X⇐YZ)=P(X|YZ)=P(XYZ)/P(YZ)</p>
<p>还是以 （黄油，苹果） 为例子，计算黄油对苹果的置信度：confidence(黄油⇐苹果)=34=0.75。</p>
<p>但是置信度有一个缺点，那就是它可能会扭曲关联的重要性。因为它只反应了Y的受欢迎的程度。如果X的受欢迎程度也很高的话，那么confidence也会很大。</p>
<p>置信度只考虑了：<br>1买苹果的人有多少<br>2买了苹果且同时买了牌酒的人有多少.<br>显然是有缺点的.<br>如果数据集中每个事务都包含了啤酒，那么啤酒跟苹果之间的关联关系就是的.</p>
<p>反过来，如果买苹果的事务有1000条，买啤酒的事务只有10条，但是所有买啤酒的这10条都买了苹果（换句话说，只有买了苹果才可能买啤酒），置信只有10/1000-0.01.<br>所以不管是置信度为1（前面一种），还是置信度0.01，都不足以表明苹果和啤酒之间的关联关系。<br>这个可以用提升度来表征。</p>
<h2><span id="ti-sheng-du">提升度</span><a href="#ti-sheng-du" class="header-anchor">#</a></h2><p>提升度表示在含有Y的条件下，同时含有X的概率，同时考虑到X的概率，公式如下：</p>
<p>Lift(X⇐Y)=support(X,Y)/(support(X)×support(Y))=P(X,Y)/(P(X)×P(Y))=P(X|Y)/P(X)=confidenc(X⇐Y)/P(X)</p>
<p>在提升度中，如果Lift(X⇐Y)=1则表示X，Y之间相互独立，没有关联（因为P(X|Y)=P(X)），</p>
<p>如果Lift(X⇐Y)&gt;1则表示X⇐Y则表示X⇐Y是有效的强关联（在购买Y的情况下很可能购买X）；</p>
<p>如果Lift(X⇐Y)&lt;1则表示X⇐Y则表示X⇐Y是无效的强关联。</p>
<p>一般来说，我们如何判断一个数据集中数据的频繁程度时使用提升度来做的。</p>
<h2><span id="apriori-suan-fa">Apriori算法</span><a href="#apriori-suan-fa" class="header-anchor">#</a></h2><p>Apriori算法的目标是找到最大的K项频繁集。这里有两层意思，首先，我们要找到符合支持度标准（置信度or提升度）的频繁集。但是这样的频繁集可能有很多。第二层意思就是我们要找到最大个数的频繁集。比如我们找到符合支持度的频繁集AB和ABE，那么我们会抛弃AB，只保留ABE，因为AB是2项频繁集，而ABE是3项频繁集。</p>
<p>算法的步骤</p>
<ol>
<li>生成初始频繁项集</li>
<li>用现有频繁项集的超集生成<br>备选项集</li>
<li>测试备选项集是否频繁。<br>如果不频繁，则舍弃</li>
<li>步骤3中是否发现新的频繁项集？</li>
<li>否，返回发现的所有频繁项集;是，返回步骤2</li>
</ol>
<p>总的来说，Apriori算法不是很难，算法的流程也很简单，而它的核心在于如何构建一个有效的评判标准，support？confidence？Lift？or others？但是它也有一些缺点：每次递归都需要产生大量的备选项集，</p>
]]></content>
      <categories>
        <category>DataMining</category>
      </categories>
      <tags>
        <tag>DataMining</tag>
      </tags>
  </entry>
  <entry>
    <title>使用HDFS的Java接口对文件进行操作</title>
    <url>/2020/04/08/HDFS/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#shi-yong-hdfs-de-java-jie-kou-jin-xing-wen-jian-de-du-xie">使用HDFS的Java接口进行文件的读写。</a></li>
<li><a href="#shi-yong-hdfsapi-shang-chuan-wen-jian-zhi-ji-qun">使用HDFSAPI上传文件至集群</a></li>
<li><a href="#shan-chu-hdfs-zhong-de-wen-jian-he-wen-jian-jia">删除HDFS中的文件和文件夹</a></li>
</ul>
<!-- tocstop -->

</div>

<h2><span id="shi-yong-hdfs-de-java-jie-kou-jin-xing-wen-jian-de-du-xie">使用HDFS的Java接口进行文件的读写。</span><a href="#shi-yong-hdfs-de-java-jie-kou-jin-xing-wen-jian-de-du-xie" class="header-anchor">#</a></h2><a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200408172005292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<p>FileSystem对象<br>要从Hadoop文件系统中读取文件，最简单的办法是使用java.net.URL对象打开数据流，从中获取数据。不过这种方法一般要使用FsUrlStreamHandlerFactory实例调用setURLStreamHandlerFactory()方法。不过每个Java虚拟机只能调用一次这个方法，所以如果其他第三方程序声明了这个对象，那我们将无法使用了。因为有时候我们不能在程序中设置URLStreamHandlerFactory实例，这个时候咱们就可以使用FileSystem API来打开一个输入流，进而对HDFS进行操作。</p>
<p>使用FileSystem，查看上传的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public sattic void main(String[] args)&#123;</span><br><span class="line">    URI uri &#x3D; URI.create(&quot;hdfs:&#x2F;&#x2F;localhost:9000&#x2F;user&#x2F;tmp&#x2F;test.txt&quot;);</span><br><span class="line">    Configuration config &#x3D; new Configuration();</span><br><span class="line">    FileSystem fs &#x3D; FileSystem.get(uri, config);</span><br><span class="line">    InputStream in &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        in &#x3D; fs.open(new Path(uri));</span><br><span class="line">        IOUtils.copyBytes(in, System.out, 2048, false);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        IOUtils.closeStream(in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileSystem是一个通用的文件系统API，FileSystem实例有下列几个静态工厂方法用来构造对象。</p>
<p>public static FileSystem get(Configuration conf)throws IOException</p>
<p>public static FileSystem get(URI uri,Configuration conf)throws IOException</p>
<p>public static FileSystem get(URI uri,Configuration conf,String user)throws IOException</p>
<p>Configuration对象封装了客户端或服务器的配置，通过设置配置文件读取类路径来实现（如：/etc/hadoop/core-site.xml）。</p>
<p>第一个方法返回的默认文件系统是在core-site.xml中指定的，如果没有指定，就使用默认的文件系统。<br>第二个方法使用给定的URI方案和权限来确定要使用的文件系统，如果给定URI中没有指定方案，则返回默认文件系统，<br>第三个方法作为给定用户来返回文件系统，这个在安全方面来说非常重要。</p>
<p>FSDataInputStream对象<br>实际上，FileSystem对象中的open()方法返回的就是FSDataInputStream对象，而不是标准的java.io类对象。这个类是继承了java.io.DataInputStream的一个特殊类，并支持随机访问，由此可以从流的任意位置读取数据。</p>
<p>在有了FileSystem实例之后，我们调用open()函数来获取文件的输入流。</p>
<p>public FSDataInputStream open(Path p)throws IOException<br>public abst\fract FSDataInputStream open(Path f,int bufferSize)throws IOException<br>第一个方法使用默认的缓冲区大小为4KB。</p>
<p>示例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.net.URI;</span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.FileSystem;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.io.IOUtils;</span><br><span class="line">public class FileSystemCat &#123;</span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		URI uri &#x3D; URI.create(&quot;hdfs:&#x2F;&#x2F;localhost:9000&#x2F;user&#x2F;tmp&#x2F;test.txt&quot;);</span><br><span class="line">    Configuration config &#x3D; new Configuration();</span><br><span class="line">    FileSystem fs &#x3D; FileSystem.get(uri, config);</span><br><span class="line">    InputStream in &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        in &#x3D; fs.open(new Path(uri));</span><br><span class="line">        IOUtils.copyBytes(in, System.out, 2048, false);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        IOUtils.closeStream(in);</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="shi-yong-hdfsapi-shang-chuan-wen-jian-zhi-ji-qun">使用HDFSAPI上传文件至集群</span><a href="#shi-yong-hdfsapi-shang-chuan-wen-jian-zhi-ji-qun" class="header-anchor">#</a></h2><p>FSDataOutputStream对象</p>
<p>Java中要将数据输出到终端，需要文件输出流，HDFS的JavaAPI中也有类似的对象。</p>
<p>FileSystem类有一系列新建文件的方法，最简单的方法是给准备新建的文件制定一个path对象，然后返回一个用于写入数据的输出流：</p>
<p>public FSDataOutputStream create(Path p)throws IOException</p>
<p>该方法有很多重载方法，允许我们指定是否需要强制覆盖现有文件，文件备份数量，写入文件时所用缓冲区大小，文件块大小以及文件权限。</p>
<p>注意：create()方法能够为需要写入且当前不存在的目录创建父目录，即就算传入的路径是不存在的，该方法也会为你创建一个目录，而不会报错。如果有时候我们并不希望它这么做，可以先用exists()方法先判断目录是否存在。</p>
<p>在写入数据的时候经常想要知道当前的进度，API也提供了一个Progressable用于传递回调接口，这样我们就可以很方便的将写入datanode的进度通知给应用了。</p>
<p>package org.apache.hadoop.util;<br>public interface Progressable{<br>    public void progress();<br>}</p>
<p>IOUtils.copyBytes(in, out, 4096, false)方法实现了文件合并及上传至hdfs上<br>IOUtils.copyBytes(in, out, 4096, false)<br>–in:是FSDataInputStream类的对象，是有关读取文件的类，也就是所谓“输入流”<br>–out:是FSDataOutputStream类的对象，是有关文件写入的类，也就是“输出流”<br>–4096表示用来拷贝的buffer大小（buffer是缓冲区）–缓冲区大小  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.BufferedInputStream;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.net.URI;</span><br><span class="line">import java.io.File;</span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.FSDataOutputStream;</span><br><span class="line">import org.apache.hadoop.fs.FileSystem;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">import org.apache.hadoop.io.IOUtils;</span><br><span class="line">import org.apache.hadoop.util.Progressable;</span><br><span class="line">public class FileSystemUpload &#123;	</span><br><span class="line">	public static void main(String[] args) throws IOException &#123;</span><br><span class="line">		&#x2F;&#x2F;请在 Begin-End 之间添加代码，完成任务要求。</span><br><span class="line">        &#x2F;********* Begin *********&#x2F;</span><br><span class="line">		File localPath&#x3D;new File(&quot;&#x2F;develop&#x2F;test.txt&quot;);</span><br><span class="line">		String hdfsPath &#x3D;&quot;hdfs:&#x2F;&#x2F;localhost:9000&#x2F;user&#x2F;hadoop&#x2F;test.txt&quot;;</span><br><span class="line">		InputStream in&#x3D;new BufferedInputStream(new FileInputStream(localPath));</span><br><span class="line">		&#x2F;&#x2F;获取输入流对象</span><br><span class="line">		Configuration config&#x3D;new Configuration();</span><br><span class="line">		FileSystem fs&#x3D;FileSystem.get(URI.create(hdfsPath),config);</span><br><span class="line">		long fileSize&#x3D;localPath.length() &gt; 65536 ? localPath.length()&#x2F;65536 :1;</span><br><span class="line">		&#x2F;&#x2F;待上传文件大小</span><br><span class="line">		FSDataOutputStream out &#x3D;fs.create(new Path(hdfsPath),new Progressable()&#123;</span><br><span class="line">		&#x2F;&#x2F;方法在每次上传了64KB字节大小的文件之后会自动调用一次</span><br><span class="line">			long fileCount&#x3D;0;</span><br><span class="line">			public void progress()&#123;</span><br><span class="line">				System.out.println(&quot;总进度&quot;+(fileCount&#x2F;fileSize)*100+&quot;%&quot;);</span><br><span class="line">				fileCount++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	IOUtils.copyBytes(in,out,2048,true);&#x2F;&#x2F;最后一个参数的意思是使用完之后是否关闭流</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="shan-chu-hdfs-zhong-de-wen-jian-he-wen-jian-jia">删除HDFS中的文件和文件夹</span><a href="#shan-chu-hdfs-zhong-de-wen-jian-he-wen-jian-jia" class="header-anchor">#</a></h2><p>列出文件<br>我们在开发或者维护系统时，经常会需要列出目录的内容，在HDFS的API中就提供了listStatus()方法来实现该功能。</p>
<p>public FileStatus[] listStatus(Path f)throws IOException</p>
<p>public FileStatus[] listStatus(Path f,PathFilter filter)throws IOException</p>
<p>public FileStatus listStatus(Path[] files)throws IOException</p>
<p>public FileStatus() listStatus(Path[] files,PathFilter filter)throws IOException</p>
<p>当传入参数是一个文件时，他会简单的转变成以数组方式返回长度为1的FileStatus对象，当传入参数是一个目录时，则返回0或多个FileStatus对象，表示此目录中包含的文件和目录。</p>
<p>listStatus()方法的使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main（String]args）throws IOException &#123;</span><br><span class="line">string uri &#x3D;&quot;hdfs:&#x2F;&#x2F;localhost：9000&#x2F;&quot;；&#x2F;&#x2F;HDFS根目录</span><br><span class="line">string path1 &#x3D;&quot;hdfs:&#x2F;&#x2F;localhost：9000&#x2F;user&quot;；</span><br><span class="line">Configuration config &#x3D; new Configuration（）；</span><br><span class="line">FileSystem fs &#x3D; FileSystem.get（URI.create（uri），config）；</span><br><span class="line">Path[]paths &#x3D;&#123;new Path（uri），new Path（path1）&#125;；&#x2F;&#x2F;构建要显示目录的数组</span><br><span class="line">Filestatus[1 status &#x3D; fs.liststatus（paths）；</span><br><span class="line">Path[]listPaths &#x3D; Fileutil.stat2Paths（status）；</span><br><span class="line">for（Path path：listPaths）&#123;</span><br><span class="line">system.out.println（path）：</span><br></pre></td></tr></table></figure>

<p>删除文件<br>使用FileSystem的delete()方法可以永久性删除文件或目录。</p>
<p>public boolean delete(Path f,boolean recursive)throws IOException</p>
<p>如果f是一个文件或者空目录，那么recursive的值可以忽略，当recursize的值为true，并且p是一个非空目录时，非空目录及其内容才会被删除（否则将会抛出IOException异常）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.URI;</span><br><span class="line">import org.apache.hadoop.conf.Configuration;</span><br><span class="line">import org.apache.hadoop.fs.FileStatus;</span><br><span class="line">import org.apache.hadoop.fs.FileSystem;</span><br><span class="line">import org.apache.hadoop.fs.FileUtil;</span><br><span class="line">import org.apache.hadoop.fs.Path;</span><br><span class="line">public class FileSystemDelete &#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) throws IOException &#123;</span><br><span class="line">		String uri&#x3D;&quot;hdfs:&#x2F;&#x2F;localhost:9000&#x2F;&quot;;</span><br><span class="line">		String path3&#x3D;&quot;hdfs:&#x2F;&#x2F;localhost:9000&#x2F;user&quot;;</span><br><span class="line">		String path2&#x3D;&quot;hdfs:&#x2F;&#x2F;localhost:9000&#x2F;user&#x2F;hadoop&quot;;</span><br><span class="line">		String path1&#x3D;&quot;hdfs:&#x2F;&#x2F;localhost:9000&#x2F;user&#x2F;tmp&quot;;</span><br><span class="line">		Configuration config&#x3D;new Configuration();</span><br><span class="line">		FileSystem fs&#x3D;FileSystem.get(URI.create(uri),config);</span><br><span class="line">		fs.delete(new Path(path2),true);&#x2F;&#x2F;删除</span><br><span class="line">		fs.delete(new Path(path3),true);&#x2F;&#x2F;删除</span><br><span class="line">		Path[] paths&#x3D;&#123;new Path(uri),new Path(path1)&#125;;</span><br><span class="line">		FileStatus[] status&#x3D;fs.listStatus(paths);</span><br><span class="line">		Path[] listPaths&#x3D;FileUtil.stat2Paths(status);</span><br><span class="line">		for (Path path:listPaths)&#123;</span><br><span class="line">			System.out.println(path);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML快速了解入门教程</title>
    <url>/2020/08/01/HTML%E5%BF%AB%E9%80%9F%E4%BA%86%E8%A7%A3%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#gai-nian">概念</a></li>
<li><a href="#html-ji-ben-jie-gou">html基本结构</a><ul>
<li><a href="#biao-qian-lei-bie">标签类别</a></li>
</ul>
</li>
<li><a href="#html-biao-qian">HTML标签</a><ul>
<li><a href="#wen-ben-biao-qian">文本标签</a></li>
<li><a href="#tu-pian-biao-qian">图片标签</a></li>
<li><a href="#lie-biao-biao-qian">列表标签</a></li>
<li><a href="#chao-lian-jie-biao-qian">超链接标签</a></li>
<li><a href="#biao-ge-biao-qian">表格标签</a></li>
<li><a href="#biao-dan">表单</a><ul>
<li><a href="#form-biao-dan-biao-qian">form 表单标签</a></li>
<li><a href="#biao-dan-xiang-biao-qian">表单项标签</a></li>
</ul>
</li>
<li><a href="#div-he-span">div和span</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h2><span id="gai-nian">概念</span><a href="#gai-nian" class="header-anchor">#</a></h2><p>全称：Hyper Text Markup Language 超文本标记语言<br>     超文本:<br>         * 包含超链接<br>         * 超越了普通文本 ，除了有文字，还有图片，视频等<br>     标记：每一个元素都是被&lt;&gt;包裹   </p>
<p>语法特征</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.文件后缀名 .html  .htm</span><br><span class="line">2.标签的分类：</span><br><span class="line">	*围堵标签(双标签)   &lt;font&gt;文本&lt;&#x2F;font&gt; 具备页面展示功能</span><br><span class="line">	*自闭合标签(单标签)  &lt;br&#x2F;&gt; 换行的功能，不具备页面展示功能</span><br><span class="line">3. 可以在开始标签中定义属性，属性名和属性值就是一个键值对，属性值必须用引号引起来	</span><br><span class="line">4.标签大小写都可以，建议小写</span><br></pre></td></tr></table></figure>
<p>转义字符<br><img src="https://img-blog.csdnimg.cn/20200720004055751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="html-ji-ben-jie-gou">html基本结构</span><a href="#html-ji-ben-jie-gou" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、&lt;!DOCTYPE&gt;</span><br><span class="line">&lt;!DOCTYPE&gt;位于文档的最前面，用于向浏览器说明当前.html文件使用的是哪种HTML或者XHTML标准规范。浏览器会按照此处指定的规范对html文件进行解析。</span><br><span class="line">HTML5可以向下兼容，所以，现在直接指定为&lt;!DOCTYPE html&gt;即可。</span><br><span class="line"></span><br><span class="line">2. html标签：就是告诉浏览器这是一个网页文件</span><br><span class="line"></span><br><span class="line">3、charset（字符编码集）</span><br><span class="line">GB2312：简体中文字符集，含6763个常用汉字</span><br><span class="line">BIG5：繁体中文，港澳台地区使用</span><br><span class="line">GBK：含全部中文字符，是对GB2312的扩展，支持繁体字</span><br><span class="line">UTF-8：支持中文和英文等，是最常用的字符集</span><br><span class="line"></span><br><span class="line">  head标签:用于网站添加一些配置信息</span><br><span class="line">            指定网站的标题&#x2F;指定网站的小图片</span><br><span class="line">            添加网站SEO相关的信息(指定网站的关键字&#x2F;指定网站的描述信息)</span><br><span class="line">             外挂一些外部的css&#x2F;js文件</span><br><span class="line">            添加一些浏览器适配相关的内容</span><br><span class="line">  一般情况下，写在head标签额内部的内容都不会显示给用户看(除标题外)</span><br><span class="line">  </span><br><span class="line"> title标签:就是用来定义网页的名字的</span><br><span class="line">          必须写在head标签的里面</span><br><span class="line">          </span><br><span class="line"> body标签:就是定义你需要让用户查看到的内容</span><br><span class="line">           虽然说有时候将内容写到了别的地方网页中也能看到，但是千万不要这么干，一定要将需要显示的内容写在body标签中</span><br></pre></td></tr></table></figure>
<h3><span id="biao-qian-lei-bie">标签类别</span><a href="#biao-qian-lei-bie" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>标签类别</th>
<th>标签汇总</th>
</tr>
</thead>
<tbody><tr>
<td>单标签</td>
<td>&lt;br&gt;、&lt;hr&gt;、&lt;img&gt;、&lt;input&gt;、&lt;param&gt;、&lt;meta&gt;、&lt;link&gt;</td>
</tr>
<tr>
<td>双标签</td>
<td>&lt;html&gt;、&lt;head&gt;、&lt;title&gt;、&lt;body&gt;、&lt;table&gt;、&lt;tr&gt;、&lt;td&gt;、&lt;span&gt;、&lt;p&gt;、&lt;form&gt;、&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;、&lt;h6&gt;、&lt;object&gt;、&lt;style&gt;、&lt;b&gt;、&lt;u&gt;、&lt;strong&gt;、&lt;i&gt;、&lt;div&gt;、&lt;a&gt;、&lt;script&gt;、&lt;center&gt;</td>
</tr>
</tbody></table>
<h2><span id="html-biao-qian">HTML标签</span><a href="#html-biao-qian" class="header-anchor">#</a></h2><h3><span id="wen-ben-biao-qian">文本标签</span><a href="#wen-ben-biao-qian" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. &lt;!--注释--&gt;     idea中的快捷键是:ctr+shift+&#x2F; </span><br><span class="line">2. h1~h6  标题标签 依次变小，加粗，黑体，换行</span><br><span class="line">3. &lt;br&#x2F;&gt; 换行标签</span><br><span class="line">4. &lt;p&gt;文章段落&lt;&#x2F;p&gt;  换行，段落间空一行</span><br><span class="line">5. &lt;hr&#x2F;&gt;水平线</span><br><span class="line">        - color:颜色 </span><br><span class="line">        - width:宽度, 单位px</span><br><span class="line">        - size :高度，单位px</span><br><span class="line">        - align:center,left,right 对齐方式</span><br><span class="line">6. &lt;b&gt; 加粗</span><br><span class="line">7. &lt;i&gt; 斜体</span><br><span class="line">8. &lt;font&gt; 文本</span><br><span class="line">        - color:颜色</span><br><span class="line">        - size:大小 ，范围 1-7 ，从小到大</span><br><span class="line">        - face:字体</span><br><span class="line">9. &lt;center&gt; 居中</span><br><span class="line">10.&lt;pre&gt;内容&lt;&#x2F;pre&gt;	预格式化。就是你敲在源码里是什么格式。在页面上就显示什么格式。一般跟code配合使用。</span><br><span class="line">11.&lt;code&gt;hello world&lt;code&gt;	表示此段是程序代码</span><br><span class="line">12.&lt;del&gt;内容&lt;&#x2F;del&gt;	在字符上带一条删除线。 一般用于价格  的打折 把原价划掉  下面出来一个新价格</span><br><span class="line">13.&lt;ins&gt;内容&lt;&#x2F;ins&gt;	表示插入的字符，表示方式，带下划线</span><br></pre></td></tr></table></figure>
<h3><span id="tu-pian-biao-qian">图片标签</span><a href="#tu-pian-biao-qian" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.src  图片的路径：相对路径的寻找：从当前文件出发</span><br><span class="line">    上级目录：..&#x2F;</span><br><span class="line">    同级和下级目录：直接写文件夹或文件名</span><br><span class="line">2.alt 替代文字信息,图片不能显示时出现</span><br><span class="line">3.width:宽度</span><br><span class="line">4.height：高度</span><br><span class="line">5.align：对齐方式 left&#x2F;right 左对齐&#x2F;右对齐</span><br><span class="line">--&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;..&#x2F;image&#x2F;c.jpg&quot; alt&#x3D;&quot;这里是刘亦菲&quot; width&#x3D;&quot;500px&quot; height&#x3D;&quot;400px&quot; align&#x3D;&quot;right&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h3><span id="lie-biao-biao-qian">列表标签</span><a href="#lie-biao-biao-qian" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h3&gt;有序列表&lt;&#x2F;h3&gt;</span><br><span class="line">&lt;!--order list</span><br><span class="line"> type: 1 A  a  i I</span><br><span class="line"> start: 开始的下标</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;ol type&#x3D;&quot;I&quot; start&#x3D;&quot;I&quot;&gt;</span><br><span class="line">    &lt;li&gt;吃早餐&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;上课&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;下课&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;放学&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;吃饭&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;睡觉&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ol&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;无序列表&lt;&#x2F;h3&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">unorder list</span><br><span class="line">type:disc,square,circle</span><br><span class="line">--&gt;</span><br><span class="line">&lt;ul type&#x3D;&quot;circle&quot; &gt;</span><br><span class="line">    &lt;li&gt;吃早餐&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;上课&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;下课&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;放学&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;吃饭&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;睡觉&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;自定义列表&lt;&#x2F;h3&gt;</span><br><span class="line">&lt;!--define list--&gt;</span><br><span class="line">&lt;dl&gt;</span><br><span class="line">    &lt;dt&gt;娱乐&lt;&#x2F;dt&gt;</span><br><span class="line">    &lt;dd&gt;游戏&lt;&#x2F;dd&gt;</span><br><span class="line">    &lt;dd&gt;K歌&lt;&#x2F;dd&gt;</span><br><span class="line">    &lt;dd&gt;电影&lt;&#x2F;dd&gt;</span><br><span class="line">    &lt;dd&gt;逛街&lt;&#x2F;dd&gt;</span><br><span class="line">&lt;&#x2F;dl&gt;</span><br></pre></td></tr></table></figure>
<h3><span id="chao-lian-jie-biao-qian">超链接标签</span><a href="#chao-lian-jie-biao-qian" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">1.href:点击跳转的资源路径</span><br><span class="line">  * 跳转到互联网资源</span><br><span class="line">  * 跳转到本地资源</span><br><span class="line">如果当时没有确定链接目标时，可以为 href 赋值 为 “#” ,即 href&#x3D;&quot;#&quot;,表示一个空连接</span><br><span class="line">2.target:</span><br><span class="line">  * _self 当前窗口打开</span><br><span class="line">  * _blank  新开一个窗口打开</span><br><span class="line">  *_parent</span><br><span class="line">这个目标使得文档载入父窗口或者包含来超链接引用的框架的框架集。如果这个引用是在窗口或者在顶级框架中，那么它与目标 _self 等效。</span><br><span class="line">  *_top</span><br><span class="line">这个目标使得文档载入包含这个超链接的窗口，用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。</span><br><span class="line"></span><br><span class="line">&lt;base&gt; 标签可以限定同一页面内所有 超链接 的打开方式。&lt;base target&#x3D;&quot;_blank&quot;&gt;</span><br><span class="line">--&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot; target&#x3D;&quot;_self&quot;&gt;点我--访问互联网资源&lt;&#x2F;a&gt; &lt;br&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;..&#x2F;image&#x2F;b.jpg&quot; target&#x3D;&quot;_blank&quot;&gt;点我看刘亦菲--访问本地工程中资源&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<p>通过创建锚点，可以快速定位到目标内容区域<br>创建锚点分为两步<br>为目标内容（即锚点）创建id 并赋值<br>将超链接文本与锚点的id 关联，</p>
<pre><code>&lt;a href=&quot;#id名称&quot;&gt; 超链接文本 &lt;/a&gt;
&lt;h3 id=&quot;name&quot;&gt;创建锚点分为两步&lt;/h3&gt;</code></pre><h3><span id="biao-ge-biao-qian">表格标签</span><a href="#biao-ge-biao-qian" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">&lt;caption&gt;我的标题&lt;&#x2F;caption&gt;  标题</span><br><span class="line">border&#x3D;&quot;1&quot;  边框,单位是像素px</span><br><span class="line">cellspacing&#x3D;&quot;0&quot;   单元格外边距，通常设置为0，用于消除td之间的间距</span><br><span class="line">cellpadding&#x3D;&quot;10&quot;  单元格内边距：单元格的边框和内部文本的距离，通常设置为10，可以撑大表格，显示清晰美观</span><br><span class="line">align&#x3D;&quot;center&quot;    </span><br><span class="line">	1.作用在table标签上：整个表格在对窗口居中显示</span><br><span class="line">	2.作用在tr标签上：表示当前行的文本内容在单元格中居中显示</span><br><span class="line">表头使用th :具有 加粗 和 文本内容居中显示的功能</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--跨行</span><br><span class="line">1.从上到下</span><br><span class="line">2.第一个单元格保留，剩下的删除</span><br><span class="line">3.给第一个单元格一个属性 rowspan&#x3D;&quot;3&quot; 包含自己在内的总行数</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--跨列</span><br><span class="line">1.从左到右</span><br><span class="line">2.第一个单元格保留，剩下的删除</span><br><span class="line">3.给第一个单元格一个属性 colspan&#x3D;&quot;4&quot; 包含自己在内的总列数</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;table border&#x3D;&quot;1&quot; cellspacing&#x3D;&quot;0&quot; cellpadding&#x3D;&quot;10&quot; align&#x3D;&quot;center&quot; bgcolor&#x3D;&quot;#7fff00&quot;&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;编号&lt;&#x2F;th&gt;</span><br><span class="line">        &lt;th&gt;姓名&lt;&#x2F;th&gt;</span><br><span class="line">        &lt;th&gt;年龄&lt;&#x2F;th&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;tr align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">        &lt;td&gt;1&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;小龙女&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;36&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;2&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;杨过&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;18&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure>
<h3><span id="biao-dan">表单</span><a href="#biao-dan" class="header-anchor">#</a></h3><h4><span id="form-biao-dan-biao-qian">form 表单标签</span><a href="#form-biao-dan-biao-qian" class="header-anchor">#</a></h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.范围：数据提交到服务器的范围</span><br><span class="line"><span class="number">2</span>.属性：</span><br><span class="line">	action：url 数据提交网址</span><br><span class="line">	method：数据提交方式 get/post</span><br></pre></td></tr></table></figure>
<ul>
<li>如何提交数据<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.表单项标签  input</span><br><span class="line"><span class="number">2</span>.input元素必须要有name属性才能提交数据</span><br><span class="line">表单项标签中的name和value属性值构成一个参数键值对，在提交的时候，会发送到服务器</span><br></pre></td></tr></table></figure></li>
<li>get和post的区别<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.get请求方式会把提交的数据显示在浏览器的地址栏，post不会显示</span><br><span class="line"><span class="number">2</span>.get方式提交的数据有大小和长度的限制，post没有</span><br><span class="line"><span class="number">3</span>.get不安全，post安全</span><br></pre></td></tr></table></figure>
<h4><span id="biao-dan-xiang-biao-qian">表单项标签</span><a href="#biao-dan-xiang-biao-qian" class="header-anchor">#</a></h4></li>
<li>input标签的type属性值<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.text 文本输入框</span><br><span class="line"><span class="number">2</span>.password 密码输入框</span><br><span class="line"><span class="number">3</span>.radio 单选</span><br><span class="line"><span class="number">3</span>.checkbox 复选框</span><br><span class="line"><span class="number">4</span>.file 文件引入按钮</span><br><span class="line"><span class="number">5</span>.submit提交按钮</span><br><span class="line"><span class="number">6</span>.button 普通按钮，本身不具备任何功能</span><br><span class="line"><span class="number">7</span>.image 图片提交</span><br><span class="line"><span class="number">8</span>.hidden 隐藏域 提交默认的数据</span><br><span class="line">扩展：</span><br><span class="line"><span class="number">9</span>.color 取色器</span><br><span class="line"><span class="number">10</span>.date 日期</span><br><span class="line"><span class="number">11</span>.dateTime_local 日期和时间</span><br><span class="line"><span class="number">12</span>.email 邮箱，有<span class="selector-tag">@</span>校验功能</span><br><span class="line"><span class="number">13</span>.number 数字</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>.以上所有的表单项都应该有name和value属性，</span><br><span class="line">	radio和checkbox必须要有name和value</span><br><span class="line">	text和password可以省略value</span><br><span class="line">	</span><br><span class="line"><span class="number">2</span>.text和password还有一个placeholder输入提示属性，不会对输入的值造成干扰</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.radio和checkbox 要实现单选和复选，name属性值必须一致 ，checked 关键字表示默认选中</span><br></pre></td></tr></table></figure></li>
<li>label标签<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.for属性的属性值和input的id一致，可以实现点击lable,光标在input中闪烁</span><br></pre></td></tr></table></figure></li>
<li>textarea<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">文本域：多行多列的输入框</span><br><span class="line">rows:行数</span><br><span class="line">cols:列数，每一行可以写的字符数</span><br></pre></td></tr></table></figure></li>
<li>select 下拉框<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.option 子标签 </span><br><span class="line"><span class="number">2</span>.name属性在select中，value属性在option中</span><br></pre></td></tr></table></figure>
<h3><span id="div-he-span">div和span</span><a href="#div-he-span" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.div和span</span><br><span class="line">	- div 是一个容器，用于包裹其它的标签</span><br><span class="line">      是块积元素：占满一行，自带换行</span><br><span class="line"></span><br><span class="line">	- span 文本标签，用于包裹少量文字信息   </span><br><span class="line">	   是内联元素：不会换行</span><br><span class="line">	   span是行内元素：没有宽和高属性，高度是固定的，实际的宽度取决于元素中的内容，不会自动换行</span><br><span class="line">div和span都需要借助css才能实现样式调节，他们本身不具备任何样式。</span><br><span class="line"></span><br><span class="line">2.header和footer</span><br><span class="line">    &lt;header&gt;   前身：  &lt;div id&#x3D;&quot;header&quot;&gt;</span><br><span class="line">    &lt;footer&gt;   前身：  &lt;div id&#x3D;&quot;footer&quot;&gt;</span><br><span class="line">是h5新增的语义化标签，用于页面框架布局，增强代码可读性</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaEE关于Jquery必须会的基础使用</title>
    <url>/2020/08/01/JavaEE%E5%85%B3%E4%BA%8EJquery%E5%BF%85%E9%A1%BB%E4%BC%9A%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#jquery-ji-chu">Jquery基础</a><ul>
<li><a href="#yin-ru-jq-cha-jian-san-chong-fang-shi">引入jq插件三种方式</a></li>
<li><a href="#1-jquery-xuan-ze-qi">1.jquery选择器</a></li>
<li><a href="#2-shi-xian-dom-cao-zuo">2.实现dom操作</a></li>
<li><a href="#3-ji-ben-shi-jian">3.基本事件</a></li>
</ul>
</li>
<li><a href="#jquery-shi-xian-ajax">Jquery实现ajax</a><ul>
<li><a href="#1-ajax-qing-qiu">1.ajax请求</a></li>
<li><a href="#2-bian-li">2.遍历</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h2><span id="jquery-ji-chu">Jquery基础</span><a href="#jquery-ji-chu" class="header-anchor">#</a></h2><p>jQuery是一个快速，小型且功能丰富的JavaScript库。借助易于使用的API（可在多种浏览器中使用），它使HTML文档的遍历和操纵，事件处理，动画和Ajax等事情变得更加简单,极大的简化了js的dom和bom操作。<br>接下来我们看看JQuery的基础使用</p>
<h3><span id="yin-ru-jq-cha-jian-san-chong-fang-shi">引入jq插件三种方式</span><a href="#yin-ru-jq-cha-jian-san-chong-fang-shi" class="header-anchor">#</a></h3><p>1.使用相对路径</p>
<blockquote>
<p>&lt;script src=”../js/jquery-3.3.1.min.js”&gt;<br>2. /ajax为服务器根目录如下<br>&lt;script src=”/ajax/js/jquery-3.3.1.min.js”&gt;<br>3. 使用${pageContext.request.contextPath}表示服务器路径，推荐使用这种，当服务器路径变化时，不需要改变。<br>&lt;script src=”${pageContext.request.contextPath}/js/jquery-3.5.0.min.js”&gt;</p>
</blockquote>
<h3><span id="1-jquery-xuan-ze-qi">1.jquery选择器</span><a href="#1-jquery-xuan-ze-qi" class="header-anchor">#</a></h3><ol>
<li><p>id</p>
</li>
<li><p>class</p>
</li>
<li><p>标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;body&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;p1&quot; class&#x3D;&quot;p1&quot;&gt;好好学习，天天向上&lt;&#x2F;p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F;js方式</span><br><span class="line">    var p1&#x3D;document.getElementById(&quot;p1&quot;)</span><br><span class="line">    console.log(p1.innerHTML);</span><br><span class="line">    &#x2F;&#x2F;jq方式--id选择器</span><br><span class="line">    var ptext&#x3D;$(&quot;#p1&quot;).html()</span><br><span class="line">    console.log(ptext)</span><br><span class="line">    &#x2F;&#x2F;jq方式--class选择器</span><br><span class="line">    console.log($(&#39;.p1&#39;).html())</span><br><span class="line">    &#x2F;&#x2F; jq方式--标签选择器</span><br><span class="line">    console.log($(&#39;p&#39;).html())</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>
<h3><span id="2-shi-xian-dom-cao-zuo">2.实现dom操作</span><a href="#2-shi-xian-dom-cao-zuo" class="header-anchor">#</a></h3><p>html(): 获取/设置元素的标签体内容 相当于 js:innerHTML<br>text(): 获取/设置元素的标签体纯文本内容  相当于 js:innerText<br>val() : 获取/设置元素的value属性值  相当于 js:value<br>实例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;..&#x2F;js&#x2F;jquery-3.5.0.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;p1&quot;&gt;&lt;span&gt;我们要&lt;&#x2F;span&gt;好好学习天天向上&lt;&#x2F;p&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;qwer&quot; name&#x3D;&quot;name&quot; id&#x3D;&quot;name&quot;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; html(): 获取&#x2F;设置元素的标签体内容</span><br><span class="line">    &#x2F;&#x2F;js方式</span><br><span class="line">    var p1&#x3D;document.getElementById(&quot;p1&quot;);</span><br><span class="line">    alert(p1.innerHTML)</span><br><span class="line">&#x2F;&#x2F;  jq方式</span><br><span class="line">    var p&#x3D;$(&#39;#p1&#39;).html();</span><br><span class="line">    console.log(p);</span><br><span class="line">    &#x2F;&#x2F;text(): 获取&#x2F;设置元素的标签体纯文本内容</span><br><span class="line">    &#x2F;&#x2F; js方式</span><br><span class="line">    alert(p1.innerText)</span><br><span class="line">&#x2F;&#x2F;jq方式</span><br><span class="line">    var p&#x3D;$(&#39;#p1&#39;).text();</span><br><span class="line">    console.log(p);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; val() : 获取&#x2F;设置元素的value属性值</span><br><span class="line">    &#x2F;&#x2F; js方式</span><br><span class="line">    var input&#x3D;document.getElementById(&quot;name&quot;)</span><br><span class="line">    console.log(input.value)</span><br><span class="line">    &#x2F;&#x2F;jq方式</span><br><span class="line">    console.log($(&#39;input&#39;).val())</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3><span id="3-ji-ben-shi-jian">3.基本事件</span><a href="#3-ji-ben-shi-jian" class="header-anchor">#</a></h3></li>
<li><p>click 点击事件</p>
</li>
<li><p>blur 失去焦点事件</p>
</li>
<li><p>change 当值改变触发事件<br>实例代码</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;事件演示&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;ajax&#x2F;js&#x2F;jquery-3.5.0.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;确定&quot; id&#x3D;&quot;butn&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;确定&quot; id&#x3D;&quot;in&quot;&gt;</span><br><span class="line">&lt;select name&#x3D;&quot;se&quot; id&#x3D;&quot;se&quot;&gt;</span><br><span class="line">    &lt;option value&#x3D;&quot;0&quot;&gt;成熟&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;option value&#x3D;&quot;1&quot;&gt;青涩&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;option value&#x3D;&quot;2&quot;&gt;单纯&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;option value&#x3D;&quot;3&quot;&gt;轻浮&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;option value&#x3D;&quot;4&quot;&gt;激情&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; 点击事件</span><br><span class="line">    &#x2F;&#x2F;js实现</span><br><span class="line">    document.getElementById(&quot;butn&quot;).onclick&#x3D;function () &#123;</span><br><span class="line">        console.log(&#39;我被点了一下&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; jq实现</span><br><span class="line">    $(&#39;#butn&#39;).click(function () &#123;</span><br><span class="line">        console.log(&#39;我被点了一下&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F;2.失去焦点事件</span><br><span class="line">    $(&#39;#in&#39;).blur(function () &#123;</span><br><span class="line">console.log(this.value);&#x2F;&#x2F;js实现</span><br><span class="line">        console.log($(this).val())</span><br><span class="line">    &#125;)</span><br><span class="line">&#x2F;&#x2F;change事件</span><br><span class="line">    $(&#39;#se&#39;).change(function () &#123;</span><br><span class="line">    console.log($(this).val())</span><br><span class="line">        console.log(this.value)</span><br><span class="line">        console.log($(&#39;#se&gt;option:selected&#39;).text()) &#x2F;&#x2F;jq</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h2><span id="jquery-shi-xian-ajax">Jquery实现ajax</span><a href="#jquery-shi-xian-ajax" class="header-anchor">#</a></h2><h3><span id="1-ajax-qing-qiu">1.ajax请求</span><a href="#1-ajax-qing-qiu" class="header-anchor">#</a></h3><p>$.get()<br>$.post()  </p>
<p><strong>异步请求get的4个参数：<br>    1.url 请求路径，访问服务器servlet的路径<br>    2.请求参数，发送到服务器的参数<br>    3.回调函数，接收并处理服务器响应的数据的函数<br>    4.希望服务器响应的数据格式，通常有 text(字符串)  ，json （键值对形式的字符串)</strong></p>
<p>以下需求示例代码：<br>姓名输入框失去焦点的瞬间，就自动携带name参数，去后台查找，是否名称冲突，而不是点击了注册后才提交整个表单，此处只携带一个参数去后台，表单并没有提交</p>
<p>实现步骤：<br>    1.姓名输入框绑定一个失去焦点事件<br>    2.失去焦点事件实现函数中，发送异步请求，携带参数name和参数值去后台servlet<br>    3.在servlet中： 接收参数name ,判断是否重名 ，给出不同的反馈，响应给浏览器客户端不同的值<br>    4.客户端接收到servlet的反馈信息后，在姓名输入框的后面显示出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;ajax&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;%--动态上下文路径--%&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;js&#x2F;jquery-3.3.1.min.js&quot; &gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;form action&#x3D;&quot;&quot;&gt;</span><br><span class="line">        姓名：&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot; value&#x3D;&quot;&quot; id&#x3D;&quot;name&quot;&gt;&lt;span id&#x3D;&quot;sp&quot;&gt;&lt;&#x2F;span&gt;&lt;br&gt;</span><br><span class="line">        密码：&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;psw&quot;&gt;&lt;br&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;注册&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(&#39;#name&#39;).blur(function () &#123;</span><br><span class="line">    $.get(&#39;&#x2F;ajax&#x2F;ajax&#39;,&#123;&#39;name&#39;:$(this).val()&#125;,function (msg) &#123;</span><br><span class="line">        console.log(msg)</span><br><span class="line">        $(&#39;#sp&#39;).html(msg);</span><br><span class="line">    &#125;,&quot;text&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>servlet代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@WebServlet(&quot;&#x2F;ajax&quot;)</span><br><span class="line">public class AjaxServlet extends HttpServlet &#123;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;异步请求处理中，不做页面跳转，只是用response对象响应数据即可</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;异步请求进来啦&quot;);</span><br><span class="line">        &#x2F;&#x2F;1.获取异步请求发送的参数</span><br><span class="line">        String name &#x3D; request.getParameter(&quot;name&quot;);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        &#x2F;&#x2F;2.判断姓名是否冲突--简化业务：和 null比较</span><br><span class="line">        response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);</span><br><span class="line">        if(name.equals(&quot;null&quot;))&#123;</span><br><span class="line">            &#x2F;&#x2F;3.响应不同的数据 -- 处理响应中文乱码问题</span><br><span class="line">            response.getWriter().write(&quot;用户名冲突！&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            response.getWriter().write(&quot;用户名正常！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-bian-li">2.遍历</span><a href="#2-bian-li" class="header-anchor">#</a></h3><p>$.each()<br>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;遍历&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;%--动态上下文路径--%&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;js&#x2F;jquery-3.3.1.min.js&quot; &gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F;1.创建一个数组</span><br><span class="line">    var arr&#x3D;[1,2,3,&#39;abc&#39;];</span><br><span class="line">    &#x2F;&#x2F;2.遍历</span><br><span class="line">    $.each(arr,function (i,e) &#123;</span><br><span class="line">        console.log(i+&quot;--&quot;+e)</span><br><span class="line">    &#125;);</span><br><span class="line">&#x2F;&#x2F;i - 选择器的 index 位置</span><br><span class="line">&#x2F;&#x2F;e - 当前的元素（也可使用 &quot;this&quot; 选择器）</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb基础之JSP</title>
    <url>/2020/08/01/JavaWeb%E5%9F%BA%E7%A1%80%E4%B9%8BJSP/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#jsp-jian-jie">JSP简介</a></li>
<li><a href="#san-da-zhi-ling">三大指令</a><ul>
<li><a href="#zhi-ling-xie-fa">指令写法</a></li>
<li><a href="#cheng-xu-jiao-ben">程序脚本</a></li>
<li><a href="#page-zhi-ling">page指令</a></li>
<li><a href="#include-zhi-ling">include指令</a></li>
<li><a href="#taglib-zhi-ling">taglib指令</a></li>
</ul>
</li>
<li><a href="#jsp-dong-zuo-biao-qian">JSP动作标签</a></li>
<li><a href="#jiu-ge-nei-zhi-dui-xiang">九个内置对象</a></li>
<li><a href="#javawebmvc-she-ji-shi-yi-tu">JavaWebMVC设计示意图</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h2><span id="jsp-jian-jie">JSP简介</span><a href="#jsp-jian-jie" class="header-anchor">#</a></h2><p>JSP—Java Server Page。JSP相当于模板引擎，简化开发，封装servlet响应html标签的代码，从用户角度看其实就是就是一个网页；从程序员角度看待，他其实就是一个Java类。它继承了servlet，所以可以说jsp就是一个特别的servlet。</p>
<h2><span id="san-da-zhi-ling">三大指令</span><a href="#san-da-zhi-ling" class="header-anchor">#</a></h2><h3><span id="zhi-ling-xie-fa">指令写法</span><a href="#zhi-ling-xie-fa" class="header-anchor">#</a></h3><p>&lt;%@ 指令名字 %&gt;</p>
<h3><span id="cheng-xu-jiao-ben">程序脚本</span><a href="#cheng-xu-jiao-ben" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;%-- jsp注释 --%&gt;  该注释中的java脚本不会被执行</span><br><span class="line">&lt;!-- html注释--&gt;   该注释中的java脚本会被执行，但是执行结果会被注释</span><br><span class="line">&lt;% %&gt;叫做脚本片段，其中写的内容会翻译在Servlet的Service方法中，显然我们可以在Service方法中定义局部变量或者调用其他方法，但是不能在Service中再定义其他的方法，也就是我们可以在&lt;%%&gt;中定义局部变量或者调用方法，但不能定义方法。在jsp页面可以有多个脚本片段，但是多</span><br><span class="line">个脚本片段之间要保证结构完整。</span><br><span class="line">&lt;%!%&gt;称作声明，其中写的内容将来会直接翻译在Servlet类中，因为我们可以在类中定义方法和属性以及全局变量，所以我们可以在&lt;%!%&gt;中声明方法、属性、全局变量。</span><br><span class="line">&lt;%=%&gt;称作jsp表达式，用于将已经声明的变量或者表达式输出到网页上面。</span><br></pre></td></tr></table></figure>
<h3><span id="page-zhi-ling">page指令</span><a href="#page-zhi-ling" class="header-anchor">#</a></h3><p>用于声明jsp :  jsp=html+page指令</p>
<ol>
<li><p>contentType=”text/html;charset=UTF-8” 指定jsp文件的类型和字符集 </p>
</li>
<li><p>import=”java.util.*” 为jsp的脚本中的Java代码去导包</p>
</li>
<li><p>errorPage=”500.jsp” 如果当前页面发生异常，就跳转到500.jsp中</p>
</li>
<li><p>isErrorPage=”true” 承认自己是不是错误处理页面，如果为true就可以使用exception内置对象</p>
<pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</code></pre></li>
</ol>
<h3><span id="include-zhi-ling">include指令</span><a href="#include-zhi-ling" class="header-anchor">#</a></h3><p>静态包含，一个jsp页面可以包含另一个jsp页面，会被tomcat服务器编译成一个servlet,可以实现脚本互通。</p>
<pre><code>&lt;%@include file=&quot;b.jsp&quot;%&gt;</code></pre><h3><span id="taglib-zhi-ling">taglib指令</span><a href="#taglib-zhi-ling" class="header-anchor">#</a></h3><p>&lt;%@ taglib prefix=”” uri =””%&gt;<br>uri：标签库路径<br>prefix：标签库的别名  </p>
<h2><span id="jsp-dong-zuo-biao-qian">JSP动作标签</span><a href="#jsp-dong-zuo-biao-qian" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;jsp:include page&#x3D;&quot;&quot;&gt;&lt;&#x2F;jsp:include&gt;</span><br><span class="line"></span><br><span class="line">&lt;jsp:param value&#x3D;“”value&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;jsp:forward page&#x3D;&quot;&quot;&gt;&lt;&#x2F;jsp:forward&gt;</span><br><span class="line"></span><br><span class="line">jsp:include</span><br><span class="line">&lt;jsp:include page&#x3D;&quot;other.jsp&quot;&gt;&lt;&#x2F;jsp:include&gt;包含指定的页面，这里是动态包含。也就是不把包含的页面的所有元素标签全部拿出来输出。而是把它的运行结果拿过来。</span><br><span class="line">jsp:forward</span><br><span class="line">&lt;jsp:forward page&#x3D;&quot;&quot;&gt;&lt;&#x2F;jsp:forward&gt;请求转发：request.getRequestDispatcher(&quot;other.jsp&quot;).forward(request,response);</span><br><span class="line">jsp:param意思是：在包含某个页面的时候，或者在跳转某个页面的时候，加入这个参数。</span><br><span class="line">&lt;jsp:forward page&#x3D;&quot;other.jsp&quot;&gt;&lt;jsp:param value&#x3D;&quot;beijing&quot; name &#x3D;&quot;address&quot;&gt;&lt;&#x2F;jsp:forward&gt;</span><br></pre></td></tr></table></figure>
<h2><span id="jiu-ge-nei-zhi-dui-xiang">九个内置对象</span><a href="#jiu-ge-nei-zhi-dui-xiang" class="header-anchor">#</a></h2><p>1.域对象(从小到大)<br>    pageContext  (只能在当前页面使用)<br>    request   （仅限于转发之间的页面不支持int类型，都用string类型）<br>    session   （用于一次会话，浏览器和服务器都不关闭称为一次会话）<br>    application  （范围最大，只要服务器不管，浏览器随意）</p>
<p>2.其它<br>    <strong>response</strong><br>    客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。<br>    <strong>out</strong><br>    out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>&lt;%=%&gt;也表示输出<br><strong>page</strong><br>page对象就是指向当前JSP页面本身，有点象类中的this指针<br><strong>exception</strong><br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。<br><strong>config</strong><br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">使用域对象来存储数据</span><br><span class="line">&lt;%</span><br><span class="line">pageContext.setAttribute(<span class="string">"name"</span>, <span class="string">"page"</span>);</span><br><span class="line">request.setAttribute(<span class="string">"name"</span>, <span class="string">"request"</span>);</span><br><span class="line">session.setAttribute(<span class="string">"name"</span>, <span class="string">"session"</span>);</span><br><span class="line">application.setAttribute(<span class="string">"name"</span>, <span class="string">"application"</span>);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">取出四个域对象中的值&lt;br&gt;</span><br><span class="line">&lt;%=pageContext.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%=request.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%=session.getAttribute(<span class="string">"name"</span>)%&gt;</span><br><span class="line">&lt;%=application.getAttribute(<span class="string">"name"</span>)%&gt;</span><br></pre></td></tr></table></figure>
<p>servlet三大域对象：request,session,applicatioon(servletContext)<br> jsp中四大域对象：pageContext,request,session,applicatioon</p>
<h2><span id="javawebmvc-she-ji-shi-yi-tu">JavaWebMVC设计示意图</span><a href="#javawebmvc-she-ji-shi-yi-tu" class="header-anchor">#</a></h2><p> mvc  – 一种软件设计典范（取调存转） <img src="https://img-blog.csdnimg.cn/20200723174051611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JS快速入门笔记</title>
    <url>/2020/08/01/JS%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#js-jian-jie">js简介</a></li>
<li><a href="#js-ji-chu-yu-fa">js基础语法</a></li>
<li><a href="#js-dui-xiang">js对象</a><ul>
<li><a href="#1-function-dui-xiang">1.Function 对象</a></li>
<li><a href="#2-array-dui-xiang">2.Array对象</a></li>
<li><a href="#3-date-dui-xiang">3.Date 对象</a><ul>
<li><a href="#4-math-dui-xiang">4.Math对象</a></li>
<li><a href="#4-regexp-zheng-ze-dui-xiang">4.RegExp正则对象</a></li>
</ul>
</li>
<li><a href="#js-diao-shi-shi-shi-yong-xia-mian-de-dai-ma-geng-jia-fang-bian-zhao-cuo">js调试时使用下面的代码更加方便找错</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h2><span id="js-jian-jie">js简介</span><a href="#js-jian-jie" class="header-anchor">#</a></h2><p>1.概念</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.js是一个脚本语言--不用编译，直接被浏览器解析</span><br><span class="line">2.js可以实现动态的效果，如轮播图，还可以进行数据校验</span><br><span class="line">JAVASript&#x3D; EcmaScript(基础语法)+JAVASript自身(BOM+DOM)</span><br></pre></td></tr></table></figure>

<h2><span id="js-ji-chu-yu-fa">js基础语法</span><a href="#js-ji-chu-yu-fa" class="header-anchor">#</a></h2><ol>
<li>js和html的结合方式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.内部 js:  写一个script 标签，标签体内容就是js代码</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;script&gt;            &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">2.外部 js: 单独写一个js文件，在head标签中使用script标签引入外部js文件</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;a.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">1. script标签和html标签的先后顺序，会导致加载的顺序不一样 ，从上到下加载</span><br><span class="line">2. 页面中可以有多个script标签</span><br><span class="line">3. 如果script标签是引入外部js文件，不能简写为单标签，标签体中也不能再写js代码</span><br></pre></td></tr></table></figure></li>
<li>注释<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;单行注释</span><br><span class="line">&#x2F;* 多行注释 *&#x2F;</span><br></pre></td></tr></table></figure></li>
<li>数据类型<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. number:  整数和小数 NaN(非数字)</span><br><span class="line">2. string:  字符串 ，单引号和双引号都可以 &#39;agc&#39; &quot;abc&quot;</span><br><span class="line">3. boolean: true&#x2F;false</span><br><span class="line">4. null: 空对象</span><br><span class="line">5. undefined：变量没有初始化</span><br></pre></td></tr></table></figure></li>
<li>变量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java是强类型语言：定义一个变量，数据类型一旦声明，就不可以更改，更不可以装其它类型的数据</span><br><span class="line">js是弱类型语言：定义一个变量，数据类型可以随意变化，可以装任意类型的数据</span><br><span class="line">定义变量 </span><br><span class="line">  var 变量名&#x3D;变量值;</span><br><span class="line">  </span><br><span class="line">typeof(变量名) -- 返回一个原始数据类型</span><br><span class="line">console.log(&quot;a是一个数字&quot;); 在浏览器控制台输出 F12按键</span><br><span class="line">document.wirte(&quot;hello&quot;);在浏览器里输出显示出来</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>5.一元运算符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. ++ --  +(正号) -(负号)</span><br><span class="line">2. +可以将其它类型转为number类型</span><br><span class="line">	string : </span><br><span class="line">    	var a&#x3D;&quot;123&quot;;  +a 就是number类型</span><br><span class="line">    	var a&#x3D;&quot;abc&quot;;  +a 就是 NaN 非数字的类型</span><br><span class="line">    boolean:</span><br><span class="line">        var a&#x3D;true; +a 输出结果：1</span><br><span class="line">        var a&#x3D;false; +a 输出结果：0</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>算术运算符&amp;比较运算符<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4. + - * &#x2F; %   </span><br><span class="line">2.&gt; &lt;  &gt;&#x3D;  &lt;&#x3D;  !&#x3D;  </span><br><span class="line">&#x3D;&#x3D;判断内容是否相同</span><br><span class="line">&#x3D;&#x3D;&#x3D;(全等，比较内容和类型)</span><br></pre></td></tr></table></figure></li>
<li>逻辑运算符<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;&amp; || ！</span><br><span class="line">! 可以将其它数据类型转换成boolean:</span><br><span class="line">	1.number : 0或NaN --&gt; false; 其它--&gt;true</span><br><span class="line">	2.string : &quot;&quot; --&gt; false  ;其它--&gt;true, &quot; &quot;--&gt;true</span><br><span class="line">	3.null&amp;undefined --&gt;false</span><br><span class="line">	4.对象&#x3D;&#x3D;null --&gt;false ; 对象!&#x3D;null --&gt;true</span><br><span class="line">	</span><br><span class="line">基于上面的类型转换，可以简写：</span><br><span class="line">1.死循环 while(1)&#123;&#125;</span><br><span class="line">2.非空验证：</span><br><span class="line">	*对象var obj： if(obj)&#123;&#125; 相当于 if(obj！&#x3D;null)&#123;&#125;</span><br><span class="line">	*字符串 var str; if(str)&#123;&#125; 相当于 if(str！&#x3D; null &amp;&amp; str.length&gt;0)&#123;&#125;,过滤了null和“”</span><br></pre></td></tr></table></figure></li>
<li>三元运算符<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">条件判断?表达式1:表达式2; -- 通常可以直接输出，或者给其它变量赋值</span><br></pre></td></tr></table></figure></li>
<li>特殊语法(归功于浏览器解析功能强大)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8. 每一条语句后的分号，可以省略，前提是 一行只有一条语句</span><br><span class="line">9. 定义变量可以省略var关键字:相当于定义了一个全局变量</span><br><span class="line">10. 变量名虽然可以相同，但是后者会覆盖前者</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>流程控制语句<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12. if...else...</span><br><span class="line">13. switch:</span><br><span class="line">	* 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)</span><br><span class="line">	* switch(变量):</span><br><span class="line">			case 值:</span><br><span class="line">	* 在JS中,switch语句可以接受任意的原始数据类型</span><br><span class="line">14. while</span><br><span class="line">15. do...while</span><br><span class="line">16. for  增强：for of    for in </span><br><span class="line"></span><br><span class="line">    var t&#x3D;[1,2,3,&#39;a&#39;,&#39;b&#39;];</span><br><span class="line">    for (var i&#x3D;0;i&lt;t.length;i++)&#123;</span><br><span class="line">        console.log(t[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(var i of t)&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for(var i in t)&#123;</span><br><span class="line">        console.log(t[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2><span id="js-dui-xiang">js对象</span><a href="#js-dui-xiang" class="header-anchor">#</a></h2><h3><span id="1-function-dui-xiang">1.Function 对象</span><a href="#1-function-dui-xiang" class="header-anchor">#</a></h3><ol>
<li>函数的三种定义方式以及调用</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 1.最常用的方式</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a=<span class="number">6</span></span><br><span class="line">        alert(a);</span><br><span class="line">    &#125;</span><br><span class="line">   fun1(); <span class="comment">//调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.匿名函数--搭配js事件</span></span><br><span class="line">    <span class="keyword">var</span> fun2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    fun2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.动态函数</span></span><br><span class="line">    <span class="keyword">var</span> fun3=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>,<span class="string">"alert(a)"</span>);</span><br><span class="line">    fun3(<span class="number">1</span>);</span><br><span class="line">js中没有函数的重载，后面的重名函数会覆盖前面的，和参数构造无关。</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>形参和实参个数关系 ，length<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形参的定义：直接写形参名</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(a+b);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//实参个数可以不和形参个数相同</span></span><br><span class="line">   fun1();<span class="comment">//NaN</span></span><br><span class="line">   fun1(<span class="number">3</span>);<span class="comment">//NaN</span></span><br><span class="line">   fun1(<span class="number">3</span>,<span class="number">4</span>);<span class="comment">//7</span></span><br><span class="line">   fun1(<span class="number">3</span>,<span class="number">4</span>,<span class="string">"abc"</span>);<span class="comment">//7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//length属性：形参的个数</span></span><br><span class="line"><span class="built_in">console</span>.log(fun1.length);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
为了解决重载函数引入了实参数组arguments</li>
<li>实参数组arguments<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//arguments实参数组：接收所有的实参，放在该数组中存起来</span></span><br><span class="line">        <span class="keyword">var</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;<span class="built_in">arguments</span>.length ; i++) &#123;</span><br><span class="line">            sum+=<span class="built_in">arguments</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//调用函数</span></span><br><span class="line">    fun1(<span class="number">3</span>,<span class="number">4</span>,+<span class="string">"12"</span>,<span class="number">5</span>);<span class="comment">//24</span></span><br><span class="line">    fun1(<span class="number">3</span>,<span class="number">4</span>,<span class="string">"12"</span>,<span class="number">5</span>);<span class="comment">//7125</span></span><br><span class="line">    fun1(<span class="number">3</span>,<span class="number">4</span>,<span class="literal">true</span>,<span class="number">5</span>);<span class="comment">//13</span></span><br><span class="line">    fun1(<span class="number">3</span>,<span class="number">4</span>,+<span class="literal">true</span>,<span class="number">5</span>);<span class="comment">//13</span></span><br></pre></td></tr></table></figure>
<h3><span id="2-array-dui-xiang">2.Array对象</span><a href="#2-array-dui-xiang" class="header-anchor">#</a></h3></li>
<li>三种定义方式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. var arr&#x3D;new Array(1,2,&quot;abc&quot;); -- (数组的元素)</span><br><span class="line">3. var arr&#x3D;new Array(5); -- (数组的长度)</span><br><span class="line">4. var arr&#x3D;[1,3,6,9,&quot;a&quot;];</span><br><span class="line">参数是一个数表示初始长度，参数大于一个，表示初始值</span><br></pre></td></tr></table></figure></li>
<li>数组的特点<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.长度随意</span><br><span class="line">2.类型随意</span><br><span class="line">3.参数是一个数表示初始长度，参数大于一个，表示初始值</span><br></pre></td></tr></table></figure></li>
<li>数组对象的方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8. join -- 连接  ,如： arr.join(&quot;--&quot;);  参数表示元素之间的连接符号，默认逗号隔开</span><br><span class="line">9. push -- 添加元素 ，如： arr.push(&quot;abc&quot;); 向数组的末尾添加元素</span><br><span class="line">10. pop  -- 删除元素，如： arr.pop(); 删除数组末尾的元素</span><br></pre></td></tr></table></figure>
<h3><span id="3-date-dui-xiang">3.Date 对象</span><a href="#3-date-dui-xiang" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.创建当前时间</span><br><span class="line"> 	var date&#x3D;new Date();</span><br><span class="line">2.方法：</span><br><span class="line">	*toLocalString(); 本地日期格式 </span><br><span class="line">	toLocaleTimeString()</span><br><span class="line">	toLocaleDateString()</span><br><span class="line">	*getTime();返回的是1970年1月1日零点到当前时间的毫秒数</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4><span id="4-math-dui-xiang">4.Math对象</span><a href="#4-math-dui-xiang" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.不需要创建对象，直接调用静态工具方法</span><br><span class="line">2.方法：</span><br><span class="line">	*random(); [0,1)之间的随机小数</span><br><span class="line">	*ceil();天花板 向上取整 ，如 Math.ceil(2.1);&#x2F;&#x2F; 3</span><br><span class="line">	*floor();地板 向下取整 ，如 Math.floor(2.9);&#x2F;&#x2F; 2</span><br><span class="line">	*round();四舍五入 ，如 Math.round(2.4);--&gt; 2 ;  Math.round(2.5);--&gt; 3</span><br><span class="line">3.属性：PI: 3.1415926...</span><br></pre></td></tr></table></figure>
<ul>
<li>例子：求 [3,8]之间的随机整数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   1. [0,1) * 6 ==&gt; [0,6)</span></span><br><span class="line"><span class="comment">   2. [0,6)+3 ==&gt; [3,9)==[3,8]</span></span><br><span class="line"><span class="comment">   3. floor 向下取整</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">var</span> a=<span class="built_in">Math</span>.random();</span><br><span class="line">    <span class="keyword">var</span> v=<span class="built_in">Math</span>.floor(a*<span class="number">6</span>+<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br></pre></td></tr></table></figure>
<h4><span id="4-regexp-zheng-ze-dui-xiang">4.RegExp正则对象</span><a href="#4-regexp-zheng-ze-dui-xiang" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.单个字符：</span><br><span class="line">	[a]  [h-x]  [a-z]  [a-zA-Z0-9_]&#x3D;&#x3D; \w    [1-6]     [0-9] &#x3D;&#x3D; \d 数字 </span><br><span class="line">	</span><br><span class="line">2.量词符号</span><br><span class="line">	？: 0或1次</span><br><span class="line">	* :任意次数 [0,正无穷]</span><br><span class="line">	+ :[1,正无穷]</span><br><span class="line">	&#123;x&#125;:表示出现x次</span><br><span class="line">	&#123;m,n&#125; : m &lt;&#x3D; 次数 &lt;&#x3D; n</span><br><span class="line">	&#123;m,&#125;  : m &lt;&#x3D; 次数</span><br><span class="line">	&#123;,n&#125;  : 次数 &lt;&#x3D; n</span><br><span class="line">3.开头^和结尾$</span><br></pre></td></tr></table></figure></li>
<li>使用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.创建对象：</span><br><span class="line">	*var reg&#x3D;new RegExp(&quot;正则表达式&quot;);</span><br><span class="line">	*var reg&#x3D;&#x2F;正则表达式&#x2F;;</span><br><span class="line"></span><br><span class="line">2.方法：test()</span><br><span class="line">reg.test(s);</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>例子 验证表单输入必须是6-8位中文<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;正则表达式&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;.&#x2F;服务器.html&quot; id&#x3D;&quot;form&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">&lt;label for&#x3D;&quot;name&quot;&gt;姓名：&lt;&#x2F;label&gt;</span><br><span class="line">&lt;input name&#x3D;&quot;name&quot; type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot;&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;submit&quot;value&#x3D;&quot;提交&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.getElementById(&quot;form&quot;).onsubmit&#x3D;function(ev)&#123;</span><br><span class="line">        var name&#x3D;document.getElementById(&quot;name&quot;).value;</span><br><span class="line">        console.log(name);</span><br><span class="line">        &#x2F;&#x2F; if (name.length&gt;&#x3D;6&amp;&amp;name.length&lt;&#x3D;8)&#123;</span><br><span class="line">        &#x2F;&#x2F;     return true</span><br><span class="line">        var reg&#x3D;&#x2F;^[\u4e00-\u9fa5]&#123;6,8&#125;$&#x2F;</span><br><span class="line">        return reg.test(name);</span><br><span class="line">        &#x2F;&#x2F; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3><span id="js-diao-shi-shi-shi-yong-xia-mian-de-dai-ma-geng-jia-fang-bian-zhao-cuo">js调试时使用下面的代码更加方便找错</span><a href="#js-diao-shi-shi-shi-yong-xia-mian-de-dai-ma-geng-jia-fang-bian-zhao-cuo" class="header-anchor">#</a></h3></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">onerror=<span class="keyword">function</span>(m,f,r,c)&#123;alert(<span class="string">"错误信息："</span>+m+<span class="string">"\n出错文件："</span>+f+<span class="string">"\n出错行："</span>+r+<span class="string">"\n出错列："</span>+c)&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux目录结构</title>
    <url>/2020/04/08/Linux_FileFlat/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-linux-mu-lu-jie-gou-shi-shi-me">1.Linux目录结构是什么？</a></li>
<li><a href="#2-linux-xi-tong-zhong-de-mei-ge-wen-jian-he-mu-lu-du-you-fang-wen-xu-ke-quan-xian">2.Linux系统中的每个文件和目录都有访问许可权限，</a></li>
</ul>
<!-- tocstop -->

</div>
## 1.Linux目录结构是什么？

<a id="more"></a>

<p>整个Linux系统最重要的地方就是在于目录树架构，所谓的目录树架构就是以根目录为主， 然后向下呈现分支状的目录结构的一种档案架构。我们可以先通过下面这幅图来直观的认识一下Linux的目录结构。<br><img src="https://img-blog.csdnimg.cn/20200325230517460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt><br> 对于这样一些目录，根据FHS（Filesystem Hierarchy Standard）规范了每个目录下面应该放置什么样的数据，主要是依据文件系统使用的频繁与否与是否允许使用者随意更动来划分。<br> 可分享的(shareable) 不可分享的(unshareable)<br>不变的(static) /usr (软件放置处) /etc (配置文件)<br>/opt (第三方协力软件) /boot (开机与核心档)<br>可变动的(variable) /var/mail (使用者邮件信箱) /var/run (程序相关)<br>/var/spool/news (新闻组) /var/lock (程序相关)<br>2.    主要目录的简介</p>
<p>a)   根目录（/）</p>
<p>根目录是整个系统最重要的一个目录，因为所有的目录都是由根目录衍生出来的。只有root用户才具有在该目录下写权限。</p>
<p>b)   /bin目录 – 用户二进制文件</p>
<p>包含二进制的可执行文件，你需要的常见的Linux命令都位于此目录下。<br><img src="https://img-blog.csdnimg.cn/20200325230745949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<p>c)   /sbin目录 – 系统二进制文件<br><img src="https://img-blog.csdnimg.cn/20200325230805491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt><br>这个目录下的命令通常由系统管理员使用， 对系统进行维护。</p>
<p>d)   /etc– 配置文件<br><img src="https://img-blog.csdnimg.cn/20200325230823141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt><br>包含所有程序所需要的配置文件，也包含用于启动/停止单个程序的起动和关闭shell脚本。</p>
<p>e)   /dev-设备文件<br><img src="https://img-blog.csdnimg.cn/20200325230854277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt><br>包含设备文件，包括终端设备、USB或连接到系统的任何设备，如网卡等。</p>
<p>f)   /proc-进程信息文件</p>
<p>这是一个虚拟的文件系统，包含有关正在运行的进程信息。</p>
<p>g)   /var-变量文件</p>
<p>包含目录下内容可变的文件，例如，系统日志文件（/var/log）;包和数据库文件（/var/lib）;电子邮件（/var/mail）;打印队列（/var/spool）;锁文件（/var/lock）;多次重新启动需要的临时文件（/var/tmp）。</p>
<p>h)   /tem-临时文件</p>
<p>包含系统和用户创建的临时文件，当系统重启时，文件消失。</p>
<p>i)   /usr-用户程序</p>
<p>包含二进制文件、库文件、文档和二级程序的源代码。</p>
<p>/usr/bin中包含用户程序的二进制文件。如果你在/bin中找不到用户二进制文件，到/usr/bin目录看看。例如：at、awk、cc、less、scp。</p>
<p>/usr/sbin中包含系统管理员的二进制文件。如果你在/sbin中找不到系统二进制文件，到/usr/sbin目录看看。例如：atd、cron、sshd、useradd、userdel。</p>
<p>/usr/lib中包含了/usr/bin和/usr/sbin用到的库。</p>
<p>/usr/local中包含了从源安装的用户程序。例如，当你从源安装Apache，它会在/usr/local/apache2中</p>
<p>j)  /home -HOME目录</p>
<p>包含所有用户的个人档案，Linux是多用户的系统，所以用该目录保存各用户的信息。</p>
<p>k)  /boot -引导加载程序</p>
<p>包含引导加载程序相关的文件。</p>
<p>l)  /lib -系统库</p>
<p>包含支持位于/lib和/sbin下的二进制文件的库文件。</p>
<p>m)  /opt -可选的附加应用程序</p>
<p>n)  /mnt -挂载目录</p>
<h2><span id="2-linux-xi-tong-zhong-de-mei-ge-wen-jian-he-mu-lu-du-you-fang-wen-xu-ke-quan-xian">2.Linux系统中的每个文件和目录都有访问许可权限，</span><a href="#2-linux-xi-tong-zhong-de-mei-ge-wen-jian-he-mu-lu-du-you-fang-wen-xu-ke-quan-xian" class="header-anchor">#</a></h2><p>用它来确定谁可以通过何种方式对文件和目录进行访问和操作。<br>文件或目录的访问权 限分为只读，只写和可执行三种。</p>
<p>这里显示的权限是依次排列的，分别为：[用户][同组][其他]<br>用户权限，就是你自己的权限。英文：user，简写：u（覆盖标号123）<br>用户组权限，就是和你同组的人的权限。英文：group，简写：g（覆盖标号456）<br>其他权限，就是不和你同组的人的权限。英文：others，简写：o（覆盖标号789）<br>所有人的权限，英文：all，简写：a</p>
<p>r, 即Read，读，权限值为4<br>w，即Write，写，权限值为2<br>x，即eXecute，执行，权限值为1<br>-，在标号0位置，表示普通的文件<br>-，其他位置，表示对应权限未开启，不具备权限<br>d，即directory，表示目录文件</p>
<p>无任何权限：数字0表示<br>开所有权限：数字7表示，即7=4+2+1</p>
<p>chmod 命令是用于改变文件或目录的访问权限。</p>
<ul>
<li>表示增加权限，如u+x, u+r, u+w, g+w, g+r, o+r， a+r等</li>
</ul>
<ul>
<li>表示取消权限，如u-x, u-r, u-w, g-w, g-r, o-r， a-r等<br>= 表示赋予给定权限，并取消其他所有权限（如果有的话，如原来u是rwx，设置u=r，u就剩r）</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven3在ideal中的配置</title>
    <url>/2020/08/01/Maven3%E5%9C%A8ideal%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#xia-zai-maven">下载Maven</a></li>
<li><a href="#2-an-zhuang-he-pei-zhi">2.安装和配置</a></li>
<li><a href="#ideal-zhong-pei-zhi-maven">ideal中配置maven</a></li>
<li><a href="#yi-lai-guan-li">依赖管理</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h2><span id="xia-zai-maven">下载Maven</span><a href="#xia-zai-maven" class="header-anchor">#</a></h2><p><a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">官网下载地址</a><br><a href="https://mirrors.huaweicloud.com/apache/maven/maven-3/" target="_blank" rel="noopener">华为云下载地址</a>在这里下载更快<br>注意！！！  idea2019版与maven3.6.2版本不兼容，我们授课使用3.5.2版本或3.5.4</p>
<ul>
<li>下载往期版本<br><a href="https://archive.apache.org/dist/maven/maven-3/" target="_blank" rel="noopener">往期版本下载地址</a><br><img src="https://img-blog.csdnimg.cn/20200731003247457.png" alt><h2><span id="2-an-zhuang-he-pei-zhi">2.安装和配置</span><a href="#2-an-zhuang-he-pei-zhi" class="header-anchor">#</a></h2>解压<br><img src="https://img-blog.csdnimg.cn/20200731003541771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>配置环境变量<br><img src="https://img-blog.csdnimg.cn/20200731003750443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>变量值为Maven安装目录<br><img src="https://img-blog.csdnimg.cn/20200731003832602.png" alt="在这里插入图片描述"><br>在系统变量Path中添加变量值：</li>
</ul>
<p>;%MAVEN_HOME%\bin</p>
<p>检查是否安装成功<br><img src="https://img-blog.csdnimg.cn/20200731004023240.png" alt="在这里插入图片描述"><br>配置本地仓库和私服<br>在maven安装目录下的conf文件夹中找到settings.xml文件<br><img src="https://img-blog.csdnimg.cn/20200731004154195.png" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.本地仓库的路径</span><br><span class="line">&lt;localRepository&gt;D:\rep_boot&lt;&#x2F;localRepository&gt;</span><br><span class="line"></span><br><span class="line">2.阿里云镜像</span><br><span class="line">&lt;mirror&gt;  </span><br><span class="line">	  &lt;id&gt;alimaven&lt;&#x2F;id&gt;  </span><br><span class="line">	  &lt;name&gt;aliyun maven&lt;&#x2F;name&gt;  </span><br><span class="line">	  &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line">	  &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;          </span><br><span class="line">&lt;&#x2F;mirror&gt;</span><br><span class="line">或华为镜像，二者只能选一个</span><br><span class="line"> &lt;mirror&gt;</span><br><span class="line">      &lt;id&gt;huaweicloud&lt;&#x2F;id&gt;</span><br><span class="line">      &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt;</span><br><span class="line">      &lt;url&gt;https:&#x2F;&#x2F;mirrors.huaweicloud.com&#x2F;repository&#x2F;maven&#x2F;&lt;&#x2F;url&gt;</span><br><span class="line"> &lt;&#x2F;mirror&gt;</span><br><span class="line"></span><br><span class="line">3.jdk版本</span><br><span class="line"> &lt;profile&gt;</span><br><span class="line">      &lt;id&gt;jdk-14&lt;&#x2F;id&gt;</span><br><span class="line">      &lt;activation&gt;</span><br><span class="line">        &lt;jdk&gt;14&lt;&#x2F;jdk&gt;</span><br><span class="line">      &lt;&#x2F;activation&gt;</span><br><span class="line">	  &lt;properties&gt;</span><br><span class="line">		&lt;maven.compiler.source&gt;14&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">			&lt;maven.compiler.target&gt;14&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">			&lt;maven.compiler.compilerVersion&gt;14&lt;&#x2F;maven.compiler.compilerVersion&gt;</span><br><span class="line">	  &lt;&#x2F;properties&gt;</span><br><span class="line">  &lt;&#x2F;profile&gt;</span><br></pre></td></tr></table></figure>
<h2><span id="ideal-zhong-pei-zhi-maven">ideal中配置maven</span><a href="#ideal-zhong-pei-zhi-maven" class="header-anchor">#</a></h2><p><strong>1.进入设置</strong><br><img src="https://img-blog.csdnimg.cn/20200731004451883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200731004512771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200731004537693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020073100463949.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200731004708194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="yi-lai-guan-li">依赖管理</span><a href="#yi-lai-guan-li" class="header-anchor">#</a></h2><p>创建后的工程结构是不完善的，我们还需要在main下添加java和resources两个文件夹<br><img src="https://img-blog.csdnimg.cn/20200731004930378.png" alt><br><strong>导入依赖</strong></p>
<p><strong>以最原始的jdbc操作为案例</strong></p>
<ul>
<li><p>在pom.xml中导入mysql驱动jar包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.38<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>jar包坐标来源，<a href="https://mvnrepository.com/" target="_blank" rel="noopener">中央仓库</a></li>
<li><a href="https://mvnrepository.com/" target="_blank" rel="noopener">https://mvnrepository.com/</a><br><img src="https://img-blog.csdnimg.cn/20200731005142794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
<p><strong>坐标详解</strong><br><img src="https://img-blog.csdnimg.cn/20200731005300942.png" alt="在这里插入图片描述"><br><strong>依赖范围</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">A 依赖 B，需要在 A 的 pom.xml 文件中添加 B 的坐标，添加坐标时需要指定依赖范围，依赖范围包</span><br><span class="line">括：</span><br><span class="line"></span><br><span class="line">compile：此范围为默认依赖范围。作用在： 编译、测试、运行</span><br><span class="line"></span><br><span class="line">provided：只有在当 JDK 或者一个容器已提供该依赖之后才使用，在编译和测试时需要，在运行时不需要。</span><br><span class="line">比如： tomcat 容器包含servlet api，但是在编译和测试时需要，运行时使用tomcat内置的servlet即可。</span><br><span class="line"></span><br><span class="line">runtime：在运行和测试系统的时候需要，但在编译的时候不需要。</span><br><span class="line">比如：jdbc的驱动包。</span><br><span class="line"></span><br><span class="line">test：在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用，</span><br><span class="line">比如：junit。</span><br><span class="line"></span><br><span class="line">system：system依赖不推荐使用。</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020073100535468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaEE中servlet的应用</title>
    <url>/2020/08/01/JavaEE%E4%B8%ADservlet%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#servlet-jian-jie">servlet简介</a></li>
<li><a href="#servlet-de-shi-yong">servlet的使用</a><ul>
<li><a href="#zai-web-xml-zhong-pei-zhi">在web.xml中配置：</a></li>
<li><a href="#pei-zhi-ban-shi-yong-servlet-de-san-chong-fang-fa">配置版使用servlet的三种方法</a><ul>
<li><a href="#1-shi-xian-servlet-jie-kou">1.实现Servlet接口</a></li>
<li><a href="#2-ji-cheng-genericservlet-chou-xiang-lei">2.继承GenericServlet抽象类</a></li>
<li><a href="#3-ji-cheng-httpservlet-feng-zhuang-liao-http-xie-yi-de-chou-xiang-lei">3.继承HttpServlet封装了http协议的抽象类</a></li>
</ul>
</li>
<li><a href="#shi-yong-zhu-jie-ban">使用注解版</a><ul>
<li><a href="#liang-chong-fang-fa-de-bi-jiao">两种方法的比较</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#request-he-response-dui-xiang">request和response对象</a><ul>
<li><a href="#request-he-response-fen-gong">request和response分工</a></li>
<li><a href="#1-request-dui-xiang">1.request对象</a><ul>
<li><a href="#zhuan-fa">转发</a></li>
<li><a href="#yu-dui-xiang-yu-nei-chuan-di-can-shu">域对象（域内传递参数）</a></li>
</ul>
</li>
<li><a href="#response-dui-xiang">Response对象</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h2><span id="servlet-jian-jie">servlet简介</span><a href="#servlet-jian-jie" class="header-anchor">#</a></h2><p>Tomcat其实是Web服务器和Servlet容器的结合体。Tomcat才与浏览器客户端打交道。Servlet可以简单的理解位Java里的一个接口。<br>1.servlet是服务器中核心处理单元<br>2.服务器中有多个不同的servlet,每一个servlet负责不同的业务，处理不同的请求<br>3.servlet的对象创建和调用其方法，都是tomcat来完成的。<br>4.一个类必须实现servlet这个接口，才能算是servlet的家族成员。   </p>
<h2><span id="servlet-de-shi-yong">servlet的使用</span><a href="#servlet-de-shi-yong" class="header-anchor">#</a></h2><h3><span id="zai-web-xml-zhong-pei-zhi">在web.xml中配置：</span><a href="#zai-web-xml-zhong-pei-zhi" class="header-anchor">#</a></h3><pre><code>servlet标签：告诉服务器servlet在哪儿，还给servlet取个名
servlet-mapping标签：拦截所有请求，告诉浏览器如何访问到该servlet,提供url访问路径，同时和servlet标签关联</code></pre><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!--    拦截请求--&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">      &lt;!--servlet的名字一定是在Web服务器中进行注册声明的--&gt;</span><br><span class="line">    &lt;servlet-name&gt;Servlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;!--servlet的响应路径--&gt;</span><br><span class="line">    &lt;url-pattern&gt;/UserLoginServlet&lt;/url-pattern&gt;</span><br><span class="line">    &lt;!--/是Web服务器的根目录--&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;!--    分配请求给servlet处理--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">      &lt;!-- 指明servlet实例的名字，具有唯一性--&gt;</span><br><span class="line">    &lt;servlet-name&gt;Servlet&lt;/servlet-name&gt;</span><br><span class="line"> &lt;!-- 指明servlet的src目录下的后台实现类的包路径--&gt;</span><br><span class="line">        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;     </span><br><span class="line">    &lt;/servlet&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ol>
<li>只有web文件夹下的内容才会被部署在服务器上</li>
<li>web文件夹下的WEB-INF文件夹里面的资源是受保护的，不能直接被访问<br><img src="https://img-blog.csdnimg.cn/20200722220515159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt><h3><span id="pei-zhi-ban-shi-yong-servlet-de-san-chong-fang-fa">配置版使用servlet的三种方法</span><a href="#pei-zhi-ban-shi-yong-servlet-de-san-chong-fang-fa" class="header-anchor">#</a></h3><h4><span id="1-shi-xian-servlet-jie-kou">1.实现Servlet接口</span><a href="#1-shi-xian-servlet-jie-kou" class="header-anchor">#</a></h4>共5个方法，其中最重要的3个是生命周期方法:init()  service() destroy()</li>
<li>init(); 初始化方法，在servlet第一次被请求时调用，表示servlet对象创建出来了<pre><code>只会被调用一次，说明servlet是单例，一个servlet类只能创建一个对象</code></pre></li>
<li>service();为人民服务方法，浏览器访问该servlet时会被服务器调用，表示提供一个服务</li>
<li>destroy();销毁方法，在服务器正常关闭时调用，表示当前servlet对象销毁了。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Helloservlet implements Servlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(ServletConfig servletConfig) throws ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">"servlet 对象诞生"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ServletConfig <span class="function"><span class="title">getServletConfig</span></span>() &#123;</span><br><span class="line">        //servlet配置信息</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line">//servlet中真正处理请求的是service方法</span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">"为人民服务！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">getServletInfo</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">destroy</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"servlet销毁!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
servlet的访问：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、首先，从浏览器中发送请求，是从当前工程中的路径与servlet-mapping标签中的url-pattern的标 签值进行匹配。</span><br><span class="line">2、根据这个映射值，找到servlet-mapping标签中的servlet-name的值与servlet标签中的servlet-name进行匹</span><br><span class="line">3、匹配到以后，找到servlet标签中的servlet-class标签中对应servlet类的src文件夹下的全路径。</span><br><span class="line">4、从而调用并执行相应的servlet类。</span><br></pre></td></tr></table></figure>
<h4><span id="2-ji-cheng-genericservlet-chou-xiang-lei">2.继承GenericServlet抽象类</span><a href="#2-ji-cheng-genericservlet-chou-xiang-lei" class="header-anchor">#</a></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Hello2servlet extends GenericServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">    System.out.println(<span class="string">"第二版本servlet，为人民服务！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
实现了Servlet接口，保留service方法仍是抽象，其它方法做了空实现<h4><span id="3-ji-cheng-httpservlet-feng-zhuang-liao-http-xie-yi-de-chou-xiang-lei">3.继承HttpServlet封装了http协议的抽象类</span><a href="#3-ji-cheng-httpservlet-feng-zhuang-liao-http-xie-yi-de-chou-xiang-lei" class="header-anchor">#</a></h4></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">public class Hello3servlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">"我是专门请求get请求的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">"我是专门请求post请求的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写了service方法，自定义了doGet/doPost方法，用来分别处理get请求和post请求。<br>并在自己的service方法中对请求方式进行判断，然后分别调用doGet和doPost方法。<br><strong>使用上面三种方法需要配置web.xml文件，我在上面已经提到了。</strong></p>
<h3><span id="shi-yong-zhu-jie-ban">使用注解版</span><a href="#shi-yong-zhu-jie-ban" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@WebServlet(name = <span class="string">"AServlet"</span>,urlPatterns=<span class="string">"/as"</span>)</span><br><span class="line">//还可以用@WebServlet(<span class="string">"/as"</span>)</span><br><span class="line">public class AServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="liang-chong-fang-fa-de-bi-jiao">两种方法的比较</span><a href="#liang-chong-fang-fa-de-bi-jiao" class="header-anchor">#</a></h4><p>注解访问servlet：</p>
<p>优点：代码少，可读性强，易于理解。</p>
<p>缺点：如果大量使用servlet注解，servlet类文件数量过多，不便于查找和修改。</p>
<p>web配置文件访问servlet：</p>
<p>优点：集中管理各servlet类路径的映射路径，便于修改和管理。</p>
<p>缺点：代码多，可读性不强，不易于理解。</p>
<h2><span id="request-he-response-dui-xiang">request和response对象</span><a href="#request-he-response-dui-xiang" class="header-anchor">#</a></h2><h3><span id="request-he-response-fen-gong">request和response分工</span><a href="#request-he-response-fen-gong" class="header-anchor">#</a></h3><p>1.都是doGet/doPost方法的形参，都是由服务器创建的<br>2.request负责封装请求行信息(请求方式，请求路径，请求参数)<br>3.response负责封装响应信息(响应头，响应体)    </p>
<h3><span id="1-request-dui-xiang">1.request对象</span><a href="#1-request-dui-xiang" class="header-anchor">#</a></h3><ul>
<li>获取请求行<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取请求方式 GET/POST</span></span><br><span class="line">String m = request.getMethod();</span><br><span class="line"><span class="comment">//2.获取虚拟路径，工程访问路径  /req</span></span><br><span class="line">String contextPath = request.getContextPath();</span><br><span class="line"><span class="comment">//3.获取servlet路径  /as</span></span><br><span class="line">String servletPath = request.getServletPath();</span><br><span class="line"><span class="comment">//4.获取get方式的请求参数，</span></span><br><span class="line">String qs = request.getQueryString();</span><br><span class="line"><span class="comment">//5.获取uri  :contextPath+servletPath  /req/as</span></span><br><span class="line">String uri = request.getRequestURI();</span><br><span class="line"><span class="comment">//6.获取url:http://localhost:80/req/as?name=aa</span></span><br><span class="line">StringBuffer url = request.getRequestURL();</span><br><span class="line"><span class="comment">//7.获取传输协议名 http</span></span><br><span class="line">String protocol = request.getProtocol();</span><br><span class="line"><span class="comment">//8.获取客户端的ip: localhost</span></span><br><span class="line">String ip = request.getRemoteAddr();</span><br></pre></td></tr></table></figure></li>
<li>获取请求头<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.根据头名称获取头值</span></span><br><span class="line">String userAgent = request.getHeader(<span class="string">"user-agent"</span>);</span><br><span class="line">System.out.println(userAgent);</span><br><span class="line">String referer = request.getHeader(<span class="string">"referer"</span>);</span><br><span class="line">System.out.println(referer);</span><br><span class="line"><span class="comment">//2.获取所有头名称</span></span><br><span class="line">Enumeration&lt;String&gt; hnames = request.getHeaderNames();</span><br><span class="line"><span class="keyword">while</span> (hnames.hasMoreElements())&#123;</span><br><span class="line">    <span class="comment">//循环变量迭代器，取出每一个头名称</span></span><br><span class="line">    String name = hnames.nextElement();</span><br><span class="line">    <span class="comment">//根据头名称获取头值</span></span><br><span class="line">    String value = request.getHeader(name);</span><br><span class="line">    System.out.println(name+<span class="string">"--"</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>获取请求体数据<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">post方式有请求体，get方式没有请求体</span><br><span class="line"><span class="comment">//1.从request对象中获取字符流--字符流中包含请求体数据</span></span><br><span class="line">BufferedReader br = request.getReader();</span><br><span class="line"><span class="comment">//2.从字符输入流中读取一行数据---请求体数据</span></span><br><span class="line">String data = br.readLine();</span><br><span class="line">System.out.println(data);</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>获取请求参数–重点<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取单个请求参数 --根据参数名 获取参数值 ，如果是表单 ，参数名就是input的name值</span></span><br><span class="line">String user = request.getParameter(<span class="string">"user"</span>);</span><br><span class="line">String psw = request.getParameter(<span class="string">"psw"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取复选框的参数值，一个参数名对应多个参数值，参数值在一个数组中</span></span><br><span class="line">String[] likes = request.getParameterValues(<span class="string">"like"</span>);<span class="comment">//java  games</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获取form中所有的请求参数名</span></span><br><span class="line">Enumeration&lt;String&gt; pnames = request.getParameterNames();<span class="comment">//user psw like</span></span><br><span class="line"><span class="keyword">while</span> (pnames.hasMoreElements())&#123;</span><br><span class="line">    <span class="comment">//获取Enumeration集合中的每一个参数名</span></span><br><span class="line">    String name = pnames.nextElement();</span><br><span class="line">    <span class="comment">//获取单个请求参数--根据参数名 获取参数值</span></span><br><span class="line">    String [] value = request.getParameterValues(name);</span><br><span class="line">    System.out.println(name+<span class="string">"--"</span>+ Arrays.toString(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        获取所有的参数名</span></span><br><span class="line">        Enumeration&lt;String&gt; names=request.getParameterNames();</span><br><span class="line">        <span class="keyword">while</span> (names.hasMoreElements())&#123;</span><br><span class="line">            String s=names.nextElement();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取同参数名的所有参数</span></span><br><span class="line">        String[] n = request.getParameterValues(<span class="string">"name"</span>);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        System.out.println(Arrays.toString(n));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一次性获取所有的参数名和参数值</span></span><br><span class="line">        Map&lt;String ,String[]&gt; map=request.getParameterMap();</span><br><span class="line">        <span class="comment">//Map的第一种遍历方法</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String ,String[]&gt;&gt; entries= map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry &lt; String, String[] &gt; entry:entries)&#123;</span><br><span class="line">            String key=entry.getKey();</span><br><span class="line">            String[] value =entry.getValue();</span><br><span class="line">            System.out.println(key+<span class="string">":"</span>+Arrays.toString(value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种遍历若干的Key</span></span><br><span class="line">        Set&lt;String&gt; keys=map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.println(key+<span class="string">"："</span>+Arrays.toString(map.get(key)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第三种遍历若干的Value</span></span><br><span class="line">        Collection&lt;String[]&gt; values=map.values();</span><br><span class="line">        <span class="keyword">for</span> (String[] value : values) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(value));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>处理post请求参数中文乱码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br></pre></td></tr></table></figure>
<h4><span id="zhuan-fa">转发</span><a href="#zhuan-fa" class="header-anchor">#</a></h4>使用的方法：request.getRequestDispatcher(“/cs”).forward(request,response);  </li>
<li>转发的特点<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.服务器行为，共享request对象。</span><br><span class="line"><span class="number">2</span>.只在同一个项目的资源之间进行转发（如不能转发百度的网站）</span><br><span class="line"><span class="number">3</span>.不论转发多少次，只能算是一次请求</span><br><span class="line"><span class="number">4</span>.转发路径，只写servlet上下文路径，不用加上虚拟路径</span><br></pre></td></tr></table></figure>
示例代码<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@WebServlet(<span class="string">"/bs"</span>)</span><br><span class="line">public class BServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">    String name=request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">    request.setAttribute(<span class="string">"wife"</span>,<span class="string">"小乔"</span>);</span><br><span class="line">    //参数传递给CServlet,转发是cservlet和bservlet共用一个对象</span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/cs"</span>).forward(request,response);</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">1.转发到CServlet的DoGet,传入request对象作为forward的实参，说明两个servlet使用的是同一个request对象</span><br><span class="line">2.转发是服务器行为，是在同一个项目内部进行转发，因此转发路径只写servlet路径，不用写工程访问路径</span><br><span class="line"> */</span><br><span class="line">@WebServlet(<span class="string">"/cs"</span>)</span><br><span class="line">public class CServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        String name=request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        String wife=(String) request.getAttribute(<span class="string">"wife"</span>);</span><br><span class="line">        System.out.println(wife);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="yu-dui-xiang-yu-nei-chuan-di-can-shu">域对象（域内传递参数）</span><a href="#yu-dui-xiang-yu-nei-chuan-di-can-shu" class="header-anchor">#</a></h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.request是javaWeb中最小的域对象</span><br><span class="line"><span class="number">2</span>.request域范围：一次请求的范围，意味着共用一个request对象</span><br><span class="line"><span class="number">3</span>.应用于转发，在转发的过程中传递参数</span><br><span class="line"><span class="number">4</span>.获取最大的域对象ServletContext的方法</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用域方法--设置参数 age=18</span></span><br><span class="line">request.setAttribute(<span class="string">"age"</span>,<span class="number">18</span>);</span><br><span class="line"><span class="comment">//使用域方法--获取参数 age=18</span></span><br><span class="line">Object age = request.getAttribute(<span class="string">"age"</span>);</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20200722225306400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></li>
</ul>
<h3><span id="response-dui-xiang">Response对象</span><a href="#response-dui-xiang" class="header-anchor">#</a></h3><ul>
<li>重定向</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 设置状态码 <span class="number">302</span> ，设置响应头 location=url</span><br><span class="line">   response.setStatus(<span class="number">302</span>);</span><br><span class="line">   response.setHeader(<span class="string">"location"</span>,<span class="string">"新url"</span>);</span><br><span class="line"><span class="number">2</span>.简写：</span><br><span class="line">   response.sendRedirect(<span class="string">"新url"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>重定向和转发对比<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.重定向地址栏会发生改变，转发地址栏不会发生改变</span><br><span class="line"><span class="number">2</span>.重定向是两次请求，因此共用两个request对象，不能共享数据，转发是一次请求，可以共享数据</span><br><span class="line"><span class="number">3</span>.重定向可以访问任意站点的资源，转发是服务器内部行为，跳转仅限于当前站点</span><br></pre></td></tr></table></figure></li>
<li>响应字符流形式的数据<br>response.getWriter().write(“字符串”);<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  //在创建对象之前设置utf-8解决编码问题</span><br><span class="line">response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">   PrintWriter writer = response.getWriter();</span><br><span class="line">    writer.write(<span class="string">"我是字符流，第一次给浏览器发送消息"</span>);//不设置setContentType会出现乱码</span><br></pre></td></tr></table></figure>
<ul>
<li>响应字节流—-响应一个图片<br>获取字节输出流，并向流中写字节数据<br>response.getOutputStream().write(字节或字节数组);<br>方法一使用绝对路径<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> //图片变成字节，先获取图片</span><br><span class="line">        FileInputStream is = new FileInputStream(<span class="string">"E:\\OPT\\Workspace\\day8-response\\web\\img\\a.jpg"</span>);</span><br><span class="line">        System.out.println(is);</span><br><span class="line">        //获取字节输出对象</span><br><span class="line">        ServletOutputStream os = response.getOutputStream();</span><br><span class="line">        int i=0;</span><br><span class="line">        //两个流对接，边读边写</span><br><span class="line">        <span class="keyword">while</span> ((i=is.read())&gt;=-1) &#123;</span><br><span class="line">            os.write(i);</span><br><span class="line">        &#125;</span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
方法二使用相对路径<br>这个方法需要将图片部署到服务器上。</li>
</ul>
<ol>
<li>先将图片放到这给目录下<br><img src="https://img-blog.csdnimg.cn/20200722224743602.png" alt="在这里插入图片描述"></li>
</ol>
</li>
</ul>
<ol start="2">
<li>打开项目结构，添加到img文件夹到库文件<br><img src="https://img-blog.csdnimg.cn/20200722225110995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码如下：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">String realPath = request.getServletContext().getRealPath(<span class="string">"/img/a.jpg"</span>);</span><br><span class="line">       System.out.println(realPath);</span><br><span class="line">       FileInputStream is = new FileInputStream(realPath);</span><br><span class="line">       System.out.println(is);</span><br><span class="line">       ServletOutputStream os = response.getOutputStream();</span><br><span class="line">       int i;</span><br><span class="line">       <span class="keyword">while</span> ((i=is.read())&gt;=-1)&#123;</span><br><span class="line">           os.write(i);</span><br><span class="line">       &#125;</span><br><span class="line">       os.close();</span><br><span class="line">       is.close();</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC最基础使用</title>
    <url>/2020/08/01/JDBC%E6%9C%80%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#jdbc-de-jie-shao">JDBC的介绍</a><ul>
<li><a href="#jian-yi-lian-jie-de-wu-da-bu-zou">建议链接的五大步骤：</a></li>
<li><a href="#jdbc-jia-gou">JDBC 架构</a></li>
</ul>
</li>
<li><a href="#liang-chong-fang-shi-huo-qu-lian-jie-dui-xiang">两种方式获取连接对象</a></li>
<li><a href="#li-yong-jdbc-zhi-xing-zeng-shan-gai-cha-ce-shi">利用jdbc执行增删改查测试</a></li>
<li><a href="#cha-xun-suo-you-shu-ju-feng-zhuang-dao-list-ji-he">查询所有数据，封装到List集合</a></li>
<li><a href="#shi-yong-dbutils-jian-hua-cao-zuo">使用DBUtils简化操作</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h2><span id="jdbc-de-jie-shao">JDBC的介绍</span><a href="#jdbc-de-jie-shao" class="header-anchor">#</a></h2><p>Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。</p>
<h3><span id="jian-yi-lian-jie-de-wu-da-bu-zou">建议链接的五大步骤：</span><a href="#jian-yi-lian-jie-de-wu-da-bu-zou" class="header-anchor">#</a></h3><ol>
<li>加载（注册）数据库</li>
<li>建立链接</li>
<li>执行SQL语句</li>
<li>处理结果集</li>
<li>关闭数据库<h3><span id="jdbc-jia-gou">JDBC 架构</span><a href="#jdbc-jia-gou" class="header-anchor">#</a></h3></li>
<li>传统连接<br><img src="https://img-blog.csdnimg.cn/20200719152323372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt><br>缺点：<br>  用户每次请求都需要向数据库获得链接，而数据库创建连接通常需要消耗相对较大的资源，创建时间也较长。假设网站一天50万访问量，数据库服务器就需要创建50万次连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、拓机。</li>
<li>使用数据库连接池<br>连接池是将已经创建好的连接保存在池中，当有请求来时，直接使用已经创建好的连接对数据库进行访问。这样省略了创建连接和销毁连接的过程。这样性能上得到了提高。<br><img src="https://img-blog.csdnimg.cn/20200719153501304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt><h2><span id="liang-chong-fang-shi-huo-qu-lian-jie-dui-xiang">两种方式获取连接对象</span><a href="#liang-chong-fang-shi-huo-qu-lian-jie-dui-xiang" class="header-anchor">#</a></h2></li>
<li>用原始的jdbc方式去获取连接对象<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test&#x2F;&#x2F;用原始的jdbc方式去获取连接对象</span><br><span class="line">   public void test() throws Exception &#123;</span><br><span class="line">       &#x2F;&#x2F;注册驱动,高版本自动注册，这一步可以省略不写</span><br><span class="line">       &#x2F;&#x2F;低版本mysql是</span><br><span class="line">       &#x2F;&#x2F;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">      &#x2F;&#x2F; mysql8用</span><br><span class="line">       Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">       &#x2F;&#x2F;获取连接对象</span><br><span class="line">       &#x2F;&#x2F;如果在本机上可使用：</span><br><span class="line">       &#x2F;&#x2F; Connection con&#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;yz&quot;,&quot;root&quot;,&quot;password&quot;);</span><br><span class="line">       Connection con&#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;yz&quot;,&quot;root&quot;,&quot;password&quot;);</span><br><span class="line">       System.out.println(con);&#x2F;&#x2F;输出连接对象的哈希地址值</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
使用druid连接池<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test&#x2F;&#x2F;使用druid连接池</span><br><span class="line">   public void test1() throws Exception &#123;</span><br><span class="line">       &#x2F;&#x2F;创建数据源（连接池）对象，并关联jdbc参数</span><br><span class="line">       DruidDataSource ds&#x3D; new DruidDataSource();</span><br><span class="line">       ds.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">       ds.setUrl(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;yz&quot;);</span><br><span class="line">       ds.setUsername(&quot;root&quot;);</span><br><span class="line">       ds.setPassword(&quot;password&quot;);</span><br><span class="line">       DruidPooledConnection con&#x3D;ds.getConnection();</span><br><span class="line">       System.out.println(con);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<h2><span id="li-yong-jdbc-zhi-xing-zeng-shan-gai-cha-ce-shi">利用jdbc执行增删改查测试</span><a href="#li-yong-jdbc-zhi-xing-zeng-shan-gai-cha-ce-shi" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line">public class hello1 &#123;</span><br><span class="line">&#x2F;&#x2F;    @SuppressWarnings(&quot;all&quot;)&#x2F;&#x2F;工程中有重复的代码，会有灰色的波浪线提示，用该注解，消除提示</span><br><span class="line">    private Connection con;</span><br><span class="line">    @Before&#x2F;&#x2F;执行每一个@Test方法前，都会去执行@Before方法</span><br><span class="line">    public void init() throws Exception &#123;</span><br><span class="line">        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        con&#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;yz&quot;,&quot;root&quot;,&quot;password&quot;);</span><br><span class="line">        System.out.println(con);&#x2F;&#x2F;输出连接对象的哈希地址值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test&#x2F;&#x2F;测试在表中添加数据</span><br><span class="line">    public void test1() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;测试jdbc新增</span><br><span class="line">        String sql &#x3D; &quot;insert into dept values (null,?,?)&quot;;</span><br><span class="line">        &#x2F;&#x2F;获取执行sql的预编译对象</span><br><span class="line">        PreparedStatement psmt &#x3D; con.prepareStatement(sql);</span><br><span class="line">        &#x2F;&#x2F;为占位符赋值</span><br><span class="line">        psmt.setString(1, &quot;销售部&quot;);</span><br><span class="line">        psmt.setString(2, &quot;光谷软件园D5栋&quot;);</span><br><span class="line">        &#x2F;&#x2F;执行sql</span><br><span class="line">        int i &#x3D; psmt.executeUpdate();</span><br><span class="line">        System.out.println(i + &quot;行数据受影响&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test&#x2F;&#x2F;测试在表中修改数据</span><br><span class="line">    public void test2() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;测试jdbc修改</span><br><span class="line">        String sql&#x3D;&quot;update dept set dname&#x3D;? where did&#x3D;?&quot;;</span><br><span class="line">        &#x2F;&#x2F;获取执行sql的预编译对象</span><br><span class="line">        PreparedStatement psmt&#x3D;con.prepareStatement(sql);</span><br><span class="line">        &#x2F;&#x2F;为占位符赋值</span><br><span class="line">        psmt.setString(1,&quot;采购部&quot;);</span><br><span class="line">        psmt.setInt(2,1);</span><br><span class="line">        &#x2F;&#x2F;执行sql</span><br><span class="line">        int i&#x3D;psmt.executeUpdate();</span><br><span class="line">        System.out.println(i+&quot;行数据受影响&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test&#x2F;&#x2F;使用jdbc测试删除</span><br><span class="line">    public void test3() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;测试jdbc删除</span><br><span class="line">        String sql&#x3D;&quot;delete from dept where dname&#x3D;?&quot;;</span><br><span class="line">        &#x2F;&#x2F;获取执行sql的预编译对象</span><br><span class="line">        PreparedStatement psmt&#x3D;con.prepareStatement(sql);</span><br><span class="line">        &#x2F;&#x2F;为占位符赋值</span><br><span class="line">        psmt.setString(1,&quot;销售部&quot;);</span><br><span class="line">        &#x2F;&#x2F;执行sql</span><br><span class="line">        int i&#x3D;psmt.executeUpdate();</span><br><span class="line">        System.out.println(i+&quot;行数据受影响&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test&#x2F;&#x2F;使用jdbc测试查询--查询单行数据</span><br><span class="line">    public void test4() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;测试jdbc查询单行数据</span><br><span class="line">        String sql1&#x3D;&quot;select * from dept where did&#x3D;?&quot;;</span><br><span class="line">        &#x2F;&#x2F;获取执行sql的预编译对象</span><br><span class="line">        PreparedStatement psmt1&#x3D;con.prepareStatement(sql1);</span><br><span class="line">        &#x2F;&#x2F;为占位符赋值</span><br><span class="line">        psmt1.setInt(1,5);</span><br><span class="line">        &#x2F;&#x2F;执行sql返回结果集</span><br><span class="line">        ResultSet rs&#x3D;psmt1.executeQuery();</span><br><span class="line">        &#x2F;&#x2F;拆开，遍历结果集：rs只有一行，只需要判断是否有数据即可；rs有多行，使用迭代器遍历</span><br><span class="line">        if (rs.next())&#123;</span><br><span class="line">            int did&#x3D;rs.getInt(1);</span><br><span class="line">            String dname&#x3D;rs.getString(2);</span><br><span class="line">            String location&#x3D;rs.getString(3);</span><br><span class="line">            System.out.println(did);</span><br><span class="line">            System.out.println(dname);</span><br><span class="line">            System.out.println(location);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test&#x2F;&#x2F;使用jdbc测试查询--查询多行数据</span><br><span class="line">    public void test5() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;测试jdbc查询单行数据</span><br><span class="line">       String sql2&#x3D;&quot;select * from dept&quot;;</span><br><span class="line">       &#x2F;&#x2F;获取执行sql的预编译对象</span><br><span class="line">       PreparedStatement psmt2&#x3D;con.prepareStatement(sql2);</span><br><span class="line">       &#x2F;&#x2F;执行sql返回结果集</span><br><span class="line">       ResultSet rs1&#x3D;psmt2.executeQuery();</span><br><span class="line">       &#x2F;&#x2F;拆开，遍历结果集：rs只有一行，只需要判断是否有数据即可；rs有多行，使用迭代器遍历</span><br><span class="line">       while (rs1.next())&#123;</span><br><span class="line">           int did&#x3D;rs1.getInt(&quot;did&quot;);</span><br><span class="line">           String dname&#x3D;rs1.getString(&quot;dname&quot;);</span><br><span class="line">           String location&#x3D;rs1.getString(&quot;location&quot;);</span><br><span class="line">           System.out.println(did+&quot;      &quot;+dname+&quot;       &quot;+location);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="cha-xun-suo-you-shu-ju-feng-zhuang-dao-list-ji-he">查询所有数据，封装到List集合</span><a href="#cha-xun-suo-you-shu-ju-feng-zhuang-dao-list-ji-he" class="header-anchor">#</a></h2>ResultSet集合包含符合SQL语句中条件的所有行，并且它通过一套get方法（这些get方法可以访问当前行中的不同列）提供了对这些行中数据的访问。ResultSet.next方法用于移动到ResultSet中的下一行，使下一行成为当前行。但我们处理数据大部分情况都用的list。接下来我们讲查询的数据处理到List中。</li>
</ol>
<p>查询emps表数据,并封装到List集合中<br>dept.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class dept &#123;</span><br><span class="line">    private String did;</span><br><span class="line">    private String dname;</span><br><span class="line">    private String location;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;dept&#123;&quot; +</span><br><span class="line">                &quot;did&#x3D;&#39;&quot; + did + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, dname&#x3D;&#39;&quot; + dname + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, location&#x3D;&#39;&quot; + location + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public dept(String did, String dname, String location) &#123;</span><br><span class="line">        this.did &#x3D; did;</span><br><span class="line">        this.dname &#x3D; dname;</span><br><span class="line">        this.location &#x3D; location;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public dept() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDid() &#123;</span><br><span class="line">        return did;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDid(String did) &#123;</span><br><span class="line">        this.did &#x3D; did;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDname() &#123;</span><br><span class="line">        return dname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDname(String dname) &#123;</span><br><span class="line">        this.dname &#x3D; dname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLocation() &#123;</span><br><span class="line">        return location;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLocation(String location) &#123;</span><br><span class="line">        this.location &#x3D; location;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hello2.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查询所有数据，封装到List集合</span><br><span class="line">public class hello2 &#123;</span><br><span class="line">    private Connection con;</span><br><span class="line">    @Before&#x2F;&#x2F;执行每一个@Test方法前，都会去执行@Before方法</span><br><span class="line">    public void init() throws Exception &#123;</span><br><span class="line">        Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">        con&#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;yz&quot;,&quot;root&quot;,&quot;password&quot;);</span><br><span class="line">        System.out.println(con);&#x2F;&#x2F;输出连接对象的哈希地址值</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void test() throws Exception&#123;</span><br><span class="line">        String sql &#x3D; &quot;select * from dept&quot;;</span><br><span class="line">        &#x2F;&#x2F;获取执行sql的预编译对象</span><br><span class="line">        PreparedStatement psmt &#x3D; con.prepareStatement(sql);</span><br><span class="line">        &#x2F;&#x2F;执行sql返回结果集</span><br><span class="line">        ResultSet rs &#x3D; psmt.executeQuery();</span><br><span class="line">        &#x2F;&#x2F;3.遍历结果集rs</span><br><span class="line">        ArrayList&lt;dept&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        while (rs.next()) &#123;&#x2F;&#x2F;rs.next()准备取出某一行数据</span><br><span class="line">            String did &#x3D; rs.getString(&quot;did&quot;);</span><br><span class="line">            String dname &#x3D; rs.getString(&quot;dname&quot;);</span><br><span class="line">            String location &#x3D; rs.getString(&quot;location&quot;);</span><br><span class="line">            &#x2F;&#x2F;将emps表中的每一行数据封装成一个emps对象</span><br><span class="line">            dept dept &#x3D; new dept(did, dname, location);</span><br><span class="line">            &#x2F;&#x2F;emps对象存进list集合中</span><br><span class="line">            list.add(dept);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;封装后的集合数据：&quot;+list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<br>可能会报错如下：<br><img src="https://img-blog.csdnimg.cn/20200719161340944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt><br>解决方法：</p>
<ol>
<li>MySQLl的jdbc驱动最新版（6.0+）时，遇到数据库和系统时区差异引起的问题。换用低版本的jar包。</li>
<li>在URL后面加上时区参数，只要出现URL就需要添加后面的<blockquote>
<p>?serverTimezone=UTC<br>或<br>?serverTimezone=GMT%2B8</p>
</blockquote>
</li>
<li>找到mysql的安装目录下MySQL Server 8.0目录下的my.ini文件，在mysqld下加入如下代码：<blockquote>
<p>default-time-zone = ‘+8:00’</p>
</blockquote>
</li>
</ol>
<p>特别提醒：<br>网上的另一种解决方法有个小问题，就是重启mysql后会还原为默认设置，需要重新设置，<strong>最好不要用下面这种方法。</strong><br><img src="https://img-blog.csdnimg.cn/20200719213755960.png" alt></p>
<h2><span id="shi-yong-dbutils-jian-hua-cao-zuo">使用DBUtils简化操作</span><a href="#shi-yong-dbutils-jian-hua-cao-zuo" class="header-anchor">#</a></h2><p>DBUtils是一个对JDBC进行简单封装的开源工具类库   </p>
<p>用传统JDBC实现DBUtils如下：<br> Jdbcutil.java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.sql.*;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Jdbcutil &#123;</span><br><span class="line">    &#x2F;&#x2F;将查询结果集rs中的数据封装到list集合中</span><br><span class="line">    public static &lt;T&gt; List&lt;T&gt; queryList(String sql, Class&lt;T&gt; c) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">            &#x2F;&#x2F;2.获取连接对象</span><br><span class="line">            Connection con &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;yz&quot;, &quot;root&quot;, &quot;password&quot;);</span><br><span class="line">            &#x2F;&#x2F;1.定义sql</span><br><span class="line">            &#x2F;&#x2F;2.创建执行sql的对象</span><br><span class="line">            PreparedStatement pstm &#x3D; con.prepareStatement(sql);</span><br><span class="line">            &#x2F;&#x2F;3.执行sql</span><br><span class="line">            ResultSet rs &#x3D; pstm.executeQuery();</span><br><span class="line">            &#x2F;&#x2F;4.遍历rs,创建一个list集合</span><br><span class="line">            ArrayList&lt;T&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            &#x2F;&#x2F;5.元数据</span><br><span class="line">            ResultSetMetaData md &#x3D; rs.getMetaData();</span><br><span class="line">            &#x2F;&#x2F;总列数</span><br><span class="line">            int count &#x3D; md.getColumnCount();</span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line">                &#x2F;&#x2F;T通用类型，不确实是哪一个实体类，dept,emps</span><br><span class="line">                T t &#x3D; c.newInstance();</span><br><span class="line">                for (int i &#x3D; 1; i &lt;&#x3D; count; i++) &#123;</span><br><span class="line">                    &#x2F;&#x2F;每一个单元格的数据</span><br><span class="line">                    Object value &#x3D; rs.getObject(i);</span><br><span class="line">                    &#x2F;&#x2F;反射中对 属性的操作，将上面单元格的数据value,存到对象t中</span><br><span class="line">                    &#x2F;&#x2F;使用元数据获取列名,列名和实体类的属性名相同的</span><br><span class="line">                    String columnName &#x3D; md.getColumnName(i);</span><br><span class="line">                    &#x2F;&#x2F;获取实体类的每一个属性的管理对象</span><br><span class="line">                    Field f &#x3D; c.getDeclaredField(columnName);</span><br><span class="line">                    &#x2F;&#x2F;由于成员属性进行了封装，是private，暴力反射，开启私有属性操作权限</span><br><span class="line">                    f.setAccessible(true);</span><br><span class="line">                    f.set(t, value);&#x2F;&#x2F;将value赋值给t对象的columnName属性</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;封装后的集合数据：&quot; + list);</span><br><span class="line">            return list;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test//测试部门表</span><br><span class="line">public void test1() throws SQLException &#123;</span><br><span class="line">    List&lt;dept&gt; dp= Jdbcutil.queryList(<span class="string">"select * from dept"</span>,dept.class);</span><br><span class="line">    System.out.println(dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用DBUtils简化操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test&#x2F;&#x2F;测试dbutils</span><br><span class="line">   public void test() throws SQLException &#123;</span><br><span class="line">       DruidDataSource ds&#x3D; new DruidDataSource();</span><br><span class="line">       ds.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">       ds.setUrl(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;yz&quot;);</span><br><span class="line">       ds.setUsername(&quot;root&quot;);</span><br><span class="line">       ds.setPassword(&quot;password&quot;);</span><br><span class="line">       &#x2F;&#x2F;1.创建qr对象，传入数据源参数</span><br><span class="line">       QueryRunner qs&#x3D;new QueryRunner(ds);</span><br><span class="line">       &#x2F;&#x2F;2.调用查询方法</span><br><span class="line">       List &lt;dept&gt; dp&#x3D;qs.query(&quot;select * from dept&quot;,new BeanListHandler&lt;dept&gt;(dept.class));</span><br><span class="line"></span><br><span class="line">       System.out.println(dp);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis中用@Select传参数</title>
    <url>/2020/08/01/Mybatis%E4%B8%AD%E7%94%A8-Select%E4%BC%A0%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->



<!-- tocstop -->

</div>

<a id="more"></a>

<p>一般情况</p>
<p>@select(“select * from user where name = #{name}”)</p>
<p>List<user>  selectUserByName (String name)</user></p>
<p>高级用法</p>
<p>@Select(“select * from userf where name like CONCAT(‘%’,#{s},’%’)”)</p>
<p>List<fkb> selectLikename(String s);</fkb></p>
<p>concat拼接字符串</p>
<p>CONCAT(‘%’,#{0},’%’)”)  不能直接用 ‘%#{s}%’</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>zip、unzip应用和dpkg用法</title>
    <url>/2020/04/22/dpkg/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-an-zhuang-zip-unzip-ying-yong">1、安装zip、unzip应用。</a><ul>
<li><a href="#centos">centos</a></li>
<li><a href="#ubuntu">ubuntu</a></li>
</ul>
</li>
<li><a href="#2-ya-suo-he-jie-ya-wen-jian">2、压缩和解压文件</a></li>
<li><a href="#3-yong-dpkg-ming-ling-xing-yun-xing-deb-an-zhuang-bao-de-fang-fa">3、用dpkg命令行运行deb安装包的方法</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>
## 1、安装zip、unzip应用。
### centos
yum install zip unzip
### ubuntu
apt install zip unzip
## 2、压缩和解压文件
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以下命令均在&#x2F;home目录下操作  </span><br><span class="line">cd &#x2F;home #进入&#x2F;home目录  </span><br><span class="line">　　　　</span><br><span class="line">　　a、把&#x2F;home目录下面的mydata目录压缩为mydata.zip    </span><br><span class="line">　　		zip -r mydata.zip mydata #压缩mydata目录    </span><br><span class="line">　　　　</span><br><span class="line">　　b、把&#x2F;home目录下面的mydata.zip解压到mydatabak目录里面  </span><br><span class="line">　　</span><br><span class="line">　　　　unzip mydata.zip -d mydatabak  </span><br><span class="line">　　　　</span><br><span class="line">　　c、把&#x2F;home目录下面的abc文件夹和123.txt压缩成为abc123.zip  </span><br><span class="line">　　</span><br><span class="line">　　　　zip -r abc123.zip abc 123.txt  </span><br><span class="line">　　　　</span><br><span class="line">　　d、把&#x2F;home目录下面的wwwroot.zip直接解压到&#x2F;home目录里面  </span><br><span class="line">　　</span><br><span class="line">　　　　unzip wwwroot.zip  </span><br><span class="line">　　e、把&#x2F;home目录下面的abc12.zip、abc23.zip、abc34.zip同时解压到&#x2F;home目录里面  </span><br><span class="line">　　　　unzip abc\*.zip  </span><br><span class="line">　　f、查看把&#x2F;home目录下面的wwwroot.zip里面的内容  </span><br><span class="line">　　　　unzip -v wwwroot.zip  </span><br><span class="line">　　g、验证&#x2F;home目录下面的wwwroot.zip是否完整  </span><br><span class="line">　　　　unzip -t wwwroot.zip  </span><br><span class="line">　　h、把&#x2F;home目录下面wwwroot.zip里面的所有文件解压到第一级目录  </span><br><span class="line">　　　　unzip -j wwwroot.zip</span><br></pre></td></tr></table></figure>
## 3、用dpkg命令行运行deb安装包的方法

<p>sudo dpkg -I iptux.deb 查看iptux.deb软件包的详细信息，包括软件名称、版本以及大小等（其中-I等价于–info）</p>
<p>sudo dpkg -c iptux.deb 查看iptux.deb软件包中包含的文件结构（其中-c等价于–contents）</p>
<p>sudo dpkg -i iptux.deb 安装iptux.deb软件包（其中-i等价于–install）</p>
<p>sudo dpkg -l iptux 查看iptux软件包的信息（软件名称可通过dpkg -I命令查看，其中-l等价于–list）</p>
<p>sudo dpkg -L iptux 查看iptux软件包安装的所有文件（软件名称可通过dpkg -I命令查看，其中-L等价于–listfiles）</p>
<p>sudo dpkg -s iptux 查看iptux软件包的详细信息（软件名称可通过dpkg -I命令查看，其中-s等价于–status）</p>
<p>sudo dpkg -r iptux 卸载iptux软件包（软件名称可通过dpkg -I命令查看，其中-r等价于–remove）</p>
<p>注： dpkg命令无法自动解决依赖关系。如果安装的deb包存在依赖包，则应避免使用此命令，或者按照依赖关系顺序安装依赖包。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux删除无用缓存及垃圾文件</title>
    <url>/2020/04/22/clean-tmp/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#yi-shan-chu-huan-cun">一、删除缓存</a></li>
<li><a href="#2-qing-li-opera-firefox-de-huan-cun-wen-jian">2、清理opera firefox的缓存文件：</a></li>
<li><a href="#3-qing-li-linux-xia-gu-li-de-bao">3、清理Linux下孤立的包：</a></li>
<li><a href="#4-xie-zai-tracker">4、卸载：tracker</a></li>
<li><a href="#er-shan-chu-ruan-jian">二、删除软件</a></li>
<li><a href="#san-shan-chu-duo-yu-nei-he">三、删除多余内核</a><ul>
<li><a href="#dui-yu-centos-shan-chu-nei-he">对于centos删除内核</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<h2><span id="yi-shan-chu-huan-cun">一、删除缓存</span><a href="#yi-shan-chu-huan-cun" class="header-anchor">#</a></h2><p>sudo apt-get autoclean                清理旧版本的软件缓存</p>
<p>sudo apt-get clean                    清理所有软件缓存</p>
<p>sudo apt-get autoremove             删除系统不再使用的孤立软件</p>
<p>这三个命令主要清理升级缓存以及无用包的。</p>
<h2><span id="2-qing-li-opera-firefox-de-huan-cun-wen-jian">2、清理opera firefox的缓存文件：</span><a href="#2-qing-li-opera-firefox-de-huan-cun-wen-jian" class="header-anchor">#</a></h2><p>ls ~/.opera/cache4</p>
<p>ls ~/.mozilla/firefox/*.default/Cache</p>
<h2><span id="3-qing-li-linux-xia-gu-li-de-bao">3、清理Linux下孤立的包：</span><a href="#3-qing-li-linux-xia-gu-li-de-bao" class="header-anchor">#</a></h2><p>终端命令下我们可以用：</p>
<p>sudo apt-get install deborphan -y</p>
<h2><span id="4-xie-zai-tracker">4、卸载：tracker</span><a href="#4-xie-zai-tracker" class="header-anchor">#</a></h2><p>一般我只要安装ubuntu就会第一删掉tracker他不仅会产生大量的cache文件而且还会影响开机速度。</p>
<p>附录：<br>包管理的临时文件目录:<br>包在<br>/var/cache/apt/archives<br>没有下载完的在<br>/var/cache/apt/archives/partial  </p>
<h2><span id="er-shan-chu-ruan-jian">二、删除软件</span><a href="#er-shan-chu-ruan-jian" class="header-anchor">#</a></h2><p>sudo apt-get remove –purge 软件名<br>purge：删除软件缓存和配置  </p>
<p>sudo apt-get autoremove<br>autoremove：会删除软件的依赖文件，一般不推荐。</p>
<p>删除系统不再使用的孤立软件</p>
<p>sudo apt-get autoclean</p>
<h2><span id="san-shan-chu-duo-yu-nei-he">三、删除多余内核</span><a href="#san-shan-chu-duo-yu-nei-he" class="header-anchor">#</a></h2><p>1，首先要使用这个命令查看当前Ubuntu系统使用的内核</p>
<p>uname -a</p>
<p>2.列出当前系统中安装内核的 image 和 extra 文件。</p>
<p> dpkg –list | grep linux-image</p>
<p>3.同时删除 linux-headers-4.2.0-12 的 image 和 extra 文件。<br>  sudo apt-get purge linux-image-4.2.0-12 </p>
<p>4.上一步中的命令，将同时触发系统对其他内核文件必要性的检查。上一步骤中，提示 linux-headers-4.2.0-30 等内核文件现在不需要了，可以使用“apt-get autoremove”来卸载它(它们)。  </p>
<pre><code>apt-get autoremove  </code></pre><p>执行上述自动卸载操作。</p>
<p>列出当前系统中安装的内核 headers 文件。</p>
<p> dpkg –list | grep linux-headers</p>
<p>image 、extra、 headers文件都是内核的组成文件。</p>
<p>继续删除 4.2.0-12 内核文件中的 headers 文件。</p>
<p>在终端中输入：</p>
<pre><code>sudo apt-get purge linux-headers-4.2.0-12</code></pre><p>系统将删除 4.2.0-12 内核文件中的 headers 文件。</p>
<p>总之中间有“xxxxxx”那段的旧内核都能删，注意一般选内核号较小的删。</p>
<h3><span id="dui-yu-centos-shan-chu-nei-he">对于centos删除内核</span><a href="#dui-yu-centos-shan-chu-nei-he" class="header-anchor">#</a></h3><p>使用uname -r查看内核版本<br>[root@xuexi ~]# uname -r<br>3.10.0-1062.18.1.el7.x86_64</p>
<p>接着使用rpm -q kernel查看系统内所有的内核<br>[root@xuexi ~]# rpm -q kernel<br>kernel-3.10.0-957.1.3.el7.x86_64<br>kernel-3.10.0-957.5.1.el7.x86_64<br>kernel-3.10.0-957.10.1.el7.x86_64<br>kernel-3.10.0-957.12.1.el7.x86_64<br>相互对照，将老旧内核使用yum remove命令删除<br>[root@xuexi ~]# yum remove kernel-3.10.0-957.1.3.el7.x86_64 kernel-3.10.0-957.5.1.el7.x86_64 kernel-3.10.0-957.10.1.el7.x86_64</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>gitnote</title>
    <url>/2020/04/08/gitnote/</url>
    <content><![CDATA[<h2><span id="git-bi-ji"><strong>git笔记</strong></span><a href="#git-bi-ji" class="header-anchor">#</a></h2><p><strong>1.新建版本库</strong><br>cd 盘名:\文件夹名  //进入D盘文件夹<br>mkdir 文件夹名称  //创建一个文件夹<br>git config –global user.name “username” //创建用户名和密码<br>git config –global user.email “email”<br>git config –list //查看git配置  </p>
<a id="more"></a>

<p>cat 文件 //打开文件<br>git init //创建库<br>touch readme.txt //新建readme记事本<br>cd 文件名 //进入文件夹<br>cd .. 回退到上一个目录<br>git add 文件名 //把文件加入git仓库<br>git add .添加同目录所有文件夹<br>git add -f file //强行添加<br>git commit -m”说明” //把文件提交到仓库<br>git status //查看仓库修改状态<br>git diff //查看做了什么修改<br>git config –global alias.别名 原名 //配置别名<br><strong>版本回退与修改</strong><br>git log //查看修改日志按q退出<br>git log –pretty=oneline 简化输出<br>git reset –hard HEAD^ //回退到前^个版本<br>当窗口没有关闭是可以重新回来，git reset –hard commitID<br>git reflog //用来记录你的每一次命令<br><img src="image/gitnote1.jpg" alt><br>git diff HEAD – 文件名 //查看工作区和版本库里面最新版本的区别<br>场景一：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，git checkout – file<br>场景二：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。<br>git rm file 或rm film//删除文件，并且git commit<br><strong>连接远程库</strong><br>ssh-keygen -t rsa -b 4096 -C “<a href="mailto:your_email@example.com">your_email@example.com</a>“//生成ssh<br>ssh -T <a href="mailto:git@github.com">git@github.com</a> # 注意邮箱地址不用改<br>git remote add origin +git地址 //添加远程库，远程库的名字就是origin<br>git remote show origin //显示所有分支<br>git remote rm origin //删除远程连接<br>git pull –rebase origin name //在第一次上传项目之前最好更新项目，确保没有与远程仓库代码冲突<br>ls -al ~/.ssh //检查本地计算机SSH key<br><strong>管理分支</strong><br>git checkout -b dev //表示创建并切换，相当于以下两条命令：<br>$ git branch dev<br>$ git checkout dev<br>git branch命令会列出所有分支，当前分支前面会标一个<em>号。<br>git checkout 分支 //切换分支<br>git merge dev //合并dev分支到当前分支。<br>git branch -d dev //删除dev分支<br>git branch -D dev //强制删除<br>git log –graph –pretty=oneline –abbrev-commit //查看分支合并图<br>git merge –no-ff -m “merge with no-ff” dev //–no-ff参数，表示禁用Fast forward，加-m会把commit写进去<br>git stash //把当前工作现场“储藏”起来，等以后恢复现场后继续工作<br>git stash list //查看工作现场存在哪<br>恢复：<br>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；<br>另一种方式是用git stash pop，恢复的同时把stash内容也删了：<br>git remote -v//查看远程库信息<br>*</em>多人协作**<br>git push origin branchname//推送自己的修改<br>git push -u origin branchname //初次添加到远程分支<br>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull抓下来<br>如果合并有冲突，则解决冲突，并在本地提交；<br>没有冲突或者解决掉冲突后，再用git push origin branchname推送就能成功！<br>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。<br>git rebase操作可以把本地未push的分叉提交历史整理成直线；<br>git pull origin branch-name//拉取远程仓库<br>git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。</branch-name></branch-name></p>
<p>而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。</p>
<p>git clone 地址//这是一种较为简单的初始化方式，当你已经有一个远程的Git版本库，只需要在本地克隆一份<br><strong>打标签</strong><br>git tag tagname//在当前分支打一个新标签，默认标签是打在最新提交的commit上的<br>git tag//查看所有标签<br>git tag tagname commitID//打历史标签<br>git show tagname//查看标签信息<br>git tag -a v0.1 -m “version 0.1 released”//创建带有说明的标签，用-a指定标签名，-m指定说明文字<br>git tag -d tagname //删除本地标签<br>git push origin –delete tagname //删除远程标签<br>git push origin tagname或git push origin :refs/tags/tagname //推送远程标签<br>git push origin –tags //一次性推送远程标签  </p>
<h2><span id="la-ji-hui-shou">垃圾回收</span><a href="#la-ji-hui-shou" class="header-anchor">#</a></h2><blockquote>
<p>git gc</p>
</blockquote>
<p>gc意味着垃圾回收(garbage collect)，<br>使用git gc指令，可以将松散的文件压缩。具体流程如文档所说：“Git 会不定时地自动运行称为 “auto gc” 的命令。大部分情况下该命令什么都不处理。不过要是存在太多松散对象 (loose object, 不在 packfile 中的对象) 或 packfile，Git 会进行调用 git gc 命令。gc 指垃圾收集 (garbage collect)，此命令会做很多工作：收集所有松散对象并将它们存入 packfile，合并这些 packfile 进一个大的 packfile，然后将不被任何 commit 引用并且已存在一段时间 (数月) 的对象删除。”</p>
<blockquote>
<p>git gc –aggressive</p>
</blockquote>
<p>对本地git库进行更彻底清理和优化，这个指令花费的时间也会更长。 </p>
<p>清空git缓存 git rm -r –cached . </p>
<h2><span id="sheng-ji">升级</span><a href="#sheng-ji" class="header-anchor">#</a></h2><blockquote>
<p>git update-git-for-windows</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql基本操作最简单入门</title>
    <url>/2020/08/01/Mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E6%9C%80%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#jian-jie">简介</a></li>
<li><a href="#shi-yong">使用</a></li>
<li><a href="#sql-fen-lei">SQL分类</a><ul>
<li><a href="#1-shu-ju-ding-yi-yu-yan-ddl"><strong>1.数据定义语言（DDL）</strong></a><ul>
<li><a href="#shu-ju-ku-cao-zuo">数据库操作</a></li>
<li><a href="#biao-cao-zuo-crud">表操作(CRUD)</a></li>
</ul>
</li>
<li><a href="#2-shu-ju-cao-zong-yu-yan-dml-data-manipulation-language"><strong>2. 数据操纵语言（DML：Data Manipulation Language）</strong></a></li>
<li><a href="#3-shu-ju-cha-xun-yu-yan-dql-data-query-language"><strong>3. 数据查询语言（DQL: Data Query Language）</strong></a></li>
<li><a href="#4-shu-ju-kong-zhi-yu-yan-dcl"><strong>4.数据控制语言（DCL）</strong></a></li>
<li><a href="#5-shi-wu-chu-li-yu-yan-dpl"><strong>5.事务处理语言（DPL）</strong></a></li>
<li><a href="#6-zhi-zhen-kong-zhi-yu-yan-ccl"><strong>6.指针控制语言（CCL）</strong></a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h2><span id="jian-jie">简介</span><a href="#jian-jie" class="header-anchor">#</a></h2><p>MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。<br>MySQL 使用标准的 SQL 数据语言形式。<br>MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。<br>在语言中不区分大小写。</p>
<h2><span id="shi-yong">使用</span><a href="#shi-yong" class="header-anchor">#</a></h2><ol>
<li>在cmd中，打开MySQL数据库服务,</li>
</ol>
<blockquote>
<p>net start mysql<br>2. 登录mysql,输入密码<br>mysql -uroot -p<br>3. 查看数据库<br>show databases;<br>4. 使用某一数据库<br>use 数据库名;<br>5. 查看数据库中的表<br>show tables;<br>6. 查询当前正在使用的数据库<br>select database();<br>7. 查询表结构<br>desc 表名;<br>8. 查看数据文件存放路径<br>show variables like ‘%datadir%’;<br>9. 查询数据库相关信息<br>status;<br>10 查看当前登录的用户.<br>SELECT CURRENT_USER;<br>11 查看数据库所有用户<br>select user,host from mysql.user;</p>
</blockquote>
<h2><span id="sql-fen-lei">SQL分类</span><a href="#sql-fen-lei" class="header-anchor">#</a></h2><h3><span id="1-shu-ju-ding-yi-yu-yan-ddl"><strong>1.数据定义语言（DDL）</strong></span><a href="#1-shu-ju-ding-yi-yu-yan-ddl" class="header-anchor">#</a></h3><p>常用的有CREATE、ALTER和DROP，用于在数据库中创建新表或删除表，以及为表加入索引等。</p>
<h4><span id="shu-ju-ku-cao-zuo">数据库操作</span><a href="#shu-ju-ku-cao-zuo" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建数据库：   </span><br><span class="line">​		create database 数据库名称;</span><br><span class="line">创建数据库db,判断是否存在，制定字符集为utf8</span><br><span class="line">	 create database if not exists db character set utf8;</span><br><span class="line">修改数据库的字符集</span><br><span class="line">	alter database 数据库名称 character set 字符集名称;</span><br><span class="line">删除数据库</span><br><span class="line">	drop database &#96;db&#96;;</span><br><span class="line">如果db存在就删除</span><br><span class="line">	DROP database IF EXISTS &#96;db&#96;;</span><br></pre></td></tr></table></figure>
<h4><span id="biao-cao-zuo-crud">表操作(CRUD)</span><a href="#biao-cao-zuo-crud" class="header-anchor">#</a></h4><h5><span id="yue-shu-chong-lei">约束种类</span><a href="#yue-shu-chong-lei" class="header-anchor">#</a></h5><p>非空约束(not null)<br>用not null约束的字段不能为null值，必须给定具体的数据</p>
<ol>
<li><p>创建表时添加约束</p>
<pre><code>CREATE TABLE stu(
    id INT,
    NAME VARCHAR(20) NOT NULL -- name为非空
);</code></pre></li>
<li><p>创建表完后，添加非空约束</p>
<pre><code>ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;</code></pre></li>
<li><p>删除name的非空约束</p>
<pre><code>ALTER TABLE stu MODIFY NAME VARCHAR(20);</code></pre></li>
</ol>
<p>唯一性约束(unique)<br>unique约束的字段，具有唯一性，不可重复，但可以为null</p>
<ol>
<li>创建表时，添加唯一约束<pre><code>CREATE TABLE stu(
    id INT,
    phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束    
);</code></pre></li>
<li>删除唯一约束(drop index)<pre><code>ALTER TABLE stu DROP INDEX phone_number;
DROP INDEX index_name ON tbl_name</code></pre></li>
<li>在创建表后，添加唯一约束<pre><code>ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;
alter table tableName add unique(column_name)</code></pre></li>
</ol>
<p>主键约束(primary key) PK<br>表中的某个字段添加主键约束后，该字段为主键字段，主键字段中出现的每一个数据都称为主键值<br>主键约束除了可以做到”not null unique”之外，还会默认添加”索引——index”<br>主键值：是当前行数据的唯一标识，即使表中两行记录相关数据相同，但由于主键值不同，所以也认为是两行不同的记录。   </p>
<pre><code>    在创建表时，添加主键约束
    create table stu(
        id int primary key,-- 给id添加主键约束
        name varchar(20)
    );

  删除主键
    -- 错误 alter table stu modify id int ;
    ALTER TABLE stu DROP PRIMARY KEY;

创建完表后，添加主键
    ALTER TABLE stu MODIFY id INT PRIMARY KEY;
    ALTER TABLE &lt;数据表名&gt; ADD PRIMARY KEY(&lt;列名&gt;);
自动增长：
    1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长
    2. 在创建表时，添加主键约束，并且完成主键自增长
    create table stu(
        id int primary key auto_increment,-- 给id添加主键约束
        name varchar(20)
    );
    3. 删除自动增长
    ALTER TABLE stu MODIFY id INT;
    4. 添加自动增长
    ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;</code></pre><p>外键约束(foreign key) FK<br>若有两个表A、B，id是A的主键，而B中也有id字段，则id就是表B的外键，外键约束主要用来维护两个表之间数据的一致性。</p>
<p>外键值可以为null，外键字段去引用一张表的某个字段的时候，被引用的字段必须具有unique约束    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 在创建表时，可以添加外键</span><br><span class="line">			create table 表名(</span><br><span class="line">				....</span><br><span class="line">					foreign key(classno) references t_class(cno)</span><br><span class="line">				);</span><br><span class="line">2. 删除外键</span><br><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</span><br><span class="line"></span><br><span class="line">3. 创建表之后，添加外键</span><br><span class="line">ALTER TABLE 从表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES</span><br></pre></td></tr></table></figure>
<p>创建一张表名为dept，主键为did自增，其他键为dname、locaction，制定字符集为utf8，引擎为InnoDB，从6开始自增。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;dept&#96; (</span><br><span class="line">  &#96;did&#96; int(11) NOT NULL AUTO_INCREMENT unique,</span><br><span class="line">  &#96;dname&#96; varchar(20) DEFAULT NULL,</span><br><span class="line">  &#96;location&#96; varchar(50) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;did&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;6 DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">重命名一张表</span><br><span class="line">RENAME TABLE 原名 TO 新名;</span><br><span class="line">ALTRE TABLE 原名 RENAME 新名;</span><br><span class="line">ALTRE TABLE 原名 RENAME TO 新名；</span><br><span class="line"></span><br><span class="line">删除一张表</span><br><span class="line">drop table 表名;</span><br><span class="line"></span><br><span class="line">删除一列</span><br><span class="line">ALTER TABLE 表名 DROP COLUMN 列名字;</span><br><span class="line">ALTER TABLE 表名 DROP 列名字;</span><br><span class="line"></span><br><span class="line">修改表的字符集</span><br><span class="line">alter table 表名 character set 字符集名称;</span><br><span class="line"></span><br><span class="line"> 添加一列</span><br><span class="line">alter table 表名 add 列名 数据类型;</span><br><span class="line"></span><br><span class="line">修改列名</span><br><span class="line">alter table 表名 change 列名 新列别 新数据类型;</span><br><span class="line"></span><br><span class="line">修改列类型</span><br><span class="line">alter table 表名 modify 列名 新数据类型;</span><br><span class="line"></span><br><span class="line">修改字段排列位置：</span><br><span class="line">alter table 表名modify 字段名1 数据类型 first   |    after  字段名2；</span><br><span class="line">ALTER TABLE grade MODIFY newname VARCHAR(20) FIRST;（将字段newname插入到表的第一个位置）</span><br></pre></td></tr></table></figure>
<h3><span id="2-shu-ju-cao-zong-yu-yan-dml-data-manipulation-language"><strong>2. 数据操纵语言（DML：Data Manipulation Language）</strong></span><a href="#2-shu-ju-cao-zong-yu-yan-dml-data-manipulation-language" class="header-anchor">#</a></h3><p>主要用来对数据库的数据进行一些操作，常用的就是INSERT、UPDATE、DELETE。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    INSERT INTO &lt;表名&gt;(列1,列2,...) VALUES (值1,值2,...);</span><br><span class="line">	</span><br><span class="line">    UPDATE &lt;表名&gt; SET &lt;列名&gt;&#x3D;新值, 列名2 &#x3D; 值2 WHERE &lt;列名&gt;&#x3D;某值;</span><br><span class="line"></span><br><span class="line">    DELETE FROM &lt;表名&gt; WHERE &lt;列名&gt;&#x3D;某值;</span><br><span class="line">    删除整表数据</span><br><span class="line">TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</span><br><span class="line">DELETE FROM emps WHERE 1&#x3D;1;</span><br><span class="line">DELETE FROM emps WHERE TRUE;</span><br><span class="line">DELETE FROM emps WHERE &#39;a&#39;&#x3D;&#39;a&#39;;</span><br></pre></td></tr></table></figure>

<h3><span id="3-shu-ju-cha-xun-yu-yan-dql-data-query-language"><strong>3. 数据查询语言（DQL: Data Query Language）</strong></span><a href="#3-shu-ju-cha-xun-yu-yan-dql-data-query-language" class="header-anchor">#</a></h3><p>数据查询语句，用于从表中获取数据。通常最常用的为保留字SELECT,并且常与FROM子句、WHERE子句组成查询SQL查询语句。<br>语法：<br> select [distinct] 字段1 [as 别名], …, 字段n [as 别名] from [库名.]表名<br>                    [<br>                    where 约束条件<br>                    group by 分组依据<br>                    having 过滤条件<br>                    order by 排序的字段<br>                    limit 限制显示的条数<br>                    ];   </p>
<p>去除重复：distinct<br>as也可以省略<br>IFNULL() 函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回第二个参数的值，如果不为 NULL 则返回第一个参数的值。<br>IFNULL(expression, alt_value)    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 条件查询</span><br><span class="line"> 1. where子句后跟条件</span><br><span class="line">2. 运算符</span><br><span class="line">		 &gt; 、&lt; 、&lt;&#x3D; 、&gt;&#x3D; 、&#x3D; 、&lt;&gt;</span><br><span class="line">		 BETWEEN...AND  </span><br><span class="line">		 IN( 集合) </span><br><span class="line">		 IS NULL  IS NOT NULL isnull()</span><br><span class="line">		and  或 &amp;&amp;</span><br><span class="line">	    or  或 || </span><br><span class="line">		not  &lt;&gt;或 !</span><br><span class="line">		</span><br><span class="line">模糊查询</span><br><span class="line">LIKE：</span><br><span class="line">		占位符：</span><br><span class="line">		_:单个任意字符</span><br><span class="line">		%：多个任意字符</span><br><span class="line">		[ ] ：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。</span><br><span class="line">		[^ ] ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。</span><br><span class="line">		</span><br><span class="line">排序查询</span><br><span class="line">	order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...</span><br><span class="line">	对筛选结果进行升序或者降序排列(默认是升序)</span><br><span class="line">　　升序:  asc ;         降序:  desc</span><br><span class="line">　　</span><br><span class="line">分页查询</span><br><span class="line">	语句1：select * from student limit 9,4</span><br><span class="line">	语句2：slect * from student limit 4 offset 9</span><br><span class="line">	&#x2F;&#x2F; 语句1和2均返回表student的第10、11、12、13行  </span><br><span class="line">	&#x2F;&#x2F;语句2中的4表示返回4行，9表示从表的第十行开始</span><br><span class="line">	公式：开始的索引 &#x3D; （当前的页码 - 1） * 每页显示的条数</span><br><span class="line">聚合函数：将一列数据作为一个整体，进行纵向的计算。</span><br><span class="line">	1. count：计算个数</span><br><span class="line">		1. 一般选择非空的列：主键</span><br><span class="line">		2. count(*)</span><br><span class="line">	2. max：计算最大值</span><br><span class="line">	3. min：计算最小值</span><br><span class="line">	4. sum：计算和</span><br><span class="line">	5. avg：计算平均值</span><br><span class="line">	6. group_concat()：组内字段拼接，用来查看组内其他字段</span><br><span class="line">	* 注意：聚合函数的计算，排除null值。</span><br><span class="line">		解决方案：</span><br><span class="line">			1. 选择不包含非空的列进行计算</span><br><span class="line">			2. IFNULL函数</span><br><span class="line">分组查询（group by）</span><br><span class="line">SELECT column_name, function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name;</span><br><span class="line">　　以记录的字段共性对记录进行分组 </span><br><span class="line">　　分组后字段可进行聚合函数处理</span><br><span class="line">　　</span><br><span class="line">having　　筛选</span><br><span class="line">　　对where和group by处理的结果进一步筛选 , 得到我们想要的数据</span><br><span class="line">		where 和 having 的区别？</span><br><span class="line">			1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来。如果用了group by 那么后面的过滤条件就不能再用where了，要用having。</span><br><span class="line">			2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。</span><br><span class="line"></span><br><span class="line">多表查询</span><br><span class="line">- 内连接</span><br><span class="line">从笛卡尔积中筛选出有效的数据，内连接只显示两个表匹配得上的数据。</span><br><span class="line">SELECT * FROM emp a ,dept b WHERE a.id &#x3D; b.id;</span><br><span class="line"> select 字段列表 from 表名1 [inner] join 表名2 on 条件</span><br><span class="line"> </span><br><span class="line">- 左、右外连接</span><br><span class="line">左外（以左边的表为主表，主表的数据会全部展示） 右外（以右边的表为主表，主表的数据会全部展示）</span><br><span class="line">左外连接&#x3D;左表全部记录+相关联结果</span><br><span class="line">右外连接&#x3D;右表全部记录+相关联结果</span><br><span class="line">SELECT * FROM emps e LEFT JOIN  dept d ON  e.dept_id&#x3D;d.did  -- 左外</span><br><span class="line"></span><br><span class="line">SELECT * FROM emps e RIGHT JOIN  dept d ON  e.dept_id&#x3D;d.did  -- 右外</span><br><span class="line"></span><br><span class="line">SELECT * FROM  dept d RIGHT JOIN  emps e  ON  e.dept_id&#x3D;d.did  -- 右外 和第一个等效</span><br><span class="line"></span><br><span class="line">- 模拟全外连接</span><br><span class="line">左表和右表都不做限制，所有的记录都显示，两表不足的地方用null 填充；</span><br><span class="line">全外连接&#x3D;左表全部记录+右表全部记录+相关联结果&#x3D;左外连接+右外连接-相关联结果（即去重复）</span><br><span class="line">union all或union纵向合并结果集，只需要两个结果集的列数和列类型相同即可，无需名称相同。</span><br><span class="line">(SELECT id,&#96;name&#96; FROM emps) UNION (SELECT did,dname FROM dept);</span><br><span class="line"></span><br><span class="line">全外连接-左外和右外使用union纵向合并结果集即可</span><br><span class="line">(SELECT * FROM dept d LEFT JOIN emps e ON e.dept_id-d.did)</span><br><span class="line">UNION</span><br><span class="line">(SELECT * FROM dept d RIGHT JOIN emps e ON e.dept_id-d.did);</span><br><span class="line"></span><br><span class="line">子查询：查询中嵌套查询，称嵌套查询为子查询。</span><br><span class="line">SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.&#96;join_date&#96; &gt; &#39;2019-11-11&#39;)  t2</span><br><span class="line">WHERE t1.id &#x3D; t2.dept_id;</span><br></pre></td></tr></table></figure>

<h3><span id="4-shu-ju-kong-zhi-yu-yan-dcl"><strong>4.数据控制语言（DCL）</strong></span><a href="#4-shu-ju-kong-zhi-yu-yan-dcl" class="header-anchor">#</a></h3><p>通过GRANT和REVOKE，确定单个用户或用户组对数据库对象的访问权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">管理用户，授权</span><br><span class="line">	1. 管理用户</span><br><span class="line">		1. 添加用户：</span><br><span class="line">			* 语法：CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</span><br><span class="line">		2. 删除用户：</span><br><span class="line">			* 语法：DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</span><br><span class="line">		3. 修改用户密码：</span><br><span class="line">			</span><br><span class="line">			UPDATE USER SET PASSWORD &#x3D; PASSWORD(&#39;新密码&#39;) WHERE USER &#x3D; &#39;用户名&#39;;</span><br><span class="line">			UPDATE USER SET PASSWORD &#x3D; PASSWORD(&#39;abc&#39;) WHERE USER &#x3D; &#39;lisi&#39;;</span><br><span class="line">			</span><br><span class="line">			SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; &#x3D; PASSWORD(&#39;新密码&#39;);</span><br><span class="line">			SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; &#x3D; PASSWORD(&#39;123&#39;);</span><br><span class="line">	通配符： % 表示可以在任意主机使用用户登录数据库</span><br><span class="line">			</span><br><span class="line">	mysql中忘记了root用户的密码,前提是有服务器的root权限</span><br><span class="line">				1. cmd -- &gt; net stop mysql 停止mysql服务</span><br><span class="line">					* 需要管理员运行该cmd</span><br><span class="line">				2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables</span><br><span class="line">				3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功</span><br><span class="line">				4. use mysql;</span><br><span class="line">				5. update user set password &#x3D; password(&#39;你的新密码&#39;) where user &#x3D; &#39;root&#39;;</span><br><span class="line">				6. 关闭两个窗口</span><br><span class="line">				7. 打开任务管理器，手动结束mysqld.exe 的进程</span><br><span class="line">				8. 启动mysql服务</span><br><span class="line">				9. 使用新密码登录。</span><br><span class="line">权限管理：</span><br><span class="line">常用权限有：select,update,alter,delete，create</span><br><span class="line">all可以代表除了grant之外的所有权限</span><br><span class="line">		1. 查询权限：</span><br><span class="line">			-- 查询权限</span><br><span class="line">			SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</span><br><span class="line">			SHOW GRANTS FOR &#39;lisi&#39;@&#39;%&#39;;</span><br><span class="line"></span><br><span class="line">		2. 授予权限：</span><br><span class="line">			1.授予权限</span><br><span class="line">			grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;</span><br><span class="line">			-- 给张三用户授予所有权限，在任意数据库任意表上</span><br><span class="line">			GRANT ALL ON *.* TO &#39;zhangsan&#39;@&#39;localhost&#39;;</span><br><span class="line">			</span><br><span class="line">			2.授予列权限</span><br><span class="line">		授予用户bob可以对test.a表的id和name列进行更新</span><br><span class="line">		grant update(id,name) on test.a to ‘bob’@‘localhost’;</span><br><span class="line"></span><br><span class="line">		3.授予数据库权限</span><br><span class="line">		授予用户bob可以对test数据库中的所有表进行查询</span><br><span class="line">		grant select on test.* to bob;</span><br><span class="line">		授予jim在test数据库中创建、修改、删除表的权限以及创建视图的权限</span><br><span class="line">		grant create、alter、drop、create view on test.* to jim;</span><br><span class="line">		授予jim可以对当前数据库中的所有表进行查询</span><br><span class="line">		grant select on * to jim; *----表示当前数据库</span><br><span class="line">		授予jim可以创建、修改、删除数据库以及对所有数据库中的所有表进行create、alter和drop</span><br><span class="line">		grant create,alter,drop on . to jim；</span><br><span class="line">		授予jim可以创建新用户</span><br><span class="line">		grant create user on . to jim;</span><br><span class="line">		授予newroot1具有和root@localhost一样的权限</span><br><span class="line">		grant all on . to ‘newroot1’@‘localhost’ with grant option;</span><br><span class="line">		all权限没有给别人赋权的权限，因此要在最后加with grant option</span><br><span class="line">		查看自己的权限：</span><br><span class="line">		show grants;</span><br><span class="line"></span><br><span class="line">		权限的传递   </span><br><span class="line">		with grant option子句：通过在grant语句的最后使用该子句，就允许被授权的用户把得到的权限继续授给其它用户    </span><br><span class="line">授予jim对teams表具有references权限，并允许他把权限授给其它用户</span><br><span class="line">grant references on teams to jim with grant option;</span><br><span class="line"></span><br><span class="line">3. 撤销权限：</span><br><span class="line">			-- 撤销权限：</span><br><span class="line">			revoke 权限列表 on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;</span><br><span class="line">			REVOKE UPDATE ON db.dept FROM &#39;user&#39;@&#39;%&#39;;	</span><br><span class="line">4. 删除用户</span><br><span class="line"> 　　mysql&gt;Delete FROM user Where User&#x3D;&#39;test&#39; and Host&#x3D;&#39;localhost&#39;;</span><br><span class="line"> 　　mysql&gt;flush privileges;</span><br><span class="line">		删除账户及权限：</span><br><span class="line">drop user 用户名@&#39;%&#39;;</span><br><span class="line">drop user 用户名@ localhost; </span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>
<h3><span id="5-shi-wu-chu-li-yu-yan-dpl"><strong>5.事务处理语言（DPL）</strong></span><a href="#5-shi-wu-chu-li-yu-yan-dpl" class="header-anchor">#</a></h3><p>事务处理语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION、COMMIT和ROLLBACK。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 事务的基本介绍</span><br><span class="line">概念：</span><br><span class="line">		*  事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。	</span><br><span class="line">操作：</span><br><span class="line">		1. 开启事务： start transaction;</span><br><span class="line">		2. 回滚：rollback;</span><br><span class="line">		3. 提交：commit;</span><br><span class="line">事务的四大特征：</span><br><span class="line">	1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。</span><br><span class="line">	2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。</span><br><span class="line">	3. 隔离性：多个事务之间。相互独立。</span><br><span class="line">	4. 一致性：事务操作前后，数据总量不变</span><br><span class="line">3. 事务的隔离级别</span><br><span class="line">	* 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些			问题，设置不同的隔离级别就可以解决这些问题。</span><br><span class="line">	* 存在问题：</span><br><span class="line">		1. 脏读：一个事务，读取到另一个事务中没有提交的数据</span><br><span class="line">		2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。</span><br><span class="line">		3. 幻读：事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据 ,查询不到自己的修改。</span><br><span class="line">如果事务A 按一定条件搜索， 期间事务B 删除了符合条件的某一条数据，导致事务A 再次读取时数据少了一条。这种情况归为 不可重复读事务</span><br><span class="line"></span><br><span class="line">	* 隔离级别：</span><br><span class="line">		1. read uncommitted：读未提交</span><br><span class="line">			* 产生的问题：脏读、不可重复读、幻读</span><br><span class="line">		2. read committed：读已提交 （Oracle）</span><br><span class="line">			* 产生的问题：不可重复读、幻读</span><br><span class="line">		3. repeatable read：可重复读 （MySQL默认）</span><br><span class="line">			* 产生的问题：幻读</span><br><span class="line">		4. serializable：串行化</span><br><span class="line">			* 可以解决所有的问题</span><br><span class="line"></span><br><span class="line">		* 注意：隔离级别从小到大安全性越来越高，但是效率越来越低</span><br><span class="line">		* 数据库查询隔离级别：</span><br><span class="line">			*select @@transaction_isolation;</span><br><span class="line">		MySQL8.0 以前用的是：tx_isolation 现在用是： transaction_isolation</span><br><span class="line">		* 数据库设置隔离级别：</span><br><span class="line">			* set global transaction isolation level  级别字符串;</span><br></pre></td></tr></table></figure>
<h3><span id="6-zhi-zhen-kong-zhi-yu-yan-ccl"><strong>6.指针控制语言（CCL）</strong></span><a href="#6-zhi-zhen-kong-zhi-yu-yan-ccl" class="header-anchor">#</a></h3><p>它的语句，想DECLARE CURSOR、FETCH INTO和UPDATE WHERE CURRENT用于对一个或多个表单独行的操作。</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>安装配置Hadoop开发环境</title>
    <url>/2020/04/08/hadoop_setup/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#an-zhuang-pei-zhi-hadoop-kai-fa-huan-jing">安装配置Hadoop开发环境</a><ul>
<li><a href="#xia-zai-hadoop">下载Hadoop</a></li>
<li><a href="#pei-zhi-hadoop-huan-jing">配置Hadoop环境</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
# 安装配置Hadoop开发环境

<h2><span id="xia-zai-hadoop">下载Hadoop</span><a href="#xia-zai-hadoop" class="header-anchor">#</a></h2><p>我们去官网下载：<a href="http://hadoop.apache.org/" target="_blank" rel="noopener">http://hadoop.apache.org/</a></p>
<a id="more"></a>

<h2><span id="pei-zhi-hadoop-huan-jing">配置Hadoop环境</span><a href="#pei-zhi-hadoop-huan-jing" class="header-anchor">#</a></h2><p>来搭建一个单节点的集群，配置一个伪分布式，为什么不做分布式呢？</p>
<p>其实分布式的配置和伪分布式差不多，只是分布式机器增加了而已，其他没什么两样。</p>
<p>##设置SSH免密登录<br>在之后操作集群的时候我们需要经常登录主机和从机，所以设置SSH免密登录时有必要的。</p>
<p>输入如下代码：</p>
<p> ssh-keygen -t rsa -P ‘’<br>生成无密码密钥对，询问保存路径直接输入回车，生成密钥对：id_rsa和id_rsa.pub，默认存储在~/.ssh目录下。 </p>
<p>接下来：把id_rsa.pub追加到授权的key里面去。</p>
<p>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys<br>然后修改权限：</p>
<p>chmod 600 ~/.ssh/authorized_keys<br>接着需要启用RSA认证，启动公钥私钥配对认证方式：  </p>
<p>vim /etc/ssh/sshd_config  如果提示权限不足在命令前加上sudo；</p>
<p>修改ssh配置：</p>
<p>RSAAuthentication yes # 启用 RSA 认证<br>PubkeyAuthentication yes # 启用公钥私钥配对认证方式<br>AuthorizedKeysFile %h/.ssh/authorized_keys # 公钥文件路径</p>
<p>重启SSH：<br>service ssh restart</p>
<p>好了准备工作已经做完了，我们要开始修改Hadoop的配置文件了，总共需要修改6个文件。分别是：</p>
<p>hadoop-env.sh；<br>yarn-env.sh ；<br>core-site.xml；<br>hdfs-site.xml；<br>mapred-site.xml；<br>yarn-site.xml。<br>我们一个一个接着来配置吧！</p>
<p>hadoop-env.sh 配置<br>两个env.sh文件主要是配置JDK的位置</p>
<p>提示：如果忘记了JDK的位置了，输入 echo $JAVA_HOME就可以看到哦。</p>
<p>首先我们切换到hadoop目录下</p>
<p>cd /app/hadoop3.1/etc/hadoop/<br>编辑  hadoop-env.sh在文件中插入如下代码： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> # The java implementation to use.  </span><br><span class="line"> #export JAVA_HOME&#x3D;$&#123;JAVA_HOME&#125;  </span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;app&#x2F;jdk1.8.0_171</span><br></pre></td></tr></table></figure>
<p>yarn-env.sh 配置<br>编辑yarn-env.sh 插入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;app&#x2F;jdk1.8.0_171</span><br></pre></td></tr></table></figure>
<p>core-site.xml配置<br>这个是核心配置文件我们需要在该文件中加入HDFS的URI和NameNode的临时文件夹位置，这个临时文件夹在下文中会创建。</p>
<p>在文件末尾的configuration标签中添加代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;  </span><br><span class="line"> &lt;property&gt;  </span><br><span class="line">    &lt;name&gt;fs.default.name&lt;&#x2F;name&gt;  </span><br><span class="line">    &lt;value&gt;hdfs:&#x2F;&#x2F;localhost:9000&lt;&#x2F;value&gt;  </span><br><span class="line">    &lt;description&gt;HDFS的URI，文件系统:&#x2F;&#x2F;namenode标识:端口号&lt;&#x2F;description&gt;  </span><br><span class="line">&lt;&#x2F;property&gt;  </span><br><span class="line">&lt;property&gt;  </span><br><span class="line">    &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;  </span><br><span class="line">    &lt;value&gt;&#x2F;usr&#x2F;hadoop&#x2F;tmp&lt;&#x2F;value&gt;  </span><br><span class="line">    &lt;description&gt;namenode上本地的hadoop临时文件夹&lt;&#x2F;description&gt;  </span><br><span class="line">&lt;&#x2F;property&gt;  </span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<p>hdfs-site.xml文件配置<br>replication指的是副本数量，我们现在是单节点，所以是1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;  </span><br><span class="line">&lt;property&gt;  </span><br><span class="line">    &lt;name&gt;dfs.name.dir&lt;&#x2F;name&gt;  </span><br><span class="line">    &lt;value&gt;&#x2F;usr&#x2F;hadoop&#x2F;hdfs&#x2F;name&lt;&#x2F;value&gt;  </span><br><span class="line">    &lt;description&gt;namenode上存储hdfs名字空间元数据 &lt;&#x2F;description&gt;   </span><br><span class="line">&lt;&#x2F;property&gt;  </span><br><span class="line">&lt;property&gt;  </span><br><span class="line">    &lt;name&gt;dfs.data.dir&lt;&#x2F;name&gt;  </span><br><span class="line">    &lt;value&gt;&#x2F;usr&#x2F;hadoop&#x2F;hdfs&#x2F;data&lt;&#x2F;value&gt;  </span><br><span class="line">    &lt;description&gt;datanode上数据块的物理存储位置&lt;&#x2F;description&gt;  </span><br><span class="line">&lt;&#x2F;property&gt;  </span><br><span class="line">&lt;property&gt;  </span><br><span class="line">    &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;  </span><br><span class="line">    &lt;value&gt;1&lt;&#x2F;value&gt;  </span><br><span class="line">&lt;&#x2F;property&gt;  </span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<p>mapred-site.xml文件配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<p>yarn-site.xml配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;  </span><br><span class="line">&lt;property&gt;  </span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;  </span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;  </span><br><span class="line">&lt;&#x2F;property&gt;  </span><br><span class="line">&lt;property&gt;  </span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.webapp.address&lt;&#x2F;name&gt;  </span><br><span class="line">        &lt;value&gt;192.168.2.10:8099&lt;&#x2F;value&gt;  </span><br><span class="line">        &lt;description&gt;这个地址是mr管理界面的&lt;&#x2F;description&gt;  </span><br><span class="line">&lt;&#x2F;property&gt;  </span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<p>创建文件夹</p>
<p>我们在配置文件中配置了一些文件夹路径，现在我们来创建他们，在/usr/hadoop/目录下使用hadoop用户操作，建立tmp、hdfs/name、hdfs/data目录，执行如下命令：</p>
<p>mkdir -p /usr/hadoop/tmp<br>mkdir /usr/hadoop/hdfs<br>mkdir /usr/hadoop/hdfs/data<br>mkdir /usr/hadoop/hdfs/name<br>将Hadoop添加到环境变量中<br>vim /etc/profile<br>在文件末尾插入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #set Hadoop Enviroment</span><br><span class="line">export HADOOP-_HOME-&#x2F;app&#x2F;hadoop3.1</span><br><span class="line">export PATH&#x3D;SPATH：SHADOOP_HOME&#x2F;bin：SHADOOP_HOME&#x2F;sbin</span><br></pre></td></tr></table></figure>
<p>最后使修改生效：source /etc/profile</p>
<p>##验证<br>现在配置工作已经基本搞定，接下来只需要完成：1.格式化HDFS文件、2.启动hadoop、3.验证Hadoop 即可。</p>
<p>格式化<br>在使用Hadoop之前我们需要格式化一些hadoop的基本信息。</p>
<p>使用如下命令：</p>
<p>hadoop namenode -format</p>
<p>##启动Hadoop<br>接下来我们启动Hadoop：</p>
<p>start-dfs.sh</p>
<p>之后如果你是图形化界面，可以在你虚拟机的图形化界面中打开火狐浏览器输入：<a href="http://localhost:9870/" target="_blank" rel="noopener">http://localhost:9870/</a> 访问hadoop的管理页面。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop shell命令使用</title>
    <url>/2020/04/08/hadoop_shell/</url>
    <content><![CDATA[<p>常用的shell命令，在之后使用的时候可以作为参考。<br>hadoop fs</p>
<table>
<thead>
<tr>
<th>选项名称</th>
<th>使用格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-ls</td>
<td>-ls &lt;路径&gt;</td>
<td>查看指定路径的当前目录结构</td>
</tr>
<tr>
<td>-lsr</td>
<td>-lsr &lt;路径&gt;</td>
<td>递归查看指定路径的目录结构</td>
</tr>
<tr>
<td>-du</td>
<td>-du &lt;路径&gt;</td>
<td>统计目录下个文件大小</td>
</tr>
<tr>
<td>-dus</td>
<td>-dus &lt;路径&gt;</td>
<td>汇总统计目录下文件(夹)大小</td>
</tr>
<tr>
<td>-count</td>
<td>-count [-q] &lt;路径&gt;</td>
<td>统计文件(夹)数量</td>
</tr>
<tr>
<td>-mv</td>
<td>-mv &lt;源路径&gt; &lt;目的路径&gt;</td>
<td>移动</td>
</tr>
<tr>
<td>-cp</td>
<td>-cp &lt;源路径&gt; &lt;目的路径&gt;</td>
<td>复制</td>
</tr>
<tr>
<td>-rm</td>
<td>-rm [-skipTrash] &lt;路径&gt;</td>
<td>删除文件/空白文件夹</td>
</tr>
<tr>
<td>-rmr</td>
<td>-rmr [-skipTrash] &lt;路径&gt;</td>
<td>递归删除</td>
</tr>
<tr>
<td>-put</td>
<td>-put &lt;多个 linux 上的文件&gt; &lt;hdfs 路径&gt;</td>
<td>上传文件</td>
</tr>
<tr>
<td>-copyFromLocal</td>
<td>-copyFromLocal &lt;多个 linux 上的文件&gt;&lt;hdfs 路径&gt;</td>
<td>从本地复制</td>
</tr>
<tr>
<td>-moveFromLocal</td>
<td>-moveFromLocal &lt;多个 linux 上的文件&gt;&lt;hdfs 路径&gt;</td>
<td>从本地移动</td>
</tr>
<tr>
<td>-getmerge</td>
<td>-getmerge &lt;源路径&gt; &lt;linux 路径&gt;</td>
<td>合并到本地</td>
</tr>
<tr>
<td>-cat</td>
<td>-cat &lt;hdfs 路径&gt;</td>
<td>查看文件内容</td>
</tr>
<tr>
<td>-text</td>
<td>-text &lt;hdfs 路径&gt;</td>
<td>查看文件内容</td>
</tr>
<tr>
<td>-copyToLocal</td>
<td>-copyToLocal [-ignoreCrc] [-crc] [hdfs 源路径] [linux 目的路径]</td>
<td>从HDFS复制到本地</td>
</tr>
<tr>
<td>-moveToLocal</td>
<td>-moveToLocal [-crc] &lt;hdfs 源路径&gt; &lt;linux目的路径&gt;    从HDFS移动到本地</td>
<td></td>
</tr>
<tr>
<td>-mkdir</td>
<td>-mkdir &lt;hdfs 路径&gt;</td>
<td>创建空白文件夹</td>
</tr>
<tr>
<td>-setrep</td>
<td>-setrep [-R] [-w] &lt;副本数&gt; &lt;路径&gt;</td>
<td>修改副本数量</td>
</tr>
<tr>
<td>-touchz</td>
<td>-touchz &lt;文件路径&gt;</td>
<td>创建空白文件</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>python根据ip地址定位地理位置并转换为.exe文件</title>
    <url>/2020/04/22/geoip/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#an-zhuang-ku-he-shu-ju-zhun-bei">安装库和数据准备</a></li>
<li><a href="#dai-ma-ru-xia">代码如下</a></li>
<li><a href="#jiang-py-wen-jian-zhuan-wei-exe-wen-jian">将py文件转为.exe文件</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>

<h2><span id="an-zhuang-ku-he-shu-ju-zhun-bei">安装库和数据准备</span><a href="#an-zhuang-ku-he-shu-ju-zhun-bei" class="header-anchor">#</a></h2><p>由于离线查询ip需要全球IP的分布数据，所以我直接选择了一个免费离线查询ip的数据包,  </p>
<p><a href="https://download.csdn.net/download/qq_42112448/12289578" target="_blank" rel="noopener">GeoLite2-City.mmdb</a></p>
<p>MMDB即Maxmind DB，是一个设计用于存储IPv4和IPv6的数据信息的数据库，mmdb文件是一个二进制格式的文件，它使用一个二分查找树加速IP信息的查询。</p>
<p>格式说明</p>
<pre><code>{
continent =&gt; {                    //大洲
    code        =&gt; string,        //大洲代码，如AS，可能为空
    names       =&gt; {              //大洲名称
        en      =&gt; string,        //大洲英文名称，如Asia，可能为空
        zh_CN   =&gt; string,        //大洲中文名称，如亚洲，可能为空
    },
},
country   =&gt; {                    //国家
    iso_code    =&gt; string,        //国家iso代码，如CN，可能为空
    names       =&gt; {              //国家名称
        en      =&gt; string,        //国家英文名称，如China，可能为空
        zh_CN   =&gt; string,        //国家中文名称，如中国，可能为空
    },
},
subdivisions =&gt; {                 //省份
    iso_code    =&gt; string,        //省iso代码省ISO代码，如44，可能为空
    names       =&gt; {              //省份名称
        en      =&gt; string,        //省份英文名称，如Guangdong，可能为空
        zh_CN   =&gt; string,        //省份中文名称，如广东，可能为空
    },
},
city      =&gt; {                    //城市
    id          =&gt; int,           //城市id，如440000，可能为空
    names       =&gt; {              //城市名称
        en      =&gt; string,        //城市英文名称，如Guangzhou，可能为空
        zh_CN   =&gt; string,        //城市中文名称，如广州，可能为空
    },
},
location  =&gt; {                    //地理位置
    latitude    =&gt; double,        //纬度，可能为空
    longitude   =&gt; double,        //经度，可能为空
    time_zone   =&gt; string,        //时区，可能为空
},
isp       =&gt; {                    //运营商
    id          =&gt; int,           //运营商id，可能为空
    names       =&gt; {              //运营商名称
        zh_CN   =&gt; string,        //运营商中文名称，如电信，可能为空
},
}</code></pre><p>为了读取这个包的数据需要安装一个模块：pip install geoip2<br>为了布局窗口安装一个模块：pip install tkinter    </p>
<h2><span id="dai-ma-ru-xia">代码如下</span><a href="#dai-ma-ru-xia" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tkinter</span><br><span class="line">import pygeoip,geoip2.database</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FindLocation(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.gi &#x3D; geoip2.database.Reader(&quot;.&#x2F;GeoLite2-City.mmdb&quot;)</span><br><span class="line">        # 创建主窗口,用于容纳其它组件</span><br><span class="line">        self.root &#x3D; tkinter.Tk()</span><br><span class="line">        # 给主窗口设置标题内容</span><br><span class="line">        self.root.title(&quot;全球定位ip位置(离线版)&quot;)</span><br><span class="line">        # 创建一个输入框,并设置尺寸</span><br><span class="line">        self.ip_input &#x3D; tkinter.Entry(self.root, width&#x3D;30)</span><br><span class="line"></span><br><span class="line">        # 创建一个回显列表</span><br><span class="line">        self.display_info &#x3D; tkinter.Listbox(self.root, width&#x3D;50)</span><br><span class="line"></span><br><span class="line">        # 创建一个查询结果的按钮</span><br><span class="line">        self.result_button &#x3D; tkinter.Button(self.root, command&#x3D;self.find_position, text&#x3D;&quot;查询&quot;)</span><br><span class="line"></span><br><span class="line">    # 完成布局</span><br><span class="line">    def gui_arrang(self):</span><br><span class="line">        self.ip_input.pack()</span><br><span class="line">        self.display_info.pack()</span><br><span class="line">        self.result_button.pack()</span><br><span class="line"></span><br><span class="line">    # 根据ip查找地理位置</span><br><span class="line">    def find_position(self):</span><br><span class="line">        # 获取输入信息</span><br><span class="line">        self.ip_addr &#x3D; self.ip_input.get()</span><br><span class="line">        aim &#x3D; self.gi.city(self.ip_addr)</span><br><span class="line">        # 为了避免非法值,导致程序崩溃,有兴趣可以用正则写一下具体的规则,我为了便于新手理解,减少代码量,就直接粗放的过滤了</span><br><span class="line">        try:</span><br><span class="line"></span><br><span class="line">            # 获取目标城市</span><br><span class="line">            city &#x3D; aim.city.name</span><br><span class="line">            # 获取目标国家</span><br><span class="line">            country &#x3D; aim.country.name</span><br><span class="line">            # 获取目标经度</span><br><span class="line">            longitude &#x3D; aim.location.longitude</span><br><span class="line">            # 获取目标纬度</span><br><span class="line">            latitude &#x3D; aim.location.latitude</span><br><span class="line">        except:</span><br><span class="line">            pass</span><br><span class="line"></span><br><span class="line">        # 创建临时列表</span><br><span class="line">        the_ip_info &#x3D; [&quot;所在纬度:&quot; + str(latitude), &quot;所在经度:&quot; + str(longitude), &quot;所在城市:&quot; + str(city), &quot;所在国家或地区:&quot; + str(country), &quot;需要查询的ip:&quot; + str(self.ip_addr)]</span><br><span class="line">        # 清空回显列表可见部分,类似clear命令</span><br><span class="line">        for item in range(10):</span><br><span class="line">            self.display_info.insert(0, &quot;&quot;)</span><br><span class="line"></span><br><span class="line">        # 为回显列表赋值</span><br><span class="line">        for item in the_ip_info:</span><br><span class="line">            self.display_info.insert(0, item)</span><br><span class="line">        # 这里的返回值,没啥用,就是为了好看</span><br><span class="line">        return the_ip_info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 初始化对象</span><br><span class="line">    FL &#x3D; FindLocation()</span><br><span class="line">    # 进行布局</span><br><span class="line">    FL.gui_arrang()</span><br><span class="line">    # 主程序执行</span><br><span class="line">    tkinter.mainloop()</span><br><span class="line">    pass</span><br><span class="line">    </span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>效果如下<br><img src="https://img-blog.csdnimg.cn/20200402234903859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<h2><span id="jiang-py-wen-jian-zhuan-wei-exe-wen-jian">将py文件转为.exe文件</span><a href="#jiang-py-wen-jian-zhuan-wei-exe-wen-jian" class="header-anchor">#</a></h2><ol>
<li>安装pyinstaller  <blockquote>
<p>pip install pyinstaller</p>
</blockquote>
</li>
<li>将.py转换为.exe<br>(1) 进入文件夹，运行cmd<br>(2)pyinstaller -F -w localip.py</li>
</ol>
<p>-w表示运行.exe是弹出命令行窗口<br>更改exe文件的图标<br>自定义打包出来的exe文件图标，需要使用-i参数，同时需要准备一个ico格式的图片<br>pyinstaller -F –icon=1234.ico localip.py<br>1234.ico为当前路径下的图标文件，在其他位置需要加上路径<br>（3）运行测试<br>生成的.exe文件在dist文件夹内<br>将数据库文件GeoLite2-City.mmdb拷贝到dist文件夹中<br>运行可执行文件(.exe)</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase Shell常用命令入门</title>
    <url>/2020/05/15/hbase-shell/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#ji-ben-cao-zuo">基本操作</a><ul>
<li><a href="#tian-jia-shu-ju">添加数据</a></li>
<li><a href="#cha-kan-shu-ju">查看数据</a></li>
<li><a href="#shan-chu-biao">删除表</a></li>
<li><a href="#xiu-gai-biao-jie-gou">修改表结构</a></li>
<li><a href="#quan-xian-guan-li">权限管理</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>
#HBase Shell常用命令入门
shell命令|描述
:-:|:-:
version|查看版本
alter|修改列族（column family)模式
count|统计表中行列数
create|创建表
describe|显示表的相关信息
delete|删除指定对象的值（行、列对应的值，可以指定时间）
deleteall|删除指定行的所有元素值
disable|使表无效
enable|使表有效
drop|删除表
exist|测试表是否存在
get|获取行或单元格（cell)的值
put|向指定单元格添加值
incr|增加指定行或列的值
list|列出Hbase存在的所有表
scan|扫描表来获取值
status|查看hbase集群的状态信息
truncate|重新创建指定表
shutdown|关闭hbase集群服务（与exit不同，必须重启才能恢复）
exit|退出（还可以重新进入）

<p>##创建表<br>创建了一个“student”表，属性有：name,sex,age,,course。因为HBase的表中会有一个系统默认的属性作为行键，无需自行创建，默认为put命令操作中表名后第一个数据。定义表的时候只需要指定column family的名字，列名在put的时候动态指定</p>
<blockquote>
<p>create ‘student’,’name’,’sex’,’age’,’course’</p>
</blockquote>
<p>建立一个有3个column family的表,指定保存的版本数（假设指定为3),默认为1.</p>
<blockquote>
<p>create ‘t1’, {NAME =&gt; ‘f1’, VERSIONS =&gt; 3}, {NAME =&gt; ‘f2’, VERSIONS =&gt; 3}, {NAME =&gt; ‘f3’, VERSIONS =&gt; 3}</p>
</blockquote>
<p>查看“student”表的基本信息</p>
<blockquote>
<p>describe ‘student’</p>
</blockquote>
<h2><span id="ji-ben-cao-zuo">基本操作</span><a href="#ji-ben-cao-zuo" class="header-anchor">#</a></h2><h3><span id="tian-jia-shu-ju">添加数据</span><a href="#tian-jia-shu-ju" class="header-anchor">#</a></h3><p>一次只能为一个表的一行数据的一个列，也就是一个单元格添加一个数据</p>
<p>为student表添加了学号为95001，名字为zhang的一行数据，其行键为8279。</p>
<blockquote>
<p>put ‘student’,’95001’,’name’,’zhang’</p>
</blockquote>
<p>行键为8279下的course列族的math列添加了一个数据。</p>
<blockquote>
<p>put ‘student’,’8279’,’course:math’,’80’</p>
</blockquote>
<p>手工把memstore写到Hfile中,每次flash都会建一个新的hfile.11</p>
<p>flush ‘t1’<br>###删除数据</p>
<p>删除了student表中8279行下的sex列的所有数据。</p>
<blockquote>
<p>delete ‘student’,’8279’,’sex’</p>
</blockquote>
<p>删除了student表中的95001行的全部数据。</p>
<blockquote>
<p>deleteall ‘student’,’8279’</p>
</blockquote>
<p>delete ‘t1’,’rowkey001’,’f1:col1’</p>
<p>注：将删除改行f1:col1列所有版本的数据</p>
<h3><span id="cha-kan-shu-ju">查看数据</span><a href="#cha-kan-shu-ju" class="header-anchor">#</a></h3><p>返回的是‘student’表‘95001’行的数据。</p>
<blockquote>
<p>get ‘student’,’95001’<br>返回的是‘student’表的全部数据。<br>scan ‘student’<br>查询时，指定查询的历史版本数。默认会查询出最新的数据。</p>
</blockquote>
<blockquote>
<p>get ‘teacher’,’8279’,{COLUMN=&gt;’username’,VERSIONS=&gt;5}</p>
</blockquote>
<h3><span id="shan-chu-biao">删除表</span><a href="#shan-chu-biao" class="header-anchor">#</a></h3><p>删除表有两步，第一步先让该表不可用，第二步删除表。</p>
<pre><code>disable &apos;student&apos;  
drop &apos;student&apos;</code></pre><h3><span id="xiu-gai-biao-jie-gou">修改表结构</span><a href="#xiu-gai-biao-jie-gou" class="header-anchor">#</a></h3><p>修改表结构必须先disable</p>
<blockquote>
<p>alter ‘t1’, {NAME =&gt; ‘f1’}, {NAME =&gt; ‘f2’, METHOD =&gt; ‘delete’}</p>
</blockquote>
<h3><span id="quan-xian-guan-li">权限管理</span><a href="#quan-xian-guan-li" class="header-anchor">#</a></h3><p>1）分配权限<br>语法 : grant &lt;user&gt; &lt;permissions&gt; &lt;table&gt; &lt;column family&gt; &lt;column qualifier&gt; </p>
<p>参数后面用逗号分隔</p>
<p>权限用五个字母表示： “RWXCA”.</p>
<p> READ(‘R’), WRITE(‘W’), EXEC(‘X’), CREATE(‘C’), ADMIN(‘A’)</p>
<p>2）查看权限</p>
<p>语法：user_permission <table></table></p>
<p>3）收回权限</p>
<p>revoke &lt;user&gt; &lt;table&gt; &lt;column family&gt; &lt;column qualifier&gt;</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>安装配置HBASE</title>
    <url>/2020/05/15/install-hbase/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#hadoop-he-hbase-ban-ben-zhi-chi">Hadoop和HBase版本支持</a></li>
<li><a href="#an-zhuang">安装</a></li>
<li><a href="#hbase-pei-zhi">HBase配置</a></li>
</ul>
<!-- tocstop -->

</div>
<a id="more"></a>
#安装配置HBase
[下载链接](http://archive.apache.org/dist/hbase/)

<p>说明：HBase的版本一定要和之前已经安装的Hadoop的版本保持兼容，不能随便选择版本。</p>
<h2><span id="hadoop-he-hbase-ban-ben-zhi-chi">Hadoop和HBase版本支持</span><a href="#hadoop-he-hbase-ban-ben-zhi-chi" class="header-anchor">#</a></h2><p><a href="http://hbase.apache.org/book.html" target="_blank" rel="noopener">参考链接</a><br><img src="https://pic.downk.cc/item/5ebd55dec2a9a83be597b77c.png" alt><br><img src="https://pic.downk.cc/item/5ebd5614c2a9a83be597fd1c.png" alt></p>
<h2><span id="an-zhuang">安装</span><a href="#an-zhuang" class="header-anchor">#</a></h2><p>本教程安装hbase-1.3.5。如果没有安装Hadoop请参考<a href="https://blog.csdn.net/qq_42112448/article/details/105128852" target="_blank" rel="noopener">安装Hadoop</a></p>
<p>1 解压安装包hbase-1.1.2-bin.tar.gz至路径 /usr/local，命令如下：</p>
<blockquote>
<p>sudo tar -zxf ~/下载/hbase-1.3.5-bin.tar.gz -C /usr/local</p>
</blockquote>
<p>2 将解压的文件名hbase-1.1.2改为hbase，命令如下：</p>
<blockquote>
<p>sudo mv /usr/local/hbase-1.3.5-bin.tar.gz /usr/local/hbase</p>
</blockquote>
<p>3 配置环境变量<br>将hbase下的bin目录添加到path中，这样，启动hbase就无需到/usr/local/hbase目录下，大大的方便了hbase的使用。编辑~/.bashrc文件</p>
<blockquote>
<p>vi ~/.bashrc</p>
</blockquote>
<p>如果没有引入过PATH请在~/.bashrc文件尾行添加如下内容：  </p>
<blockquote>
<p>export PATH=$PATH:/usr/local/hbase/bin</p>
</blockquote>
<p>编辑完成执行下面命令：  </p>
<blockquote>
<p>source ~/.bashrc</p>
</blockquote>
<p>5 查看HBase版本，确定hbase安装成功,命令如下：  </p>
<blockquote>
<p>hbase version<br><img src="https://pic.downk.cc/item/5ebd5ba9c2a9a83be59dd3b7.png" alt></p>
</blockquote>
<h2><span id="hbase-pei-zhi">HBase配置</span><a href="#hbase-pei-zhi" class="header-anchor">#</a></h2><p>HBase有三种运行模式，单机模式、伪分布式模式、分布式模式。这里我使用的是伪分布式。</p>
<p>1.配置/usr/local/hbase/conf/hbase-env.sh。命令如下：</p>
<blockquote>
<p>vi /usr/local/hbase/conf/hbase-env.sh</p>
</blockquote>
<p>配置JAVA_HOME，HBASE_CLASSPATH，HBASE_MANAGES_ZK.HBASE_CLASSPATH设置为本机Hadoop安装目录下的conf目录（即/usr/local/hadoop/conf）</p>
<blockquote>
<p>export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64<br>export HBASE_CLASSPATH=/usr/local/hadoop/conf<br>export HBASE_MANAGES_ZK=true</p>
</blockquote>
<p>2.配置/usr/local/hbase/conf/hbase-site.xml。用命令vi打开并编辑hbase-site.xml，命令如下：</p>
<p>vi /usr/local/hbase/conf/hbase-site.xml</p>
<p>修改hbase.rootdir，指定HBase数据在HDFS上的存储路径；将属性hbase.cluter.distributed设置为true。假设当前Hadoop集群运行在伪分布式模式下，在本机上运行，且NameNode运行在9000端口。hbase.rootdir指定HBase的存储目录；hbase.cluster.distributed设置集群处于分布式模式.</p>
<pre><code>&lt;configuration&gt;
    &lt;property&gt;
            &lt;name&gt;hbase.rootdir&lt;/name&gt;
            &lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
            &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;
            &lt;value&gt;true&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;</code></pre><p>3 接下来测试运行HBase</p>
<blockquote>
<p>start-dfs.sh</p>
</blockquote>
<p>再启动HBase</p>
<blockquote>
<p>start-hbase.sh</p>
</blockquote>
<p>输入命令jps</p>
<p><img src="https://pic.downk.cc/item/5ebd5ed4c2a9a83be5a1b998.png" alt></p>
<p>进入shell界面：</p>
<p>hbase shell</p>
<p>退出Shell</p>
<blockquote>
<p>exit</p>
</blockquote>
<p>停止HBase运行,命令如下：</p>
<blockquote>
<p>stop-hbase.sh</p>
</blockquote>
<p>注意：如果在操作HBase的过程中发生错误，可以通过{HBASE_HOME}目录（/usr/local/hbase）下的logs子目录中的日志文件查看错误原因。<br>这里启动关闭Hadoop和HBase的顺序一定是：<br>启动Hadoop—&gt;启动HBase—&gt;关闭HBase—&gt;关闭Hadoop</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql各种存储引擎和物理文件结构的对比</title>
    <url>/2020/04/08/mysql_engine/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#mysql-ge-chong-cun-chu-yin-qing-he-wu-li-wen-jian-jie-gou-de-dui-bi">Mysql各种存储引擎和物理文件结构的对比</a><ul>
<li><a href="#cun-chu-yin-qing">存储引擎</a></li>
<li><a href="#dui-bi">对比</a><ul>
<li><a href="#1-myisam">1、MyISAM</a></li>
<li><a href="#2-memory">2.MEMORY</a></li>
<li><a href="#3-innodb">3、InnoDB</a></li>
</ul>
</li>
<li><a href="#xuan-ze-chang-jing">选择场景</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
# Mysql各种存储引擎和物理文件结构的对比

<a id="more"></a>

<h2><span id="cun-chu-yin-qing">存储引擎</span><a href="#cun-chu-yin-qing" class="header-anchor">#</a></h2><p>即表类型(table_type),用户可以根据应用的需求选择如何来存储数据、索引、是否使用事务等。选择合适的存储引擎往往能够有效的提高数据库的性能和数据的访问效率，另外一个数据库中的多个表可以使用不同引擎的组合以满足各种性能和实际需求。</p>
<p>在mysql5之后，支持的存储引擎有十几个，但是常用的就那么几种，而且默认支持的也是InnoDB。</p>
<p>使用命令来看看当前数据库可以支持的存储引擎有哪些。</p>
<p>show engines;<br><img src="https://img-blog.csdnimg.cn/20200402145944900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<p>查看当前表使用的存储引擎</p>
<p>mysql&gt; show create table emp;</p>
<p>mysql&gt; show table status like ‘emp’ ;</p>
<p>查看数据库默认使用哪个引擎</p>
<p>SHOW VARIABLES LIKE ‘storage_engine’;</p>
<h2><span id="dui-bi">对比</span><a href="#dui-bi" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/20200402150121296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<p>存储引擎</p>
<h3><span id="1-myisam">1、MyISAM</span><a href="#1-myisam" class="header-anchor">#</a></h3><p>使用这个存储引擎，每个MyISAM在磁盘上存储成三个文件。</p>
<p>（1）frm文件：存储表的定义数据</p>
<p>（2）MYD文件：存放表具体记录的数据</p>
<p>（3）MYI文件：存储索引</p>
<p>frm和MYI可以存放在不同的目录下。MYI文件用来存储索引，但仅保存记录所在页的指针，索引的结构是B+树结构。下面这张图就是MYI文件保存的机制：<br><img src="https://img-blog.csdnimg.cn/20200402171643795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<p>从这张图可以发现，这个存储引擎通过MYI的B+树结构来查找记录页，再根据记录页查找记录。并且支持全文索引、B树索引和数据压缩。</p>
<p><strong>MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事务。MyISAM主要特性有：</strong></p>
<p>1、大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持</p>
<p>2、当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块自动完成</p>
<p>3、每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16</p>
<p>4、最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上</p>
<p>5、BLOB和TEXT列可以被索引</p>
<p>6、NULL被允许在索引的列中，这个值占每个键的0~1个字节</p>
<p>7、所有数字键值以高字节优先被存储以允许一个更高的索引压缩</p>
<p>8、每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快</p>
<p>9、可以把数据文件和索引文件放在不同目录</p>
<p>10、每个字符列可以有不同的字符集</p>
<p>11、有VARCHAR的表可以固定或动态记录长度</p>
<p>12、VARCHAR和CHAR列可以多达64KB</p>
<p>使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：frm文件存储表定义、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名时.MYI（MYIndex）</p>
<p>支持数据的类型也有三种：</p>
<p>（1）、静态表（fixed）</p>
<p>默认的存储格式</p>
<p>静态表中的字段都是非变长字段，每个记录都是固定的长度，当表不包含变量长度列(VARCHAR, BLOB, 或TEXT)时,使用这个格式。</p>
<p>优点：存储迅速，出现故障容易恢复</p>
<p>缺点：占用空间比动态表大，静态表在进行数据存储时会按照事先定义的列宽度补足空格，但在访问的时候会去掉这些空格</p>
<p>注意：如果数据本身带有空格，在返回的时候会去掉数据本身自带的末尾的空格，前面的会保留</p>
<p>（2）、动态表（dynamic）</p>
<p>包含变长字段，例如varchar、、text、blob，如果一个MyISAM表包含任何可变长度的字段（varchar、blob、text），或者该表创建时用row_format=dynamic指定，则该表使用动态格式存储</p>
<p>优点：占用空间小</p>
<p>缺点：频繁的更新和删除操作会产生碎片，需要定期用optimize table语句或myisamchk -r命令来改善性能，并且在出现故障后较难恢复</p>
<p>（3）、压缩表</p>
<p>由myisampack工具创建，占据非常小的磁盘空间，因为每个记录都是被单独压缩的</p>
<h3><span id="2-memory">2.MEMORY</span><a href="#2-memory" class="header-anchor">#</a></h3><p>MEMORY存储引擎是用保存在内存中的数据来创建表，将数据存在内存，为了提高数据的访问速度，每一个表实际上和一个磁盘文件关联。文件是frm。</p>
<p>MEMORY主要特性有：</p>
<p>1、MEMORY表的每个表可以有多达32个索引，每个索引16列，以及500字节的最大键长度</p>
<p>2、MEMORY存储引擎执行HASH和BTREE缩影</p>
<p>3、可以在一个MEMORY表中有非唯一键值</p>
<p>4、MEMORY表使用一个固定的记录长度格式</p>
<p>5、支持的数据类型有限制，比如：不支持TEXT和BLOB类型，对于字符串类型的数据，只支持固定长度的行，VARCHAR会被自动存储为CHAR类型；</p>
<p>6、MEMORY支持AUTO_INCREMENT列和对可包含NULL值的列的索引</p>
<p>7、MEMORY表在所由客户端之间共享（就像其他任何非TEMPORARY表）</p>
<p>8、MEMORY表内存被存储在内存中，内存是MEMORY表和服务器在查询处理时的空闲中，创建的内部表共享</p>
<p>9、当不再需要MEMORY表的内容时，要释放被MEMORY表使用的内存，应该执行DELETE FROM或TRUNCATE TABLE，或者删除整个表（使用DROP TABLE）</p>
<p>10.由于数据是存放在内存中，一旦服务器出现故障，数据都会丢失；</p>
<p>11.查询的时候，如果有用到临时表，而且临时表中有BLOB，TEXT类型的字段，那么这个临时表就会转化为MyISAM类型的表，性能会急剧降低；</p>
<p>优点：突破对单个MyISAM表的大小限制，通过将不同的表分布在多个磁盘上，提高访问效率</p>
<h3><span id="3-innodb">3、InnoDB</span><a href="#3-innodb" class="header-anchor">#</a></h3><p>他的主要特点有：</p>
<p>（1）可以通过自动增长列，方法是auto_increment。</p>
<p>（2）支持事务。默认的事务隔离级别为可重复度，通过MVCC（并发版本控制）来实现的。</p>
<p>（3）使用的锁粒度为行级锁，可以支持更高的并发；</p>
<p>（4）配合一些热备工具可以支持在线热备份；</p>
<p>（5）在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度；</p>
<p>（6）对于InnoDB类型的表，其数据的物理组织形式是聚簇表。所有的数据按照主键来组织。数据和索引放在一块，都位于B+数的叶子节点上；</p>
<p>（7）InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合</p>
<p>（8）InnoDB是为处理巨大数据量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系型数据库引擎锁不能匹敌的</p>
<p>（9）InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上</p>
<p>（10）InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键</p>
<p>当然InnoDB的存储表和索引也有下面两种形式：</p>
<p>（1）使用共享表空间存储：所有的表和索引存放在同一个表空间中。</p>
<p>优点：</p>
<p>1.可以将表空间分为多个文件放在不同的磁盘上，分布IO，提高性能。innodn_data_file_path=/data/ibdata1:2000M；/db/ibdata2:2000M:autoextend</p>
<p>autoextend表示如果指定的2000M空间用满后，该文件自动增长。</p>
<p>也就是说采用共享空间存储，存储空间的大小不受文件系统下文件大小的限制了，而取决于自身的限制，官方文档显示，表空间的最大限制是64TB。</p>
<p>2.表数据和表结构放在一起，方便管理</p>
<p>缺点：由于所有的数据和索引都是在一个文件中混合存储，这样的话对一个表做了大量的删除操作后，表空间中会产生大量的空隙</p>
<p>（2）使用多表空间存储：表结构放在frm文件，数据和索引放在IBD文件中。分区表的话，每个分区对应单独的IBD文件，分区表的定义可以查看我的其他文章。使用分区表的好处在于提升查询效率。</p>
<p>优点：</p>
<p>每张表都有自己独立的表空间，可实现单表在不同数据库中移动<br>空间可回收。drop table会自动回收；删除数据后，通过alter table emp engine=innodb也可回收不用的表空间<br>效率和性能会好一些<br>缺点：由于每个表的数据都是以一个单独的文件来存放，所以会受到文件系统的大小限制</p>
<p>对于InnoDB来说，最大的特点在于支持事务。但是这是以损失效率来换取的。</p>
<p>innodb的数据库的物理文件结构为：</p>
<p>.frm文件</p>
<p>.ibd文件和.ibdata文件：</p>
<p>这两种文件都是存放innodb数据的文件，之所以用两种文件来存放innodb的数据，是因为innodb的数据存储方式能够通过配置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。</p>
<p>独享表空间存储方式使用.ibd文件，并且每个表一个ibd文件</p>
<p>共享表空间存储方式使用.ibdata文件，所有表共同使用一个ibdata文件</p>
<h2><span id="xuan-ze-chang-jing">选择场景</span><a href="#xuan-ze-chang-jing" class="header-anchor">#</a></h2><p>如果要提供提交、回滚、崩溃恢复能力的事物安全（ACID兼容）能力，并要求实现并发控制，InnoDB是一个好的选择</p>
<p>如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率</p>
<p>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果</p>
<p>一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求，使用合适的存储引擎，将会提高整个数据库的性能。</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql远程连接数据库原来怎么简单</title>
    <url>/2020/08/01/mysql%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E6%9D%A5%E6%80%8E%E4%B9%88%E7%AE%80%E5%8D%95/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#yi-guan-li-yuan-shen-fen-deng-lu-pei-zhi">以管理员身份登录配置</a><ul>
<li><a href="#yi-deng-lu-mysql-shu-ru-mi-ma">一、登录mysql,输入密码</a></li>
<li><a href="#liang-chong-pei-zhi-fang-fa">两种配置方法</a></li>
</ul>
</li>
<li><a href="#zai-ben-di-shi-yong-ip-di-zhi-yuan-cheng-deng-lu">在本地使用ip地址远程登录</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h2><span id="yi-guan-li-yuan-shen-fen-deng-lu-pei-zhi">以管理员身份登录配置</span><a href="#yi-guan-li-yuan-shen-fen-deng-lu-pei-zhi" class="header-anchor">#</a></h2><h3><span id="yi-deng-lu-mysql-shu-ru-mi-ma">一、登录mysql,输入密码</span><a href="#yi-deng-lu-mysql-shu-ru-mi-ma" class="header-anchor">#</a></h3><p>mysql -uroot -p</p>
<h3><span id="liang-chong-pei-zhi-fang-fa">两种配置方法</span><a href="#liang-chong-pei-zhi-fang-fa" class="header-anchor">#</a></h3><p>一、改表法<br>    在localhost登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，将”localhost”改称”%”</p>
<p>　　mysql&gt;update user set host = ‘%’ where user = ‘root’;</p>
<p>　　mysql&gt;select host, user from user;</p>
<p>二、授权法<br>    添加用户：<br>    CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’;<br>    授予权限<br>        GRANT ALL ON <em>.</em> TO ‘myuser’@’localhost’;<br>        或</p>
<p> 你想myuser使用mypassword（密码）从任何主机连接到mysql服务器的话。            </p>
<blockquote>
<p>mysql&gt;GRANT ALL PRIVILEGES ON <em>.</em> TO ‘myuser’@’%’IDENTIFIED BY ‘mypassword’ WITH     GRANT OPTION;</p>
</blockquote>
<p>　　如果你想允许用户myuser从ip为192.168.1.5的主机连接到mysql服务器，并使用mypassword作为密码</p>
<blockquote>
<p>mysql&gt;GRANT ALL PRIVILEGES ON <em>.</em> TO ‘myuser’@’192.168.1.5’IDENTIFIED BY  ‘mypassword’ WITH GRANT OPTION;</p>
</blockquote>
<blockquote>
<p>mysql&gt;FLUSH PRIVILEGES<br>　　使修改生效，就可以了</p>
</blockquote>
<p><strong><em>这里可以看看<a href="https://blog.csdn.net/qq_42112448/article/details/107434384" target="_blank" rel="noopener">数据控制语言（DCL）</a>，强烈推荐。</em></strong></p>
<h2><span id="zai-ben-di-shi-yong-ip-di-zhi-yuan-cheng-deng-lu">在本地使用ip地址远程登录</span><a href="#zai-ben-di-shi-yong-ip-di-zhi-yuan-cheng-deng-lu" class="header-anchor">#</a></h2><ol>
<li>确定远程机器的防火墙关闭，或在防火墙允许3306端口号<blockquote>
<p>telnet 192.168.1.165 3306<br>如果不能联通，就需要在防火墙中运行3306端口入站。</p>
</blockquote>
</li>
<li>远程登录<blockquote>
<p>mysql -u root -p -h 192.168.1.104</p>
</blockquote>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200719111605416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>mapreduce基础知识</title>
    <url>/2020/04/08/mapreduce/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#mapreduce-ji-chu-zhi-shi">mapreduce基础知识</a><ul>
<li><a href="#mapreduce-bian-cheng-mo-xing">MapReduce编程模型</a></li>
<li><a href="#google-mapreduce-bing-xing-chu-li-de-ji-ben-guo-cheng">Google MapReduce并行处理的基本过程</a><ul>
<li><a href="#1-dai-kuan-you-hua">1.带宽优化：</a></li>
<li><a href="#2-yong-shu-ju-fen-qu-jie-jue-shu-ju-xiang-guan-xing-wen-ti">2.用数据分区解决数据相关性问题：</a></li>
</ul>
</li>
<li><a href="#mapreduce-kuang-jia-zu-cheng">MapReduce框架组成</a></li>
<li><a href="#shu-ju-cun-chu-yu-ji-suan-jie-dian-gou-jia">数据存储与计算节点构架</a></li>
<li><a href="#ti-xi-jie-gou">体系结构</a><ul>
<li><a href="#da-gai-liu-cheng">大概流程：</a></li>
<li><a href="#wen-jian-shu-ru-ge-shi-inputformat">文件输入格式InputFormat</a></li>
<li><a href="#shu-ru-shu-ju-fen-kuai-inputsplits">输入数据分块InputSplits</a></li>
<li><a href="#shu-ju-ji-lu-du-ru-recordreader">数据记录读入RecordReader</a></li>
<li><a href="#mapper">Mapper</a></li>
<li><a href="#shuffle-jie-duan">shuffle阶段：</a></li>
<li><a href="#reducer">Reducer</a></li>
<li><a href="#wen-jian-shu-chu-ge-shi-outputformat">文件输出格式OutputFormat</a></li>
</ul>
</li>
<li><a href="#guan-yu-hdfs-block-he-mapreduce-split">关于HDFS block和MapReduce split</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="mapreduce-ji-chu-zhi-shi">mapreduce基础知识</span><a href="#mapreduce-ji-chu-zhi-shi" class="header-anchor">#</a></h1><p>Mapreduce 是一个分布式运算程序的编程框架，是用户开发“基于 hadoop 的数据分析 应用”的核心框架</p>
<p>Mapreduce 核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的 分布式运算程序，并发运行在一个 hadoop 集群上</p>
<a id="more"></a>

<h2><span id="mapreduce-bian-cheng-mo-xing">MapReduce编程模型</span><a href="#mapreduce-bian-cheng-mo-xing" class="header-anchor">#</a></h2><p>MapReduce 由 两 个 阶 段 组 成 ：Map 和 Reduce。</p>
<p>map() 函数以 key/value 对作为输入，产生另外一系列 key/value 对作为中间输出写入本地 磁盘。MapReduce 框架会自动将这些中间数据按照 key 值进行聚集，且 key 值相同（用户可 设定聚集策略，默认情况下是对 key 值进行哈希取模）的数据被统一交给 reduce() 函数处理。<br>reduce() 函数以 key 及对应的 value 列表作为输入，经合并 key 相同的 value 值后，产 生另外一系列 key/value 对作为最终输出写入 HDFS。<br>指定三个组件分别是 InputFormat、Partitioner 和 OutputFormat， 它们均需要用户根据自己的应用需求配置①指定输入 文件格式。将输入数据切分成若干个 split，且将每个 split 中的数据解析成一个个 map() 函数 要求的 key/value 对。②确定 map() 函数产生的每个 key/value 对发给哪个 Reduce Task 函数处 理。③指定输出文件格式，即每个 key/value 对以何种形式保存到输出文件中。</p>
<h2><span id="google-mapreduce-bing-xing-chu-li-de-ji-ben-guo-cheng">Google MapReduce并行处理的基本过程</span><a href="#google-mapreduce-bing-xing-chu-li-de-ji-ben-guo-cheng" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/20200403011440528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<h3><span id="1-dai-kuan-you-hua">1.带宽优化：</span><a href="#1-dai-kuan-you-hua" class="header-anchor">#</a></h3><p>大量的键值对数据在传送给Reduce节点时会引起较大的通信带开销.·解决方案</p>
<p>每个Map节点处理完成的中间键值对将由combiner做一个合并庄缩，即把那些键名相同的鍵值对归井 为一个鍵名下的一组数值.</p>
<h3><span id="2-yong-shu-ju-fen-qu-jie-jue-shu-ju-xiang-guan-xing-wen-ti">2.用数据分区解决数据相关性问题：</span><a href="#2-yong-shu-ju-fen-qu-jie-jue-shu-ju-xiang-guan-xing-wen-ti" class="header-anchor">#</a></h3><p>一个Reduce节点上的计算数据可能会来自多个Map节点，因此，为了在进入Reduce节点计算之前，需要把属于一个Reduce节点的数据归并到一起.</p>
<p>在Map阶段进行了Corbining以后，可以根据一定的策路对Ma输出的中间结果进行分区（partitioning），这样即可解决以上数据相关性问题避免Reduceit算过程中的数据通信.</p>
<h2><span id="mapreduce-kuang-jia-zu-cheng">MapReduce框架组成</span><a href="#mapreduce-kuang-jia-zu-cheng" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/20200403011345581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<p>当一个作被提交给Hadoop时，这个作业输入数剧划分成很多个等长的快，每个数据块都会对应一个a任务。这些map任务时执行，并行化地处理数据。</p>
<p>map任务的输出排序，然后分发给Redace任务以做进一步处理。</p>
<p>作业（Job）和任务（Task）是Hadoop MapRedace并行计算框架中常重要的两个概念。</p>
<p>任务（Task）是Hadoop mapRetoce架进行并行计算的基本单位，是一个逻辑上的概念。</p>
<h2><span id="shu-ju-cun-chu-yu-ji-suan-jie-dian-gou-jia">数据存储与计算节点构架</span><a href="#shu-ju-cun-chu-yu-ji-suan-jie-dian-gou-jia" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/20200403011235621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<p>为了实现Hadoop系统设计中本地化计算的原则，数据存储节点DataNode与计算节点TaskTracker将合并设置，让每个从节点同时运行作为DataNode和TaskTracker，以此让每个TaskTracker尽可能处理存储在本地DataNode上的数据.</p>
<p>而数据主控节点NameNode与作业执行主控节点jobTracker既可以设置在同一个主控节点上，在集群规模较大或者这两个主控节点负载都很高以致于会相互影响时，也可以分开设置在两个不同的节点上.</p>
<h2><span id="ti-xi-jie-gou">体系结构</span><a href="#ti-xi-jie-gou" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/20200403011212908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<p><strong>Client（客户端）</strong></p>
<p>1.通过client可以提交用户编写的应用程序用户通过它将应</p>
<p>用程序交到JobTracker端</p>
<p>2.通过这些Client用户也可以通过它提供的一些接口去查</p>
<p>看当前提交作业的运行状态</p>
<p><strong>JobTracker（作业跟踪器）</strong></p>
<blockquote>
<p>负责资源的监控和作业的调度</p>
</blockquote>
<blockquote>
<p>监控底层的其它的TaskTracker以及当前运行的Job的健康状况</p>
</blockquote>
<blockquote>
<p>一旦探测到失败的情况就把这个任务转移到其它节点继续执行跟踪任务执行进度和资源使用量</p>
</blockquote>
<p><strong>TaskTracker（任务调度器）</strong></p>
<p>执行具体的相关任务一般接收JobTracker发送过来的命令</p>
<p>把一些自己的资源使用情况，以及任务的运行进度通过心跳的方式，也就是heartbeat发送给JobTracker</p>
<p>以slot为资源调度单位<br><img src="https://img-blog.csdnimg.cn/20200403011107433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<p>同一台机器上可以同时执行map任务和reduce任务。</p>
<p>Hadoop MapReduce执行框架的组件和执行流程<br><img src="https://img-blog.csdnimg.cn/20200403011011708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<h3><span id="da-gai-liu-cheng">大概流程：</span><a href="#da-gai-liu-cheng" class="header-anchor">#</a></h3><p>每个TaskTracker节点将从HDFS分布式文件中读取所有处理的数据。Hadoop MapReduce框架提供了一个InputFormat对象负责具体以什么样的输入格式读取数据。然后数据会被分为很多个分片（Split），每个分片将交由一个Map对象处理。再进入Map之前，需要通过RecorderReader对象逐个从数据分片中读出数据记录、并转换为Key-value键值对，逐个输入到Map中处理。Map输出中间结果前，需要经过一个Combiner对象将该Map输出的相同主键下的所有键值对合并成一个键值对；map所输出的中间结果在进入Reduce之前，先通过中间的Partitioner对象进行数据分区，将数据发送到合适的Reduce节点上，避免不同Reduce节点上数据相关性，保证每个reduce节点可独立完成本地计算；在传入Reduce节点之前还会将所有键值对按照主键值进行排序。Reduce节点完成计算后，经过OutputFormat对指定输出数据的具体格式，最终将数据输出并写回到HDFS中。</p>
<h3><span id="wen-jian-shu-ru-ge-shi-inputformat">文件输入格式InputFormat</span><a href="#wen-jian-shu-ru-ge-shi-inputformat" class="header-anchor">#</a></h3><p>InputFormat类是Hadoop MapReduce框架中的基础类之一</p>
<p>定义了数据文件如何分割和读取</p>
<p>InputFormat提供了以下一些功能</p>
<p>1.选择文件或者其它对象，用来作为输入</p>
<p>2.定义InputSplits，将一个文件分为不同任务，每一个IputSplits将单独作为一个Map的输入</p>
<p>3.提供一个RecordReader，将InputSplit处理转换为若干输入记录</p>
<p>4.有一个抽象的类FilelnputFormat，所有的输入格式类都从这个类继承其功能以及特性当启动一个Hadoop任务的时候，一个输入文件所在的目录被输入到FilelnputFormat对象中。Filelnputformat从这个目录中读取所有文件。然后FilelnputFormat将这些文件分割为多个InputSplits。</p>
<p>5.通过在JobConf对象上设置JobConf.sethnputFormat设置文件输入的格式</p>
<h3><span id="shu-ru-shu-ju-fen-kuai-inputsplits">输入数据分块InputSplits</span><a href="#shu-ru-shu-ju-fen-kuai-inputsplits" class="header-anchor">#</a></h3><p>输入数据分块InputSplits inputsplit定了输入到单个Map任务的输入数据</p>
<p>一个MapReduce程序被统称为一个Job，可能有上百个任务构成</p>
<p>InputSpilt将文件分为64MB的大小</p>
<p>·配置文件hadoop-site xml中的mepred min.split.size控制这个大小</p>
<p>mapred.tasktracker.map.taks.maximm用来控制某一个节点上所有map任务的最大数目</p>
<h3><span id="shu-ju-ji-lu-du-ru-recordreader">数据记录读入RecordReader</span><a href="#shu-ju-ji-lu-du-ru-recordreader" class="header-anchor">#</a></h3><p>数据记录读入RecordReader inputsplit定义了一个数据分块，但是没有定义如何读取数据记录</p>
<p>RecordReader实际上定义了如何将数据记录转化为一个key value对的详细方法，并将数据记录传给Mapper类</p>
<p>TexthnputFormat提供了LineRecordReader读入一个文本行数据记录</p>
<h3><span id="mapper">Mapper</span><a href="#mapper" class="header-anchor">#</a></h3><p>每一个Mapper类的实例生成了一个Java进程，负责处理某一个InputSplit上的数据有两个额外的参数OutputCollector以及Reporter，前者用来收集中间结果，后者用来获得环境参数以及设置当前执行的状态。</p>
<p>现在的版本用MapperContext提供给每一个Mapper函数，用来提供上面两个对象的功能</p>
<h3><span id="shuffle-jie-duan">shuffle阶段：</span><a href="#shuffle-jie-duan" class="header-anchor">#</a></h3><p>将map的输出作为reduce的输入的过程就是shuffle了，这个是mapreduce优化的重点地方。Shuffle一开始就是map阶段做输出操作，一般mapreduce计算的都是海量数据，map输出时候不可能把所有文件都放到内存操作，因此map写入磁盘的过程十分的复杂，更何况map输出时候要对结果进行排序，内存开销是很大的，map在做输出时候会在内存里开启一个环形内存缓冲区，这个缓冲区专门用来输出的，默认大小是100mb，并且在配置文件里为这个缓冲区设定了一个阀值，默认是0.80（这个大小和阀值都是可以在配置文件里进行配置的），同时map还会为输出操作启动一个守护线程，如果缓冲区的内存达到了阀值的80%时候，这个守护线程就会把内容写到磁盘上，这个过程叫spill，另外的20%内存可以继续写入要写进磁盘的数据，写入磁盘和写入内存操作是互不干扰的，如果缓存区被撑满了，那么map就会阻塞写入内存的操作，让写入磁盘操作完成后再继续执行写入内存操作，前面我讲到写入磁盘前会有个排序操作，这个是在写入磁盘操作时候进行，不是在写入内存时候进行的，如果我们定义了combiner函数，那么排序前还会执行combiner操作。每次spill操作也就是写入磁盘操作时候就会写一个溢出文件，也就是说在做map输出有几次spill就会产生多少个溢出文件，等map输出全部做完后，map会合并这些输出文件。这个过程里还会有一个Partitioner操作，对于这个操作很多人都很迷糊，其实Partitioner操作和map阶段的输入分片（Input split）很像，一个Partitioner对应一个reduce作业，如果我们mapreduce操作只有一个reduce操作，那么Partitioner就只有一个，如果我们有多个reduce操作，那么Partitioner对应的就会有多个，Partitioner因此就是reduce的输入分片，这个程序员可以编程控制，主要是根据实际key和value的值，根据实际业务类型或者为了更好的reduce负载均衡要求进行，这是提高reduce效率的一个关键所在。到了reduce阶段就是合并map输出文件了，Partitioner会找到对应的map输出文件，然后进行复制操作，复制操作时reduce会开启几个复制线程，这些线程默认个数是5个，程序员也可以在配置文件更改复制线程的个数，这个复制过程和map写入磁盘过程类似，也有阀值和内存大小，阀值一样可以在配置文件里配置，而内存大小是直接使用reduce的tasktracker的内存大小，复制时候reduce还会进行排序操作和合并文件操作，这些操作完了就会进行reduce计算了。</p>
<h3><span id="reducer">Reducer</span><a href="#reducer" class="header-anchor">#</a></h3><p>做用户定义的Reduce操作</p>
<p>接收到一个OutputCollector的</p>
<p>类作为输出</p>
<p>新版本的编程接口是Reducer.Context</p>
<h3><span id="wen-jian-shu-chu-ge-shi-outputformat">文件输出格式OutputFormat</span><a href="#wen-jian-shu-chu-ge-shi-outputformat" class="header-anchor">#</a></h3><p>写入到HDFS的所有OutputFormat都继承自FileOutputFormat每一个Reducer都写一个文件到一个共同的输出目录，文件名是</p>
<p>part-nnnnn，其中nnnn是与每一个reducer相关的一个号（partition id）</p>
<p>FileOutputFormat.setOutputPath（）</p>
<p>JobConf.setOutputFormat（）</p>
<h2><span id="guan-yu-hdfs-block-he-mapreduce-split">关于HDFS block和MapReduce split</span><a href="#guan-yu-hdfs-block-he-mapreduce-split" class="header-anchor">#</a></h2><p>Block：HDFS中最小的数据存储单位，默认是164M；Split：MapReduce中最小的计算单元，默认与Block一一对应。两者的对应关系是任意的，用户可控制。</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基本命令</title>
    <url>/2020/04/08/linux_command/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#chang-yong-zhi-ling">常用指令</a></li>
<li><a href="#xi-tong-guan-li-ming-ling">系统管理命令</a></li>
<li><a href="#da-bao-ya-suo-xiang-guan-ming-ling">打包压缩相关命令</a></li>
<li><a href="#guan-ji-chong-qi-ji-qi">关机/重启机器</a></li>
<li><a href="#linux-guan-dao">Linux管道</a></li>
<li><a href="#linux-ruan-jian-bao-guan-li">Linux软件包管理</a></li>
<li><a href="#yong-hu-ji-yong-hu-zu-guan-li">用户及用户组管理</a></li>
<li><a href="#wen-jian-quan-xian-guan-li">文件权限管理</a></li>
</ul>
<!-- tocstop -->

</div>

<h2><span id="chang-yong-zhi-ling">常用指令</span><a href="#chang-yong-zhi-ling" class="header-anchor">#</a></h2><a id="more"></a>

<p>ls　　        显示文件或目录</p>
<p>  -l           列出文件详细信息l(list)</p>
<p>  -a          列出当前目录下所有文件及目录，包括隐藏的a(all)</p>
<p>mkdir         创建目录</p>
<pre><code>-p           创建目录，若无父目录，则创建p(parent)</code></pre><p>cd               切换目录</p>
<p>touch          创建空文件</p>
<p>echo            创建带有内容的文件。</p>
<p>cat              查看文件内容</p>
<p>cp                拷贝</p>
<p>mv               移动或重命名</p>
<p>rm               删除文件</p>
<p>-r            递归删除，可删除子目录及文</p>
<p>-f            强制删除</p>
<p>find              在文件系统中搜索某文件</p>
<p>wc                统计文本中行数、字数、字符数</p>
<p>grep             在文本文件中查找某个字符串</p>
<p>rmdir           删除空目录</p>
<p>tree             树形结构显示目录，需要安装tree包</p>
<p>pwd              显示当前目录</p>
<p>ln                  创建链接文件</p>
<p>more、less  分页显示文本文件内容</p>
<p>head、tail    显示文件头、尾内容</p>
<p>ctrl+alt+F1  命令行全屏模式</p>
<h2><span id="xi-tong-guan-li-ming-ling">系统管理命令</span><a href="#xi-tong-guan-li-ming-ling" class="header-anchor">#</a></h2><p>stat              显示指定文件的详细信息，比ls更详细</p>
<p>who               显示在线登陆用户</p>
<p>whoami          显示当前操作用户</p>
<p>hostname      显示主机名</p>
<p>uname           显示系统信息</p>
<p>top                动态显示当前耗费资源最多进程信息</p>
<p>ps                  显示瞬间进程状态 ps -aux</p>
<p>du                  查看目录大小 du -h /home带有单位显示目录信息</p>
<p>df                  查看磁盘大小 df -h 带有单位显示磁盘信息</p>
<p>ifconfig          查看网络情况</p>
<p>ping                测试网络连通</p>
<p>netstat          显示网络状态信息</p>
<p>man                命令不会用了，找男人  如：man ls</p>
<p>clear              清屏</p>
<p>alias               对命令重命名 如：alias showmeit=”ps -aux” ，另外解除使用unaliax showmeit</p>
<p>kill                 杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。</p>
<h2><span id="da-bao-ya-suo-xiang-guan-ming-ling">打包压缩相关命令</span><a href="#da-bao-ya-suo-xiang-guan-ming-ling" class="header-anchor">#</a></h2><p>gzip：</p>
<p>bzip2：</p>
<p>tar:                打包压缩</p>
<pre><code>-c              归档文件

-x              压缩文件

-z              gzip压缩文件

-j              bzip2压缩文件

-v              显示压缩或解压缩过程 v(view)

-f              使用档名</code></pre><p>例：</p>
<p>tar -cvf /home/abc.tar /home/abc              只打包，不压缩</p>
<p>tar -zcvf /home/abc.tar.gz /home/abc        打包，并用gzip压缩</p>
<p>tar -jcvf /home/abc.tar.bz2 /home/abc      打包，并用bzip2压缩</p>
<p>当然，如果想解压缩，就直接替换上面的命令  tar -cvf  / tar -zcvf  / tar -jcvf 中的“c” 换成“x” 就可以了。</p>
<h2><span id="guan-ji-chong-qi-ji-qi">关机/重启机器</span><a href="#guan-ji-chong-qi-ji-qi" class="header-anchor">#</a></h2><p>shutdown</p>
<pre><code>-r             关机重启

-h             关机不重启

now          立刻关机</code></pre><p>halt               关机</p>
<p>poweroff               关机</p>
<p>reboot          重启</p>
<h2><span id="linux-guan-dao">Linux管道</span><a href="#linux-guan-dao" class="header-anchor">#</a></h2><p>将一个命令的标准输出作为另一个命令的标准输入。也就是把几个命令组合起来使用，后一个命令除以前一个命令的结果。</p>
<p>例：grep -r “close” /home/* | more       在home目录下所有文件中查找，包括close的文件，并分页输出。</p>
<h2><span id="linux-ruan-jian-bao-guan-li">Linux软件包管理</span><a href="#linux-ruan-jian-bao-guan-li" class="header-anchor">#</a></h2><p>dpkg (Debian Package)管理工具，软件包名以.deb后缀。这种方法适合系统不能联网的情况下。</p>
<p>比如安装tree命令的安装包，先将tree.deb传到Linux系统中。再使用如下命令安装。</p>
<p>sudo dpkg -i tree_1.5.3-1_i386.deb         安装软件</p>
<p>sudo dpkg -r tree                                     卸载软件</p>
<p>注：将tree.deb传到Linux系统中，有多种方式。VMwareTool，使用挂载方式；使用winSCP工具等；</p>
<p>APT（Advanced Packaging Tool）高级软件工具。这种方法适合系统能够连接互联网的情况。</p>
<p>依然以tree为例</p>
<p>sudo apt-get install tree                         安装tree</p>
<p>sudo apt-get remove tree                       卸载tree</p>
<p>sudo apt-get update                                 更新软件</p>
<p>sudo apt-get upgrade        </p>
<p>将.rpm文件转为.deb文件</p>
<p>.rpm为RedHat使用的软件格式。在Ubuntu下不能直接使用，所以需要转换一下。</p>
<p>sudo alien abc.rpm</p>
<h2><span id="yong-hu-ji-yong-hu-zu-guan-li">用户及用户组管理</span><a href="#yong-hu-ji-yong-hu-zu-guan-li" class="header-anchor">#</a></h2><p>/etc/passwd    存储用户账号</p>
<p>/etc/group       存储组账号</p>
<p>/etc/shadow    存储用户账号的密码</p>
<p>/etc/gshadow  存储用户组账号的密码</p>
<p>useradd 用户名</p>
<p>userdel 用户名</p>
<p>adduser 用户名</p>
<p>groupadd 组名</p>
<p>groupdel 组名</p>
<p>passwd root     给root设置密码</p>
<p>su root</p>
<p>su - root </p>
<p>/etc/profile     系统环境变量</p>
<p>bash_profile     用户环境变量</p>
<p>.bashrc              用户环境变量</p>
<p>su user              切换用户，加载配置文件.bashrc</p>
<p>su - user            切换用户，加载配置文件/etc/profile ，加载bash_profile</p>
<p>更改文件的用户及用户组<br>sudo chown [-R] owner[:group] {File|Directory}</p>
<p>例如：还以jdk-7u21-linux-i586.tar.gz为例。属于用户hadoop，组hadoop</p>
<p>要想切换此文件所属的用户及组。可以使用命令。</p>
<p>sudo chown root:root jdk-7u21-linux-i586.tar.gz</p>
<h2><span id="wen-jian-quan-xian-guan-li">文件权限管理</span><a href="#wen-jian-quan-xian-guan-li" class="header-anchor">#</a></h2><p>三种基本权限</p>
<p>R           读         数值表示为4</p>
<p>W          写         数值表示为2</p>
<p>X           可执行  数值表示为1</p>
<p>-rw-rw-r–一共十个字符，分成四段。</p>
<p>第一个字符“-”表示普通文件；这个位置还可能会出现“l”链接；“d”表示目录</p>
<p>第二三四个字符“rw-”表示当前所属用户的权限。   所以用数值表示为4+2=6</p>
<p>第五六七个字符“rw-”表示当前所属组的权限。      所以用数值表示为4+2=6</p>
<p>第八九十个字符“r–”表示其他用户权限。              所以用数值表示为2</p>
<p>所以操作此文件的权限用数值表示为662 </p>
<p>更改权限<br>sudo chmod [u所属用户  g所属组  o其他用户  a所有用户]  [+增加权限  -减少权限]  [r  w  x]   目录名 </p>
<p>例如：有一个文件filename，权限为“-rw-r—-x” ,将权限值改为”-rwxrw-r-x”，用数值表示为765</p>
<p>sudo chmod u+x g+w o+r  filename</p>
<p>上面的例子可以用数值表示</p>
<p>sudo chmod 765 filename</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统下查询进程</title>
    <url>/2020/04/10/progress_manage/</url>
    <content><![CDATA[<h2><span id="cha-xun-jin-cheng">查询进程</span><a href="#cha-xun-jin-cheng" class="header-anchor">#</a></h2><a id="more"></a>

<div class="toc">

<!-- toc -->

<ul>
<li><a href="#ps-ming-ling-de-can-shu-xuan-xiang-ji-shuo-ming">ps命令的参数选项及说明</a></li>
<li><a href="#cha-xun-zheng-zai-yun-xing-de-jin-cheng-xin-xi">查询正在运行的进程信息</a></li>
<li><a href="#cha-xun-jin-cheng-id-gua-he-zhi-ji-de-bu-fen-jin-cheng-zi-duan">查询进程ID（适合只记得部分进程字段）</a></li>
<li><a href="#yi-wan-zheng-de-ge-shi-xian-shi-suo-you-de-jin-cheng">以完整的格式显示所有的进程</a></li>
<li><a href="#xian-shi-jin-cheng-xin-xi-bing-shi-shi-geng-xin">显示进程信息，并实时更新</a></li>
<li><a href="#lie-chu-suo-you-da-kai-de-wen-jian-lsof">列出所有打开的文件:lsof</a></li>
<li><a href="#zhong-zhi-jin-cheng">终止进程</a><ul>
<li><a href="#jin-cheng-jian-kong">进程监控</a></li>
</ul>
</li>
<li><a href="#shi-yong-ming-ling-pmap-lai-shu-chu-jin-cheng-nei-cun-de-zhuang-kuang-ke-yi-yong-lai-fen-xi-xian-cheng-dui-zhan">使用命令pmap，来输出进程内存的状况，可以用来分析线程堆栈；</a></li>
</ul>
<!-- tocstop -->

</div>

<h3><span id="ps-ming-ling-de-can-shu-xuan-xiang-ji-shuo-ming">ps命令的参数选项及说明</span><a href="#ps-ming-ling-de-can-shu-xuan-xiang-ji-shuo-ming" class="header-anchor">#</a></h3><ol>
<li>-a　　显示所有终端下执行的进程</li>
<li>a　　显示与终端相关的所有进程，包含每个进程的完整路径</li>
<li>x　　显示与终端无关的所有进程</li>
<li>u　　显示进程的用户信息</li>
<li>-u　　显示指定用户相关的进程信息</li>
<li>-e　　显示所有进程</li>
<li>-f　　 额外显示UID、PPID、C与STIME栏位</li>
<li>f　　 显示进程树</li>
<li>-H　　显示进程树</li>
<li>-l　　 以详细的格式来显示进程的状况</li>
<li>-o　　自定义输出指定的字段，以退号分隔</li>
<li>-sot key key表示为指定字段排序，默认升序，+key升序，key降序</li>
</ol>
<h3><span id="cha-xun-zheng-zai-yun-xing-de-jin-cheng-xin-xi">查询正在运行的进程信息</span><a href="#cha-xun-zheng-zai-yun-xing-de-jin-cheng-xin-xi" class="header-anchor">#</a></h3><p>ps -ef</p>
<p>输出信息中各列的说明如下。  </p>
<ol>
<li>UID：进程被该UID所拥有。  </li>
<li>PID：进程的标识号。  </li>
<li>PPID：进程的父进程的标识号。  </li>
<li>C:CPU使用的资源百分比。</li>
<li>STIME：进程开始的时间。</li>
<li>TTY：该进程是在哪个终端机上面运作，若与终端机无关，则显示“？”，另外，ttyl-tty6是本机上面的登入者进程，若为pts/0等，则表示为由网络连接进主机的进程。</li>
<li>TIME：进程所使用的总的CPU时间。</li>
<li>CMD：正在执行的命令行。</li>
</ol>
<p>eg:查询归属于用户colin115的进程</p>
<p>ps -ef | grep colin115</p>
<p>ps -lu colin115</p>
<h3><span id="cha-xun-jin-cheng-id-gua-he-zhi-ji-de-bu-fen-jin-cheng-zi-duan">查询进程ID（适合只记得部分进程字段）</span><a href="#cha-xun-jin-cheng-id-gua-he-zhi-ji-de-bu-fen-jin-cheng-zi-duan" class="header-anchor">#</a></h3><p>pgrep 查找进程</p>
<p>eg:查询进程名中含有re的进程<br>pgrep -l re</p>
<h3><span id="yi-wan-zheng-de-ge-shi-xian-shi-suo-you-de-jin-cheng">以完整的格式显示所有的进程</span><a href="#yi-wan-zheng-de-ge-shi-xian-shi-suo-you-de-jin-cheng" class="header-anchor">#</a></h3><blockquote>
<p>ps -ajx</p>
</blockquote>
<h3><span id="xian-shi-jin-cheng-xin-xi-bing-shi-shi-geng-xin">显示进程信息，并实时更新</span><a href="#xian-shi-jin-cheng-xin-xi-bing-shi-shi-geng-xin" class="header-anchor">#</a></h3><blockquote>
<p>top</p>
</blockquote>
<h3><span id="lie-chu-suo-you-da-kai-de-wen-jian-lsof">列出所有打开的文件:lsof</span><a href="#lie-chu-suo-you-da-kai-de-wen-jian-lsof" class="header-anchor">#</a></h3><p>查看端口占用的进程状态：</p>
<blockquote>
<p>lsof -i:3306</p>
</blockquote>
<p>查看谁正在使用某个文件</p>
<p>lsof   /filepath/file</p>
<p>通过某个进程号显示该进程打开的文件</p>
<p>lsof -p 1</p>
<p>列出所有的网络连接</p>
<p>lsof -i</p>
<p>列出谁在使用某个特定的udp端口</p>
<p>lsof -i udp:55</p>
<p>特定的tcp端口</p>
<p>lsof -i tcp:80</p>
<p>查看用户username的进程所打开的文件</p>
<p>$lsof -u username</p>
<p>查询init进程当前打开的文件</p>
<p>$lsof -c init</p>
<p>查询指定目录下被进程开启的文件（使用+D 递归目录）：</p>
<p>$lsof +d mydir1/</p>
<h3><span id="zhong-zhi-jin-cheng">终止进程</span><a href="#zhong-zhi-jin-cheng" class="header-anchor">#</a></h3><p>杀死指定PID的进程 (PID为Process ID)</p>
<blockquote>
<p>kill PID</p>
</blockquote>
<p>杀死相关进程</p>
<p>kill -9 3434</p>
<p> [ctrl]+z         將前台任务丟到后台中暂停<br> jobs 查看后台的工作状态<br> fg %jobnumber           将后台的任务拿到前台来处理<br> bg %jobnumber         将任务放到后台中去处理  </p>
<p>杀死job工作 (job为job number,jobs命令查看)</p>
<p>$kill %job</p>
<h2><span id="jin-cheng-jian-kong">进程监控</span><a href="#jin-cheng-jian-kong" class="header-anchor">#</a></h2><p>输入top命令后，进入到交互界面；接着输入字符命令后显示相应的进程状态：</p>
<p>对于进程，平时我们最常想知道的就是哪些进程占用CPU最多，占用内存最多。以下两个命令就可以满足要求:</p>
<p>P：根据CPU使用百分比大小进行排序。<br>M：根据驻留内存大小进行排序。<br>i：使top不显示任何闲置或者僵死进程。  </p>
<h3><span id="shi-yong-ming-ling-pmap-lai-shu-chu-jin-cheng-nei-cun-de-zhuang-kuang-ke-yi-yong-lai-fen-xi-xian-cheng-dui-zhan">使用命令pmap，来输出进程内存的状况，可以用来分析线程堆栈；</span><a href="#shi-yong-ming-ling-pmap-lai-shu-chu-jin-cheng-nei-cun-de-zhuang-kuang-ke-yi-yong-lai-fen-xi-xian-cheng-dui-zhan" class="header-anchor">#</a></h3><blockquote>
<p>pamp PID</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vim使用</title>
    <url>/2020/04/08/vim/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#vim-dao-hang-ji-chu">vim导航基础</a><ul>
<li><a href="#zai-wen-ben-zhong-cha-zhao">在文本中查找</a><ul>
<li><a href="#que-ren-ti-huan">确认替换</a></li>
</ul>
</li>
<li><a href="#an-ci-yi-dong">按词移动</a></li>
<li><a href="#dan-ci-kuai-su-pi-pei">单词快速匹配</a></li>
<li><a href="#duan-luo-yi-dong">段落移动</a></li>
<li><a href="#tiao-dao-zi-fu-chu">跳到字符处</a></li>
<li><a href="#yi-dong-de-qi-ta-ming-ling">移动的其它命令</a></li>
</ul>
</li>
<li><a href="#mo-shi">模式</a><ul>
<li><a href="#ti-huan">替换</a></li>
<li><a href="#ba-ming-ling-de-jie-guo-du-ru-vim">把命令的结果读入 Vim</a></li>
<li><a href="#ba-wai-bu-wen-jian-du-ru-vim">把外部文件读入 Vim</a></li>
</ul>
</li>
<li><a href="#vim-de-yu-fa">Vim 的 ‘语法’</a><ul>
<li><a href="#dong-ci">‘动词’</a></li>
</ul>
</li>
<li><a href="#fen-ping-ming-ling">分屏命令</a><ul>
<li><a href="#1-qie-huan-fen-ping-chuang-kou">1) 切换分屏窗口</a></li>
<li><a href="#2-diao-zheng-chuang-kou-da-xiao">2) 调整窗口大小</a></li>
</ul>
</li>
<li><a href="#yi-xie-kuai-jie-jian-he-ji-qiao">一些快捷键和技巧</a></li>
<li><a href="#pei-zhi-vimrc">配置 ~/.vimrc</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h2><span id="vim-dao-hang-ji-chu">vim导航基础</span><a href="#vim-dao-hang-ji-chu" class="header-anchor">#</a></h2><p>在vim中打开filename<br>vim filename<br> :e .      会打开内置的文件浏览器，浏览要当前目录下的文件 </p>
<p> :n 文件名         新建文件 </p>
<p>退出vim<br>:q</p>
<p>保存当前文件<br>:w</p>
<p>退出 Vim 并且不保存文件,!表示强制执行<br>:q!</p>
<p>保存文件并且退出 Vim<br>:wq<br>:x</p>
<p>撤销<br>u</p>
<p>U 撤销当前行的所有修改<br>返回撤销<br>CTRL+R</p>
<p>左移一个字符<br>h<br>下移一行<br>j<br>上移一行<br>k<br>右移一个字符<br>l</p>
<p>移到行首<br>0<br>移到行尾<br>$<br>移到行内的第一个非空白字符处<br>^  </p>
<h3><span id="zai-wen-ben-zhong-cha-zhao">在文本中查找</span><a href="#zai-wen-ben-zhong-cha-zhao" class="header-anchor">#</a></h3><p>光标之后的所有该词都高亮显示<br>/word</p>
<p>光标之前的所有该词都高亮显示<br>?word</p>
<p>查找后将光标移到该词的下一个出现位置<br>n</p>
<p>光标移到该词的上一个出现位置<br>N</p>
<p>将文件每一行上的所有 ‘foo’ 都改成 ‘bar’<br>:%s/foo/bar/g</p>
<p>将当前行上的所有 ‘foo’ 都改成 ‘bar’<br>：s/foo/bar/g </p>
<h4><span id="que-ren-ti-huan">确认替换</span><a href="#que-ren-ti-huan" class="header-anchor">#</a></h4><p>如果把末尾的 g 改成 gc 在替换的时候，会有提示！推荐使用！<br>:%s/旧文本/新文本/gc<br>y - yes 替换<br>n - no 不替换<br>a - all 替换所有<br>q - quit 退出替换<br>l - last 最后一个，并把光标移动到行首<br>^E 向下滚屏<br>^Y 向上滚屏</p>
<h3><span id="an-ci-yi-dong">按词移动</span><a href="#an-ci-yi-dong" class="header-anchor">#</a></h3><p> 默认一个单词由字母，数字和下划线组成</p>
<pre><code>w                # 移动到下一个词首
b                # 移动到前一个词首
e                # 移动到下一个词尾</code></pre><h3><span id="dan-ci-kuai-su-pi-pei">单词快速匹配</span><a href="#dan-ci-kuai-su-pi-pei" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*</td>
<td>向后查找当前光标所在单词</td>
</tr>
<tr>
<td align="center">#</td>
<td>向前查找当前光标所在单词</td>
</tr>
<tr>
<td align="center">### 段落移动</td>
<td></td>
</tr>
<tr>
<td align="center">* <code>vi</code> 中使用 空行 来区分段落</td>
<td></td>
</tr>
<tr>
<td align="center">* 在程序开发时，通常 <strong>一段功能相关的代码会写在一起</strong> —— 之间没有空行</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">{</td>
<td>上一段</td>
</tr>
<tr>
<td align="center">}</td>
<td>下一段</td>
</tr>
<tr>
<td align="center">### 跳到字符处</td>
<td></td>
</tr>
</tbody></table>
<pre><code>fx 向右跳到本行字符x处（x可以是任何字符）
Fx 向左跳到本行字符x处（x可以是任何字符）
tx 和fx相同，区别是跳到字符x前
Tx 和Fx相同，区别是跳到字符x后</code></pre><h3><span id="yi-dong-de-qi-ta-ming-ling">移动的其它命令</span><a href="#yi-dong-de-qi-ta-ming-ling" class="header-anchor">#</a></h3><pre><code>gg               # 移到文件顶部
G                # 移到文件末尾
:NUM             # 移到第 NUM 行 (NUM 是任意数字)
H                # 移到屏幕顶部
M                # 移到屏幕中间位置
L                # 移到屏幕末尾
+              #移到下一行的行首
-              #移到上一行的行首
%               跳到相对应的括号上，编程时常用如30%
&quot;H&quot;意为Home, &quot;M&quot;为Middle, &quot;L&quot;为Last.  当前屏幕的上中下位置
&apos;               移动到上一次的修改行</code></pre><h2><span id="mo-shi">模式</span><a href="#mo-shi" class="header-anchor">#</a></h2><p>命令模式 - Vim 启动后就处于这个模式，用于导航和操作命令 插入模式 - 用于在你的文件中进行修改 可视模式 - 用于高亮文本并对它们进行操作 Ex 模式 - 用于跳到底部的 ‘:’ 提示行上输入命令<br><img src="https://img-blog.csdnimg.cn/20200401231529455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<pre><code>i                # 在光标位置前，将 Vim 切换到插入模式
a                # 在光标位置后，将 Vim
A                #在行末插入切换到插入模式
o:              #在当前行的下面另起一行，并变为插入模式
O：              #在当前行上面另起一行，变为插入模式
v                # 将 Vim 切换到可视模式  
   V                 选中光标经过的完整行 
Ctrl + v              垂直方向选中文本 
:                # 将 Vim 切换到 ex 模式
&lt;esc&gt;            # 无论你当前处于什么模式，都返回到命令模式
：e!            放弃更改，然后相当于重新打开
：help           帮助，可用ZZ退出帮助窗口

# 复制和粘贴文本
y                # 复制所选的内容
yy               # 复制当前行
d                # 删除所选的内容,剪切
dd               # 删除当前行，5dd ：删除当前行开始的5行； 
dG              #(先输入d，然后按 shift 键输入g)删除当前行至最后一行的所以行。
D                #删除到行尾
p                # 在当前光标位置后粘贴复制的文本
P                # 在当前光标位置前粘贴复制的文本
x                # 删除当前光标位置处的字符, 删除3个字符就是3x 

vim中Nyy可以复制光标后的N行。有时我们不容易得出行数，这时可以用做标记的方法来制定复制范围：

1. 在开始行上输入ma作一个标记
2. 移动到结束行，输入y&apos;a会复制当前行到标记a之间的文本。d&apos;a会删除。或者是v进入可视模式，再13G跳转到相应行，y即可。
:10,20y    回车即可，相应的删除也是如此     :10,20d     （此方法比上面两种方法更简单）
:10,20 m 30    把10行到20行的内容，剪切到30行之后
:10,20 co 30   把10行到20行的内容，复制到30行之后
将光标放在 { 处，然后输入v%就可以把大括号中内容选定
%: 移动到与制匹配的括号上去（），{}，[]，&lt;&gt;等。将光标放在 { 处，然后输入v%就可以把大括号中内容选定</code></pre><h3><span id="ti-huan">替换</span><a href="#ti-huan" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
<th>工作模式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">r</td>
<td align="center">replace</td>
<td>替换当前字符</td>
<td>命令模式</td>
</tr>
<tr>
<td align="center">R</td>
<td align="center">replace</td>
<td>替换当前行光标后的字符</td>
<td>替换模式</td>
</tr>
<tr>
<td align="center">* <code>R</code> 命令可以进入 <strong>替换模式</strong>，替换完成后，按下 <code>ESC</code> 可以回到 <strong>命令模式</strong></td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">* <strong>替换命令</strong> 的作用就是不用进入 <strong>编辑模式</strong>，对文件进行 <strong>轻量级的修改</strong></td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center">### 把命令的结果读入 Vim</td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>有时候你需要把某个命令的结果复制到 Vim 中，这在 Vim 也非常简单。切换到正常模式，然后输入 :read !command 即可把 command 的结果输入到 vim 中。</p>
<pre><code>:read !ls -l</code></pre><h3><span id="ba-wai-bu-wen-jian-du-ru-vim">把外部文件读入 Vim</span><a href="#ba-wai-bu-wen-jian-du-ru-vim" class="header-anchor">#</a></h3><p>我开始使用 Vim 的时候，经常会打开一个文件、复制内容、关闭文件、打开另一个文件、然后粘贴进去复制到内容。其实Vim中读取另一个文件的内容非常方便。切换到正常模式，然后按:read。使用此快捷键你不需要手动打开文件来复制内容。</p>
<pre><code>:read readme.md</code></pre><h2><span id="vim-de-yu-fa">Vim 的 ‘语法’</span><a href="#vim-de-yu-fa" class="header-anchor">#</a></h2><p>Vim 可以被认为是按 ‘动词-修饰词-名词’ 格式编排的一组命令：</p>
<p>动词 - 你的动作 修饰词 - 你如何执行你的动作 名词 - 你的动作所作用于的对象</p>
<h1><span id="dong-ci">‘动词’</span><a href="#dong-ci" class="header-anchor">#</a></h1><pre><code>d                # 删除
c                # 修改
y                # 复制
v                # 可视化选择

# &apos;修饰词&apos;

i                # 内部的
a                # 周围的
NUM              # 数字 (NUM 是任意数字)
f                # 查找文本并位于其上
t                # 查找文本并停于其前面
/                # 从光标处开始查找字符串
?                # 在光标前查找字符串

# &apos;名词&apos;

w                # 词
s                # 句子
p                # 段落
b                # 块

# 示例 &apos;语句&apos; 或命令

d2w              # 删除 2 个词
cis              # 修改段落内的内容
yip              # 复制段落内的内容 (复制你所在的段落)
ct&lt;              # 修改直到括号开启处
                 # 对你的当前位置直到下个括号开启处的内容进行修改
d$               # 删除直到行尾
如果光标放在第一个s上，想删除到“(”为止，则输入dt(就可以了，t(的作用是跳到下一个&quot;(&quot;前。
ctrl +n 自动补全 ctrl + p 也一样</code></pre><h2><span id="fen-ping-ming-ling">分屏命令</span><a href="#fen-ping-ming-ling" class="header-anchor">#</a></h2><ul>
<li>使用 <strong>分屏命令</strong>，可以 <strong>同时编辑和查看多个文件</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:sp [文件名]</td>
<td align="center">split</td>
<td>横向增加分屏</td>
</tr>
<tr>
<td align="center">:vsp [文件名]</td>
<td align="center">vertical split</td>
<td>纵向增加分屏</td>
</tr>
</tbody></table>
<h4><span id="1-qie-huan-fen-ping-chuang-kou">1) 切换分屏窗口</span><a href="#1-qie-huan-fen-ping-chuang-kou" class="header-anchor">#</a></h4><blockquote>
<p>分屏窗口都是基于 <code>CTRL + W</code> 这个快捷键的，<code>w</code> 对应的英文单词是 <code>window</code></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">w</td>
<td align="center">window</td>
<td>切换到下一个窗口</td>
</tr>
<tr>
<td align="center">r</td>
<td align="center">reverse</td>
<td>互换窗口</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">close</td>
<td>关闭当前窗口，但是不能关闭最后一个窗口</td>
</tr>
<tr>
<td align="center">q</td>
<td align="center">quit</td>
<td>退出当前窗口，如果是最后一个窗口，则关闭 vi</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">other</td>
<td>关闭其他窗口</td>
</tr>
</tbody></table>
<h4><span id="2-diao-zheng-chuang-kou-da-xiao">2) 调整窗口大小</span><a href="#2-diao-zheng-chuang-kou-da-xiao" class="header-anchor">#</a></h4><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">英文</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center"></td>
<td>增加窗口高度</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center"></td>
<td>减少窗口高度</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center"></td>
<td>增加窗口宽度</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center"></td>
<td>减少窗口宽度</td>
</tr>
<tr>
<td align="center">=</td>
<td align="center"></td>
<td>等分窗口大小</td>
</tr>
</tbody></table>
<blockquote>
<p>调整窗口宽高的命令可以和数字连用，例如：<code>5 CTRL + W +</code> 连续 5 次增加高度</p>
</blockquote>
<h2><span id="yi-xie-kuai-jie-jian-he-ji-qiao">一些快捷键和技巧</span><a href="#yi-xie-kuai-jie-jian-he-ji-qiao" class="header-anchor">#</a></h2><pre><code>&lt;!--TODO: Add more!--&gt;
&gt;                # 将所选内容缩进一级
&lt;                # 将所选内容取消缩进一级
:earlier 15m     # 将文档还原到 15 分钟前的状态
:later 15m       # 逆转上述命令
ddp              # 相邻行交换位置，先 dd 再 p
.                # 重复之前动作</code></pre><h2><span id="pei-zhi-vimrc">配置 ~/.vimrc</span><a href="#pei-zhi-vimrc" class="header-anchor">#</a></h2><p>.vimrc 可用于在启动时对 Vim 进行配置。在vimrc中，双引号开头的行，将被当作注释忽略。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot; 根据文件名检测文件类型，以便能进行智能自动缩进等操作。</span><br><span class="line">filetype indent plugin on</span><br><span class="line"></span><br><span class="line">&quot; 开启语法高亮</span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line">&quot; 更好的命令行补全</span><br><span class="line">set wildmenu</span><br><span class="line"></span><br><span class="line">&quot; 除了当使用大写字母时使用大小写无关查找</span><br><span class="line">set ignorecase</span><br><span class="line">set smartcase</span><br><span class="line"></span><br><span class="line">&quot; 当新开一行时，如果没有开启文件特定的缩进规则，</span><br><span class="line">&quot; 则缩进保持与你当前行一致</span><br><span class="line">set autoindent</span><br><span class="line"></span><br><span class="line">&quot; 在左侧显示行号</span><br><span class="line">set number</span><br><span class="line"></span><br><span class="line">&quot; 缩进选项，根据个人偏好进行修改</span><br><span class="line"></span><br><span class="line">&quot; 每个 TAB 的可视空格数</span><br><span class="line">set tabstop&#x3D;4</span><br><span class="line"></span><br><span class="line">&quot; 编辑时 TAB 对应的空格数</span><br><span class="line">set softtabstop&#x3D;4</span><br><span class="line"></span><br><span class="line">&quot; 当使用缩进操作 (&gt;&gt; 和 &lt;&lt;) 时缩进的空格数</span><br><span class="line">set shiftwidth&#x3D;4</span><br><span class="line"></span><br><span class="line">&quot; 将 TAB 转换成空格</span><br><span class="line">set expandtab</span><br><span class="line"></span><br><span class="line">&quot; 为缩进和对齐开启智能化的 TAB 和空格切换功能</span><br><span class="line">set smarttab</span><br></pre></td></tr></table></figure>
<p>常用命令速查图<br><img src="https://img-blog.csdnimg.cn/20200401234008806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法分析</title>
    <url>/2020/04/15/sort/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#pai-xu">排序</a><ul>
<li><a href="#fen-xi-ce-shi">分析测试</a></li>
<li><a href="#dai-ma-ru-xia">代码如下：</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="pai-xu">排序</span><a href="#pai-xu" class="header-anchor">#</a></h1><p>算法的时间复杂度主要取决与比较和交换的次数。空间复杂度看是否需要额外的内存空间存储数组的副本。  </p>
<a id="more"></a>

<ol>
<li><p><strong>冒泡排序法</strong><br>比较相邻的元素。如果第一个比第二个大，就交换他们两个，依次类推。最好时间复杂度O(n)，平均时间复杂度O(n²)。空间复杂度O(1)。<br><img src="https://img-blog.csdnimg.cn/20200415114009703.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
</li>
<li><p><strong>选择排序法</strong><br>在数组中找出最小的元素，与第一个元素交换位置，依次类推。<br>比较的次数为你n*(n-1)/2,交换的次数为n-1。时间复杂度O(n²)，空间复杂度O(1)。   <img src="https://img-blog.csdnimg.cn/20200415114134152.jpg" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>插入排序法</strong><br>将数插入到左侧已有序的数组中，将其余元素右移。插入排序所需时间取决于输入元素的初始位置。对于大规模乱序数组插入排序很慢。因为只交换相邻的元素。<br>最好情况：交换0次，比较n-1次。<br>平均情况：交换n<em>(n-1)/4次,比较n</em>(n-1)/4次。<br>最坏情况：交换n<em>(n-1)/2次,比较n</em>(n-1)/2次。<br>时间复杂度O(n²)，空间复杂度O(1)<br>插入排序的交换操作和数组倒置的数量相同，需要比较次数大于数组倒置的数量，小于倒置的数量加数组的大小。插入排序不会访问索引右侧的元素，选择排序不会访问元素左侧的元素。<br><img src="https://img-blog.csdnimg.cn/20200415114044457.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt><br>对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间市平方级别的，二者之比为一个较小的常数。  </p>
</li>
<li><p><strong>希尔排序</strong><br>基于插入排序的一种快速的排序算法，即分组插入排序。先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量  =1(  &lt;  …&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。一般适用于中小规模的数据量。希尔算法在最坏的情况下和平均情况下执行效率相差不是很大。优化的是使d=1时，比较次数接近n。<br>使用不同的增量对希尔排序的时间复杂度的改进将不一样<br>(1) 希尔增量序列:初次取序列的一半为增量，以后每次减半，直到增量为1。最坏情况时间复杂度为O(n²)，空间复杂度O(1)。<br>(2) Knuth增量序列:hi=3^i−1,递推公式：h1=1,hi=3∗h(i−1)+1。一般都用这个序列.最坏时间复杂度为 Θ(N^(3/2))<br><img src="https://img-blog.csdnimg.cn/20200415114214869.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>归并排序</strong><br>递归法（Top-down）<br>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>重复步骤3直到某一指针到达序列尾<br>将另一序列剩下的所有元素直接复制到合并序列尾<br>时间复杂为nlogn<br>空间复杂度为n<br><img src="https://img-blog.csdnimg.cn/20200415114245703.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt><br><img src="https://img-blog.csdnimg.cn/20200415114308895.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>快排算法</strong>（挖坑(基准数)填数，分治思想）<br>先从数列中取出一个数作为基准数。将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。再对左右区间重复第二步，直到各区间只有一个数。<br>时间复杂为nlogn<br><img src="https://img-blog.csdnimg.cn/20200415114339407.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ol>
<p>7.<strong>堆排序算法</strong></p>
<p>用数组结构存储，逻辑结构为完全二叉树，先做成大根堆或小根堆，第一个数即为最大或最小，在将第一个数与最后一个数交换位置，在把第一个数通过上浮或下沉操作移动到顺序位置。<br>一棵大小为N完全二叉树高度为lgn</p>
<p>对于一个含有N个元素的基于堆的优先队列，插入元素操作只需不超过lgN+1次比较，删除最大元素操作需要不超过2lgN次比较。<br>构造堆时下沉操作需要小于2N次比较以及小于N次交换。<br>要构造一个元素大小为28的堆，会处理1个大小为28的堆，两个大小为14的堆，4个大小为7的堆，8个大小为3的堆。8<em>1+4</em>2+2<em>3+1</em>5=27。27&lt;N。又因在堆中最坏情况比较次数D(N)为两个子结点的一次比较，和堆顶点与两个子结点中大者进行比较，所以最坏情况下比较次数为2倍交换次数，D(N)=2C(N)&lt;2N。<br>将N个元素排序，堆排序只需小于2NlgN+2N次比较，及N/2次交换。2N来自于堆的构造，2NlgN来自每次下沉操作的比较。<br><img src="https://img-blog.csdnimg.cn/20200415114419872.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt><br>时间复杂为nlogn<br>空间复杂度为1</p>
<h2><span id="fen-xi-ce-shi">分析测试</span><a href="#fen-xi-ce-shi" class="header-anchor">#</a></h2><p>排序算法复杂度分析如图  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZTk2N2ZiNGMyYTlhODNiZTU2NGNhZGQuanBn?x-oss-process=image/format,png" alt></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMuZG93bmsuY2MvaXRlbS81ZTk2N2ZiNGMyYTlhODNiZTU2NGNhY2MuanBn?x-oss-process=image/format,png" alt><br><img src="https://img-blog.csdnimg.cn/20200415114926777.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>每种排序方法需要时间如图：<br><img src="https://img-blog.csdnimg.cn/20200415115012459.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2><span id="dai-ma-ru-xia">代码如下：</span><a href="#dai-ma-ru-xia" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void bubble_sort(int *p, int n)</span><br><span class="line">&#123;</span><br><span class="line">	int temp, i, j, k;</span><br><span class="line">	for (i &#x3D; 0; i &lt; n - 1; i++)&#x2F;&#x2F;选择出最大的数放后面</span><br><span class="line">	&#123;</span><br><span class="line">		for (j &#x3D; 0; j &lt; n - i - 1; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (p[j] &gt; p[j + 1])</span><br><span class="line">			&#123;</span><br><span class="line">				temp &#x3D; p[j];</span><br><span class="line">				p[j] &#x3D; p[j + 1];</span><br><span class="line">				p[j + 1] &#x3D; temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void selection_sort(int *p, int n)</span><br><span class="line">&#123;</span><br><span class="line">	int i, j, k, temp;</span><br><span class="line">	for (i &#x3D; 0; i &lt; n - 1; i++)&#x2F;&#x2F;选择出最小的数</span><br><span class="line">	&#123;</span><br><span class="line">		k &#x3D; i;&#x2F;&#x2F;第k个为最小元素</span><br><span class="line">		for (j &#x3D; i + 1; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			if (p[k] &gt; p[j])</span><br><span class="line">				k &#x3D; j;</span><br><span class="line">		&#125;</span><br><span class="line">		if (i !&#x3D; k)</span><br><span class="line">		&#123;</span><br><span class="line">			temp &#x3D; p[k];</span><br><span class="line">			p[k] &#x3D; p[i];</span><br><span class="line">			p[i] &#x3D; temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void insertion_sort(int *p, int n)</span><br><span class="line">&#123;</span><br><span class="line">	int i, j, temp;</span><br><span class="line">	for (i &#x3D; 1; i &lt; n; i++)&#x2F;&#x2F;i前面为有序</span><br><span class="line">		for (j &#x3D; i; j &gt; 0; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			if (p[j - 1] &gt; p[j])&#x2F;&#x2F;与前一个元素比较交换，最后到达在序中位置，相当与插入到该位置</span><br><span class="line">			&#123;</span><br><span class="line">				temp &#x3D; p[j];</span><br><span class="line">				p[j] &#x3D; p[j - 1];</span><br><span class="line">				p[j - 1] &#x3D; temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;void shell_sort1(int *p,int n)&#x2F;&#x2F;希尔增量</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">&#x2F;&#x2F;	int temp, i, j,h;</span><br><span class="line">&#x2F;&#x2F;	for (h &#x3D; n &#x2F; 2; h &gt;&#x3D;1; h &#x3D; h &#x2F; 2)&#x2F;&#x2F;控制增量</span><br><span class="line">&#x2F;&#x2F;	&#123;</span><br><span class="line">&#x2F;&#x2F;		for (i &#x3D; h; i &lt; n; i++)</span><br><span class="line">&#x2F;&#x2F;		&#123;</span><br><span class="line">&#x2F;&#x2F;			for (j &#x3D; i - h; j &gt;&#x3D; 0 &amp;&amp; p[j] &gt; p[j + h]; j -&#x3D; h)</span><br><span class="line">&#x2F;&#x2F;			&#123;</span><br><span class="line">&#x2F;&#x2F;				temp &#x3D; p[j];</span><br><span class="line">&#x2F;&#x2F;				p[j] &#x3D; p[j + h];</span><br><span class="line">&#x2F;&#x2F;				p[j + h] &#x3D; temp;</span><br><span class="line">&#x2F;&#x2F;			&#125;</span><br><span class="line">&#x2F;&#x2F;		&#125;</span><br><span class="line">&#x2F;&#x2F;	&#125;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line">void shell_sort2(int *p, int n)&#x2F;&#x2F; Knuth增量</span><br><span class="line">&#123;</span><br><span class="line">	int temp, h &#x3D; 1, i, j;</span><br><span class="line">	while (h &lt; n &#x2F; 3)</span><br><span class="line">		h &#x3D; 3 * h + 1;&#x2F;&#x2F;1，4，13，40……</span><br><span class="line">	while (h &gt;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		for (i &#x3D; h; i &lt; n; i++)&#x2F;&#x2F;将a[i]插入到a[i-j],a[i-2*j]……中</span><br><span class="line">		&#123;</span><br><span class="line">			for (j &#x3D; i; j &gt;&#x3D; h &amp;&amp; p[j] &lt; p[j - h]; j -&#x3D; h)</span><br><span class="line">			&#123;</span><br><span class="line">				temp &#x3D; p[j];</span><br><span class="line">				p[j] &#x3D; p[j - h];</span><br><span class="line">				p[j - h] &#x3D; temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		h &#x3D; h &#x2F; 3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void mergearray(int a[], int first, int mid, int last, int temp[])</span><br><span class="line">&#123;</span><br><span class="line">	int i &#x3D; first, m &#x3D; mid;</span><br><span class="line">	int j &#x3D; mid + 1, n &#x3D; last;</span><br><span class="line">	int k &#x3D; 0;</span><br><span class="line">	while (i &lt;&#x3D; m &amp;&amp; j &lt;&#x3D; n)&#x2F;&#x2F;前一半与后一半比较，输入小的到辅助数组temp[]中</span><br><span class="line">	&#123;</span><br><span class="line">		if (a[i] &lt;&#x3D; a[j])</span><br><span class="line">			temp[k++] &#x3D; a[i++];</span><br><span class="line">		else</span><br><span class="line">			temp[k++] &#x3D; a[j++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while (i &lt;&#x3D; m)&#x2F;&#x2F;将剩下的没有比较的继续插到后面</span><br><span class="line">		temp[k++] &#x3D; a[i++];</span><br><span class="line"></span><br><span class="line">	while (j &lt;&#x3D; n)</span><br><span class="line">		temp[k++] &#x3D; a[j++];</span><br><span class="line"></span><br><span class="line">	for (i &#x3D; 0; i &lt; k; i++)</span><br><span class="line">		a[first + i] &#x3D; temp[i];</span><br><span class="line">&#125;</span><br><span class="line">void mergesort(int p[], int first, int last, int temp[])</span><br><span class="line">&#123;</span><br><span class="line">	if (first &lt; last)</span><br><span class="line">	&#123;</span><br><span class="line">		int mid &#x3D; (first + last) &#x2F; 2;</span><br><span class="line">		mergesort(p, first, mid, temp);    &#x2F;&#x2F;左边有序</span><br><span class="line">		mergesort(p, mid + 1, last, temp); &#x2F;&#x2F;右边有序</span><br><span class="line">		mergearray(p, first, mid, last, temp); &#x2F;&#x2F;再将二个有序数列合并</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void quick_sort(int *p, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">	int i, j, temp;&#x2F;&#x2F;temp保存基准数</span><br><span class="line">	if (left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		i &#x3D; left; j &#x3D; right;</span><br><span class="line">		temp &#x3D; p[left];</span><br><span class="line">		while (i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			while (p[j] &gt;&#x3D; temp &amp;&amp; i &lt; j)&#x2F;&#x2F;先找右边</span><br><span class="line">				j--;</span><br><span class="line">			if (i &lt; j)</span><br><span class="line">				p[i++] &#x3D; p[j];</span><br><span class="line">			while (p[i] &lt;&#x3D; temp &amp;&amp; i &lt; j)&#x2F;&#x2F;再找左边</span><br><span class="line">				i++;</span><br><span class="line">			if (i &lt; j)</span><br><span class="line">				p[j--] &#x3D; p[i];</span><br><span class="line">			p[i] &#x3D; temp;&#x2F;&#x2F;将基准数归位</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		quick_sort(p, left, i - 1);</span><br><span class="line">		quick_sort(p, i + 1, right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	srand(unsigned(time(NULL)));</span><br><span class="line">	int n,x;</span><br><span class="line">	cout &lt;&lt; &quot;请输入元素的个数:&quot;;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	cout &lt;&lt; &quot;选择方法\n1.冒泡排序\n2.选择排序\n3.插入排序\n4.希尔排序\n5.归并排序\n6.快速排序\n&quot;;</span><br><span class="line">	cin &gt;&gt; x;</span><br><span class="line">	int *p &#x3D; new int[n];</span><br><span class="line">	int *a &#x3D; new int[n];</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p[i] &#x3D; rand();</span><br><span class="line">	&#125;</span><br><span class="line">	if (p &#x3D;&#x3D; NULL)</span><br><span class="line">		return false;</span><br><span class="line">	switch (x)</span><br><span class="line">	&#123;</span><br><span class="line">	case(1):bubble_sort(p,n); break;</span><br><span class="line">	case(2):selection_sort(p, n); break;</span><br><span class="line">	case(3):insertion_sort(p, n); break;</span><br><span class="line">	case(4):shell_sort2(p, n); break;</span><br><span class="line">	case(5):mergesort(p, 0, n - 1, a); break;</span><br><span class="line">	case(6):quick_sort(p, 0, n - 1); break;</span><br><span class="line">	default:</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; p[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	delete[] p;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>十分钟学会CSS基础使用</title>
    <url>/2020/08/01/%E5%8D%81%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9ACSS%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#gai-nian">概念</a></li>
<li><a href="#shi-yong">使用</a><ul>
<li><a href="#yu-html-san-chong-jie-he-fang-shi">与HTML三种结合方式</a></li>
<li><a href="#ji-ben-xuan-ze-qi">基本选择器</a></li>
<li><a href="#kuo-zhan-xuan-ze-qi">扩展选择器</a></li>
<li><a href="#chang-yong-de-shu-xing">常用的属性</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h2><span id="gai-nian">概念</span><a href="#gai-nian" class="header-anchor">#</a></h2><p>css : cascading  style  sheet  层叠 样式 表 ：修饰网页，布局和美化<br>好处：</p>
<ul>
<li>美化网页，样式更多更强大 </li>
<li>提高效率  <h2><span id="shi-yong">使用</span><a href="#shi-yong" class="header-anchor">#</a></h2><h3><span id="yu-html-san-chong-jie-he-fang-shi">与HTML三种结合方式</span><a href="#yu-html-san-chong-jie-he-fang-shi" class="header-anchor">#</a></h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.内联样式 ：在元素上使用style属性</span><br><span class="line">    &lt;div style&#x3D;&quot;color:red;&quot;&gt;</span><br><span class="line">    	hello world</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">2.内部样式：在head标签中，使用style标签</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        div&#123;</span><br><span class="line">        	color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">    </span><br><span class="line">3.外部样式：定义css文件，在head标签中使用link标签引入css文件</span><br><span class="line">	&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;..&#x2F;css&#x2F;a.css&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">三种结合方式的优先级：</span><br><span class="line">	*内联样式最高 </span><br><span class="line">	*内部和外部没有明显的优先级，取决于谁后加载</span><br></pre></td></tr></table></figure>
<h3><span id="ji-ben-xuan-ze-qi">基本选择器</span><a href="#ji-ben-xuan-ze-qi" class="header-anchor">#</a></h3><ol>
<li>id选择器     #id值{样式属性列表}<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &lt;style&gt;</span><br><span class="line">       #zsf&#123;</span><br><span class="line">           color: yellow;</span><br><span class="line">       &#125;</span><br><span class="line">   &lt;&#x2F;style&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">   &lt;li id&#x3D;&quot;zsf&quot;&gt;张三丰&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure></li>
<li>class选择器  .class值{样式属性列表}<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &lt;style&gt;</span><br><span class="line">       .zs&#123;</span><br><span class="line">           color: blue;</span><br><span class="line">       &#125;</span><br><span class="line">   &lt;&#x2F;style&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">   &lt;li class&#x3D;&quot;zs&quot;&gt;张无极&lt;&#x2F;li&gt;</span><br><span class="line">   &lt;li class&#x3D;&quot;zs&quot;&gt;张飞&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>
元素选择器    元素名称{样式属性列表}<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &lt;style&gt;</span><br><span class="line">        div&#123;</span><br><span class="line">            border: 1px solid red;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">   &lt;&#x2F;style&gt;</span><br><span class="line">&lt;div&gt;1&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>优先级：id &gt; class &gt;元素<h3><span id="kuo-zhan-xuan-ze-qi">扩展选择器</span><a href="#kuo-zhan-xuan-ze-qi" class="header-anchor">#</a></h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 交集   用.隔开</span><br><span class="line">       两个选择器的范围之间的交集，两个选择器直接写在一起，不要理解为用.连接</span><br><span class="line"></span><br><span class="line">2. 并集   用,隔开</span><br><span class="line"></span><br><span class="line">3. 后代</span><br><span class="line">   后代用空格隔开，可跨越多代</span><br><span class="line"></span><br><span class="line">4. 子代</span><br><span class="line">   用大于号隔开，跨越一代 如： div&gt;li</span><br><span class="line"></span><br><span class="line">5. 属性选择器</span><br><span class="line">   1. span[a&#x3D;&quot;a&quot;]&#123;&#125;</span><br><span class="line"></span><br><span class="line">   2.&lt;span a&#x3D;&quot;a&quot;&gt; &lt;span&gt;</span><br><span class="line">   例：</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        &#x2F;*元素选择器和属性选择器取  交集 *&#x2F;</span><br><span class="line">        span[a&#x3D;&#39;a&#39;]&#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">        span[b&#x3D;&#39;b&#39;]&#123;</span><br><span class="line">            color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">        [c&#x3D;&quot;c&quot;][e&#x3D;&quot;e&quot;]&#123;</span><br><span class="line">            color: rebeccapurple;</span><br><span class="line">        &#125;</span><br><span class="line">        [d&#x3D;&quot;d&quot;]&#123;</span><br><span class="line">            color: yellowgreen;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        &lt;span a&#x3D;&quot;a&quot;&gt;当我的紫葡萄化为深秋的露水&lt;&#x2F;span&gt; &lt;br&gt;</span><br><span class="line">        &lt;span b&#x3D;&quot;b&quot;&gt;当我的鲜花依偎在别人的情怀&lt;&#x2F;span&gt; &lt;br&gt;</span><br><span class="line">        &lt;span c&#x3D;&quot;c&quot; e&#x3D;&quot;e&quot;&gt;我依然固执的拾起凝霜的枯藤&lt;&#x2F;span&gt; &lt;br&gt;</span><br><span class="line">        &lt;span d&#x3D;&quot;d&quot;&gt;在凄凉的大地上写下相信未来&lt;&#x2F;span&gt; &lt;br&gt;</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">6. 伪类选择器(针对状态)</span><br><span class="line"></span><br><span class="line">   对于超链接，初始状态(a:link)，鼠标悬停状态(a:hover)，鼠标点击状态(a:action)，访问过状态(a:visited)</span><br></pre></td></tr></table></figure>
<h3><span id="chang-yong-de-shu-xing">常用的属性</span><a href="#chang-yong-de-shu-xing" class="header-anchor">#</a></h3><ol>
<li>字体属性<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字体属性的功能：设置页面字体的显示样式。</span><br><span class="line">	font-family 设置使用的字体</span><br><span class="line">	font-style 设置字体的样式，是否斜体</span><br><span class="line">	font-variant 设置字体的大小写</span><br><span class="line">	font-weight 设置字体的粗细</span><br><span class="line">	font-size 设置字体的大小</span><br></pre></td></tr></table></figure></li>
<li>颜色和背景属性<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">颜色和背景属性的功能:设置页面元素的颜色和背景颜色.</span><br><span class="line">color 设置元素前景色</span><br><span class="line">background-color 设置元素背景色	</span><br><span class="line">background-imge 设置元素背景图案	</span><br><span class="line">background-repeat 设置背景图案的重复方式	</span><br><span class="line">background-position 设置背景图案的初始位置	</span><br><span class="line">background-size 设置背景大小</span><br></pre></td></tr></table></figure></li>
<li>文本属性<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文本属性的功能:设置页面的显示效果。</span><br><span class="line">text-align 设置文本的对齐方式</span><br><span class="line">text-indent 设置文本的首行缩进		</span><br><span class="line">line-height 设置文本的行高		</span><br><span class="line">a:link 设置链接未访问的状态</span><br><span class="line">a:visited 设置链接访问过的的状态</span><br><span class="line">a:hover 设置链接的鼠标悬停状态</span><br></pre></td></tr></table></figure></li>
<li>边框属性<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">边框属性是设置页面内边框元素的显示效果</span><br><span class="line">border :边框 border:&quot;1px solid red&quot;  三个子属性：边框宽度 实线&#x2F;虚线 颜色</span><br></pre></td></tr></table></figure></li>
<li>块属性<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">块属性是设置元素之间的距离</span><br><span class="line">外边距</span><br><span class="line">margin:</span><br><span class="line"> margin-left  左外边距</span><br><span class="line"> margin-right 右外边距</span><br><span class="line"> margin-top   上外边距</span><br><span class="line"> margin-bottom 下外边距</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">margin: 10px 10px 30px 20px; 依次表示：上 右 下 左</span><br><span class="line">margin: 10px 10px;  依次表示上 左</span><br><span class="line">margin: 10px auto;  auto会自动居中</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">上下冲突时，满足上面的</span><br><span class="line">左右冲突时，满足左边的</span><br><span class="line"></span><br><span class="line">padding</span><br><span class="line">	容器内部的边距称为padding	即从边框开始往里的距离</span><br><span class="line">	设置padding会增加宽，高，box-sizing: border-box;   盒子的尺寸按盒子的原始边框显示</span><br><span class="line"></span><br><span class="line">padding-top 设置顶端填充距</span><br><span class="line"></span><br><span class="line">padding-right  设置右侧填充距距 使用 同外边距一样。</span><br></pre></td></tr></table></figure></li>
<li>层属性<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置页面内元素的定位方式：</span><br><span class="line">Relative 设置相当定位</span><br><span class="line">Absolute 设置绝对定位</span><br></pre></td></tr></table></figure></li>
<li>内联元素(inline)和块级元素(block) </li>
</ol>
<p>内联元素(inline)<br>对应于display:block<br>1、内联元素(inline)不会独占一行，相邻的内联元素会排在同一行。其宽度随内容的变化而变化。<br>2、内联元素不可以设置宽高<br>3、行内元素起边距作用的只有margin-left、margin-right、padding-left、padding-right，其它属性不会起边距效果。<br>常见的有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a – 锚点 </span><br><span class="line">abbr – 缩写 </span><br><span class="line">b – 粗体</span><br><span class="line">big – 大字体 </span><br><span class="line">br – 换行 </span><br><span class="line">cite – 引用 </span><br><span class="line">code – 计算机代码(在引用源码的时候需要) </span><br><span class="line">em – 强调 </span><br><span class="line">font – 字体设定(不推荐) </span><br><span class="line">i – 斜体 </span><br><span class="line">img – 图片 </span><br><span class="line">input – 输入框 </span><br><span class="line">kbd – 定义键盘文本 </span><br><span class="line">label – 表格标签 </span><br><span class="line">q – 短引用 </span><br><span class="line">span – 常用内联容器，定义文本内区块 </span><br><span class="line">strong – 粗体强调 </span><br><span class="line">textarea – 多行文本输入框</span><br></pre></td></tr></table></figure>
<p>块级元素<br>对应于display:inline；<br>1、块级元素会独占一行，默认情况下宽度自动填满其父元素宽度<br>2、块级元素可以设置宽高<br>3、块级元素可以设置margin，padding<br>常见的有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">address – 地址 </span><br><span class="line">blockquote – 块引用 </span><br><span class="line">dir – 目录列表 </span><br><span class="line">div – 常用块级容易，也是CSS layout的主要标签 </span><br><span class="line">dl – 定义列表 </span><br><span class="line">fieldset – form控制组 </span><br><span class="line">form – 交互表单 </span><br><span class="line">h1 – h6 标题 </span><br><span class="line">hr – 水平分隔线 </span><br><span class="line">menu – 菜单列表 </span><br><span class="line">ol – 有序表单 </span><br><span class="line">p – 段落 </span><br><span class="line">pre – 格式化文本 </span><br><span class="line">table – 表格 </span><br><span class="line">ul – 无序列表 </span><br><span class="line">li -定义列表项目</span><br></pre></td></tr></table></figure>
<p>内联块状元素(display: inline-block)：<br>简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现（可以设置宽高和margin值）。之后的内联对象会被排列在同一内联。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。</p>
<ol start="8">
<li>浮动<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两个块级元素都设置了宽度和高度，两个想要占一行，就使用浮动，来进行设置</span><br><span class="line">如果有嵌套，浮动相对的就是父元素，没有父元素，浮动相对的就是浏览器窗口</span><br><span class="line">两边都为左浮动，如果宽度放不下，会被挤下去</span><br><span class="line">默认情况下，子元素能够撑起父元素的高度</span><br><span class="line">如果子元素设置了浮动，是没有办法撑起父元素的高度，父元素要么手动设置高度，要么清除浮动</span><br><span class="line">表示垂直屏幕向上漂浮，会脱离文档流，也会让块级元素div失去 换行功能</span><br><span class="line">float:left 向左浮动</span><br><span class="line">float:right 向右浮动</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Python函数式编程及案例</title>
    <url>/2021/04/12/Python%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#python-han-shu-shi-bian-cheng-ji-an-li">Python函数式编程及案例</a><ul>
<li><a href="#python-han-shu">Python函数</a><ul>
<li><a href="#xian-ding-fang-fa-can-shu-lei-xing-fan-hui-zhi-lei-xing-bian-liang-lei-xing">限定方法参数类型、返回值类型、变量类型</a></li>
<li><a href="#fu-za-de-lei-xing-biao-zhu">复杂的类型标注</a></li>
</ul>
</li>
<li><a href="#die-dai-qi-sheng-cheng-qi">迭代器、生成器</a><ul>
<li><a href="#sheng-cheng-qi-generator-yield">生成器(generator) - yield</a></li>
<li><a href="#sheng-cheng-qi-biao-da-shi-yu-lie-biao-tui-dao-shi">生成器表达式() 与 列表推导式[]</a></li>
</ul>
</li>
<li><a href="#python-gao-jie-han-shu-zhuang-shi-qi-pian-han-shu">Python高阶函数、装饰器、偏函数</a><ul>
<li><a href="#nei-qian-han-shu-zai-han-shu-nei-bu-ding-yi-de-han-shu">内嵌函数：在函数内部定义的函数；</a></li>
<li><a href="#han-shu-bi-bao-wai-bu-han-shu-fan-hui-liao-nei-qian-han-shu-huo-nei-bu-han-shu-yin-yong-liao-wai-bu-bian-liang">函数闭包：外部函数返回了内嵌函数，或内部函数引用了外部变量</a></li>
<li><a href="#gao-jie-han-shu-map-reduce-filter-sorted">高阶函数 -map、reduce、filter、sorted</a></li>
<li><a href="#zhuang-shi-qi-decorator">装饰器(Decorator)</a></li>
<li><a href="#pian-han-shu">偏函数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h2><span id="python-han-shu-shi-bian-cheng-ji-an-li">Python函数式编程及案例</span><a href="#python-han-shu-shi-bian-cheng-ji-an-li" class="header-anchor">#</a></h2><h3><span id="python-han-shu">Python函数</span><a href="#python-han-shu" class="header-anchor">#</a></h3><p>虚参的类型根据实参来推断，作用类似于模板类型参数<t>，但是更灵活</t></p>
<p> 虚参缺省值</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def print_sum(a,b&#x3D;1,c&#x3D;0):</span><br><span class="line">    s&#x3D;a+b+c</span><br><span class="line">    print(&quot;&#123;0&#125; + &#123;1&#125; + &#123;2&#125; &#x3D; &#123;3&#125;&quot;.format(a, b, c, s))</span><br><span class="line">    return s</span><br><span class="line">x &#x3D; print_sum(10, 20)       # a&#x3D;10, b&#x3D;20, c&#x3D;0</span><br><span class="line"></span><br><span class="line"># x &#x3D; print_sum(10, c&#x3D;20)   # a&#x3D;10, b&#x3D;1, c&#x3D;20</span><br><span class="line"># y &#x3D; print_sum(&quot;abc &quot;, &quot;xyz&quot;) # a&#x3D;&#39;abc&#39;, b&#x3D; &#39;xyz&#39;, c&#x3D;0  error!</span><br><span class="line">y &#x3D; print_sum(&quot;abc &quot;, &quot;xyz&quot;, &#39;!&#39;)   # a&#x3D;&#39;abc&#39;, b&#x3D; &#39;xyz&#39;, c&#x3D;&#39;!&#39;</span><br><span class="line">z &#x3D; print_sum(100.0 ,20)    # a&#x3D;100.0, b&#x3D;1, c&#x3D;0</span><br></pre></td></tr></table></figure>



<p>虚实结合,实参赋值给虚参，虚参改变后不会影响实参</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def swap(a, b):</span><br><span class="line">    a, b &#x3D; b, a     # 等价于 tuple 赋值: (a, b) &#x3D; (b, a)</span><br><span class="line">    print(a, b)</span><br><span class="line">x,y&#x3D;3,4</span><br><span class="line">print(x, y)</span><br><span class="line">swap(x, y)</span><br><span class="line">print(x, y)</span><br></pre></td></tr></table></figure>

<p>列表参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def lst_sum(lst):</span><br><span class="line">    s &#x3D; 0</span><br><span class="line">    for e in lst:</span><br><span class="line">        s +&#x3D; e</span><br><span class="line">    return s</span><br><span class="line"># s &#x3D; (1,2,3,4,5)    # tuple</span><br><span class="line"># s &#x3D; [1,2,3,4,5]   # list</span><br><span class="line">s &#x3D; set((1,3,5,7,9))   # set</span><br><span class="line">t &#x3D; lst_sum(s)      # s 可以是 tuple、list、set 等</span><br><span class="line">print(s, t)</span><br></pre></td></tr></table></figure>

<p> <em>args 和 *</em>kw 参数</p>
<p> *args是可变参数，args接收的是一个 tuple</p>
<p> **kw是关键字参数，kw接收的是一个 dic 调用函数时，如何传入可变参数和关键字参数的语法：</p>
<p> 可变参数，既可以直接传入：func(1, 2, 3)；又可以先组装成 list 或 tuple，再通过<em>args传入：func(</em>(1, 2, 3))</p>
<p> 关键字参数既可以直接传入：func(a=1, b=2)；又可以先组装成 dict，再通过<strong>kw传入：func(</strong>{‘a’: 1, ‘b’: 2})</p>
<p>使用<em>args和*</em>kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func_paras(param1, *params, **words):</span><br><span class="line">    print(&quot;param1: &quot;,param1)    # &#x3D;&#x3D;&gt; Hello!</span><br><span class="line">    print(&quot;params: &quot;, params)   # &#x3D;&#x3D;&gt; (1, 2, 3, 4, 5, &#39;abc&#39;)</span><br><span class="line">    print(&quot;words: &quot;, words)     # &#x3D;&#x3D;&gt; &#123;&#39;word1&#39;: &#39;Java&#39;, &#39;word2&#39;: &#39;Python&#39;&#125;</span><br><span class="line"></span><br><span class="line">func_paras(&quot;Hello!&quot;,1,2,3,4,5,&quot;abc&quot;, word1&#x3D;&quot;Java&quot;, word2&#x3D;&quot;Python&quot;)</span><br></pre></td></tr></table></figure>
<p>python限定方法参数类型、返回值类型、变量类型等<br><a href="https://www.cnblogs.com/linkenpark/p/11676297.html" target="_blank" rel="noopener">https://www.cnblogs.com/linkenpark/p/11676297.html</a></p>
<h4><span id="xian-ding-fang-fa-can-shu-lei-xing-fan-hui-zhi-lei-xing-bian-liang-lei-xing">限定方法参数类型、返回值类型、变量类型</span><a href="#xian-ding-fang-fa-can-shu-lei-xing-fan-hui-zhi-lei-xing-bian-liang-lei-xing" class="header-anchor">#</a></h4><p>基本类型指定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test(a:int, b:str) -&gt; str:</span><br><span class="line">    print(a, b)</span><br><span class="line">    return 1000</span><br><span class="line"></span><br><span class="line">test(&#39;test&#39;, &#39;abc&#39;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 函数test，</span><br><span class="line"># a:int  指定了输入参数a为int类型，</span><br><span class="line"># b:str  b为str类型，</span><br><span class="line"># -&gt; str  返回值为srt类型。</span><br><span class="line">最终返回了一个int，此时pycharm就会有警告；</span><br><span class="line">当调用这个方法时，参数a我们输入的是字符串，此时也会有警告；</span><br><span class="line">但非常重要的一点是，pycharm只是提出了警告，但实际上运行是不会报错，毕竟python的本质还是动态语言</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test(b: List[int]) -&gt; str:</span><br><span class="line">    print(b)</span><br><span class="line">    return &#39;abc&#39;</span><br><span class="line">test([1,&#39;a&#39;])</span><br></pre></td></tr></table></figure>

<p>虽然我们指定了List[int]即由int组成的列表，但是，实际中，只要这个列表中存在int（其他的可以为任何类型），就不会出现警告</p>
<h4><span id="fu-za-de-lei-xing-biao-zhu">复杂的类型标注</span><a href="#fu-za-de-lei-xing-biao-zhu" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vector &#x3D; List[float]</span><br><span class="line">def scale(scalar: float, vector: Vector) -&gt; Vector:</span><br><span class="line">    return [scalar * num for num in vector]</span><br><span class="line"># typechecks; a list of floats qualifies as a Vector.</span><br><span class="line">new_vector &#x3D; scale(2.0, [1.0, -4.2, 5.4])</span><br><span class="line">print(new_vector)</span><br></pre></td></tr></table></figure>

<p>创建变量时的类型指定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Employee(NamedTuple):</span><br><span class="line">    name: str</span><br><span class="line">    id: int &#x3D; 3</span><br><span class="line"></span><br><span class="line">employee &#x3D; Employee(&#39;Guido&#39;)</span><br><span class="line">assert employee.id &#x3D;&#x3D; 3</span><br></pre></td></tr></table></figure>

<h3><span id="die-dai-qi-sheng-cheng-qi">迭代器、生成器</span><a href="#die-dai-qi-sheng-cheng-qi" class="header-anchor">#</a></h3><p>迭代器(iterator)，是函数式编程的基石<br>生成器(generator)，是一类用来简化编写迭代器工作的特殊函数<br> 迭代器，是一个数据流对象；该对象每次只返回一个元素<br> <strong>next</strong>() 方法：<br> 无参数，并总是返回数据流中的下一个元素<br> 无元素时，会抛出异常 StopIteration<br> 迭代器未必是有限的<br> iter() 函数:<br> 接受任意对象并试图返回一个迭代器<br> 对象若不支持迭代时，抛出 TypeError 异常<br> 对象若能生成迭代器，则称为 iterable，可迭代的对象类型有:<br> 元组、列表、序列(字符串)、字典(key)、集合、文件等<br> for X in Y 等价于 for X in iter(Y)<br> list(iterator), 把迭代器具体化成列表<br>tuple(iterator), 把迭代器具体化成元组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L &#x3D; [1, 2, 3]</span><br><span class="line">it &#x3D; iter(L)  #转化为 迭代器</span><br><span class="line">print(it)</span><br><span class="line">print(it.__next__())    # &#x3D;&#x3D;&gt; 1  等价于 next(it)</span><br><span class="line">print(next(it))         # &#x3D;&#x3D;&gt; 2</span><br><span class="line">print(next(it))         # &#x3D;&#x3D;&gt; 3</span><br><span class="line">print(next(it))         # StopIteration</span><br><span class="line">it &#x3D; iter([1, 2, 3])    # 转化为迭代器</span><br><span class="line">for x in it:</span><br><span class="line">    print(x)    # &#x3D;&#x3D;&gt; 1 2 3</span><br><span class="line">t &#x3D; tuple(iter(L))           # &#x3D;&#x3D;&gt; (1, 2, 3) - 元组</span><br><span class="line">lst &#x3D; list(it)          # &#x3D;&#x3D;&gt; [] - 空列表，it 已空</span><br><span class="line">print(t, lst)</span><br><span class="line">a, b, c &#x3D; iter([1, 2, 3])   # 解压</span><br><span class="line">print(a,b,c)</span><br></pre></td></tr></table></figure>

<h4><span id="sheng-cheng-qi-generator-yield">生成器(generator) - yield</span><a href="#sheng-cheng-qi-generator-yield" class="header-anchor">#</a></h4><p>普通的函数返回(return)一个值，而生成器返回(yield)一个能返回数据流的迭代器。当你调用一个生成器函数，它并不会返回单独的值，而是返回一个支持生成器协议的生成器对象<br>当执行 yield 表达式i时，生成器会输出 i 的值，就像 return 表达式一样。yield 和 return 最大的区别在于，到达 yield 的时候生成器的执行状态会挂起并保留局部变量。在下一次调用生成器 <strong>next</strong>() 方法的时候，函数会恢复执行。<br>yield进一步阅读：Python3之携程 <a href="https://www.cnblogs.com/zhangxinqi/p/8337207.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangxinqi/p/8337207.html
</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def generate_ints(N):</span><br><span class="line">   for i in range(N):</span><br><span class="line">       yield i    # 用 yield 取代 return</span><br><span class="line">gen &#x3D; generate_ints(3)</span><br><span class="line">print(gen)</span><br><span class="line">print(next(gen))</span><br><span class="line">print(next(gen))</span><br><span class="line">print(next(gen))</span><br><span class="line">for i in generate_ints(5):</span><br><span class="line">    print(i)</span><br><span class="line">a, b, c &#x3D; generate_ints(3)</span><br><span class="line">print(a, b, c,&quot;\n&quot;)</span><br></pre></td></tr></table></figure>

<p>斐波拉契数列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def generate_fab(n):  # 生成斐波拉契数列的前 n 个数</span><br><span class="line">    for i in range(2):</span><br><span class="line">        yield 1</span><br><span class="line">    x &#x3D; y &#x3D; 1</span><br><span class="line">    for i in range(2, n):</span><br><span class="line">        z &#x3D; x + y</span><br><span class="line">        x, y &#x3D; y, z</span><br><span class="line">        yield z</span><br><span class="line">for k in generate_fab(10):</span><br><span class="line">    print(k)</span><br><span class="line">print()</span><br></pre></td></tr></table></figure>

<p>yield 变成了一个表达式，返回一个可以赋给变量或执行操作的值: val = (yield i)。而send(value) 方法向生成器val发送值value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def counter(maximum):</span><br><span class="line">    i &#x3D; 0</span><br><span class="line">    while i &lt; maximum:</span><br><span class="line">        val &#x3D; (yield i)</span><br><span class="line">        # If value provided, change counter</span><br><span class="line">        if val !&#x3D;None:</span><br><span class="line">            i &#x3D; val     # i &#x3D; val +1</span><br><span class="line">        else:</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line"></span><br><span class="line">it &#x3D; counter(20)</span><br><span class="line">L1 &#x3D; [next(it) for i in range(3)]   # 列表推导式，见 2.3 节</span><br><span class="line">print(L1)   # &#x3D;&#x3D;&gt; [0, 1, 2]</span><br><span class="line">it.send(8)# 向 it 发送值 8， val &#x3D; 8</span><br><span class="line">L1.extend([next(it) for i in range(3)])#list.extend() 合并列表</span><br><span class="line">print(L1)</span><br><span class="line">it.send(15)  # 向 it 发送值 15</span><br><span class="line">L1.extend([next(it) for i in range(3)])</span><br><span class="line">print(L1)   # &#x3D;&#x3D;&gt; [0, 1, 2, 9, 10, 11, 16, 17, 18]</span><br><span class="line">it.send(5)  # 向 it 发送值 5</span><br><span class="line">L1.extend([next(it) for i in range(3)])</span><br><span class="line">print(L1)   # &#x3D;&#x3D;&gt; [0, 1, 2, 9, 10, 11, 16, 17, 18, 6, 7, 8]</span><br></pre></td></tr></table></figure>
<h4><span id="sheng-cheng-qi-biao-da-shi-yu-lie-biao-tui-dao-shi">生成器表达式() 与 列表推导式[]</span><a href="#sheng-cheng-qi-biao-da-shi-yu-lie-biao-tui-dao-shi" class="header-anchor">#</a></h4><p>Generator expression – returns iterator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stripped_iter &#x3D; (line.strip() for line in line_list)</span><br><span class="line">print(stripped_iter, tuple(stripped_iter))</span><br></pre></td></tr></table></figure>

<p>List comprehension – returns list</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stripped_list &#x3D; [line.strip() for line in line_list]</span><br><span class="line">print(stripped_list)</span><br></pre></td></tr></table></figure>

<p>if - 加过滤条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stripped_list &#x3D; [line.strip() for line in line_list if line !&#x3D; &quot;\n&quot;]</span><br><span class="line">print(stripped_list)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">生成器表达式的一般形式(语法):</span><br><span class="line">( expression for expr1 in sequence1</span><br><span class="line">             if condition1</span><br><span class="line">             for expr2 in sequence2</span><br><span class="line">             if condition2</span><br><span class="line">             ...</span><br><span class="line">             for exprN in sequenceN</span><br><span class="line">             if conditionN )</span><br><span class="line">等价于：</span><br><span class="line"></span><br><span class="line">for expr1 in sequence1:</span><br><span class="line">    if not (condition1):</span><br><span class="line">        continue   # Skip this element</span><br><span class="line">    for expr2 in sequence2:</span><br><span class="line">        if not (condition2):</span><br><span class="line">            continue   # Skip this element</span><br><span class="line">        ...</span><br><span class="line">        for exprN in sequenceN:</span><br><span class="line">            if not (conditionN):</span><br><span class="line">                continue   # Skip this element</span><br></pre></td></tr></table></figure>

<h3><span id="python-gao-jie-han-shu-zhuang-shi-qi-pian-han-shu">Python高阶函数、装饰器、偏函数</span><a href="#python-gao-jie-han-shu-zhuang-shi-qi-pian-han-shu" class="header-anchor">#</a></h3><p>函数是对象<br>函数作为对象使用，可以赋值，可作为参数传递等，可以递归；<br>Python： 一切皆对象</p>
<h4><span id="nei-qian-han-shu-zai-han-shu-nei-bu-ding-yi-de-han-shu">内嵌函数：在函数内部定义的函数；</span><a href="#nei-qian-han-shu-zai-han-shu-nei-bu-ding-yi-de-han-shu" class="header-anchor">#</a></h4><h4><span id="han-shu-bi-bao-wai-bu-han-shu-fan-hui-liao-nei-qian-han-shu-huo-nei-bu-han-shu-yin-yong-liao-wai-bu-bian-liang">函数闭包：外部函数返回了内嵌函数，或内部函数引用了外部变量</span><a href="#han-shu-bi-bao-wai-bu-han-shu-fan-hui-liao-nei-qian-han-shu-huo-nei-bu-han-shu-yin-yong-liao-wai-bu-bian-liang" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def g():</span><br><span class="line">    count &#x3D; 0       # g()的局部变量</span><br><span class="line">    def counter():  # g()的内嵌函数</span><br><span class="line">        nonlocal count  # 不是counter()的内部变量，而是它外部g()的变量</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        return count</span><br><span class="line">    return counter  # 返回函数对象</span><br><span class="line"></span><br><span class="line">f1 &#x3D; g()</span><br><span class="line">f2 &#x3D; g() # f1 与 f2 执行时，互不影响</span><br><span class="line"></span><br><span class="line">print(&quot;f1:&quot;, f1(), f1())    # &#x3D;&#x3D;&gt; f1: 1 2</span><br><span class="line">print(&quot;f2:&quot;, f2())          # &#x3D;&#x3D;&gt; f2: 1</span><br><span class="line">print(&quot;f1:&quot;,f1(), f1())     # &#x3D;&#x3D;&gt; f1: 3 4</span><br><span class="line">print(&quot;f2:&quot;, f2(), f2(), f2())  # &#x3D;&#x3D;&gt; f2: 2 3 4</span><br><span class="line"></span><br><span class="line">def fiboracci(): # 斐波拉契数列</span><br><span class="line">    x &#x3D; y &#x3D; 1</span><br><span class="line">    def gen(): # 斐波拉契数列生成器</span><br><span class="line">        nonlocal x, y</span><br><span class="line">        z &#x3D; x + y</span><br><span class="line">        x, y &#x3D; y, z</span><br><span class="line">        return z</span><br><span class="line">    return gen</span><br><span class="line">f1 &#x3D; fiboracci()</span><br><span class="line">f2 &#x3D; fiboracci()</span><br><span class="line">L1 &#x3D; [f1() for i in range(10)]</span><br><span class="line">print(L1)           # &#x3D;&#x3D;&gt; [2, 3, 5, 8, 13, 21, 34, 55, 89, 144]</span><br><span class="line">print([f2() for i in range(8)])   # &#x3D;&#x3D;&gt; [2, 3, 5, 8, 13, 21, 34, 55]</span><br></pre></td></tr></table></figure>

<h4><span id="gao-jie-han-shu-map-reduce-filter-sorted">高阶函数 -map、reduce、filter、sorted</span><a href="#gao-jie-han-shu-map-reduce-filter-sorted" class="header-anchor">#</a></h4><p>map</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def f1(x):</span><br><span class="line">    return x ** 2</span><br><span class="line"></span><br><span class="line">L &#x3D; [1,2,3,4,5,6,7,8,9]</span><br><span class="line">R &#x3D; list(map(f1, L)) # 让map的结果转换为list</span><br><span class="line">print(&quot;map结果:&quot;, R) # &#x3D;&#x3D; &gt; map结果: [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line"></span><br><span class="line">r2 &#x3D; map(f1, L)</span><br><span class="line">print(r2)       # map对象，是一个可迭代的(iterable)对象</span><br><span class="line">for x in r2:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure>

<p>reduce</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line">def f2(x, y):</span><br><span class="line">    return x * 10 + y</span><br><span class="line">a &#x3D; reduce(f2, L)</span><br><span class="line">print(&quot;reduce结果为:&quot;, a) # &#x3D;&#x3D; &gt; reduce结果为: 123456789</span><br><span class="line">filter</span><br><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 &#x3D;&#x3D; 1</span><br><span class="line">L1 &#x3D; list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</span><br><span class="line">print(L1) # &#x3D;&#x3D;&gt; [1, 5, 9, 15]</span><br></pre></td></tr></table></figure>

<p>zip (不是高阶函数，常用)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L1 &#x3D;[1,3,5,7,9]</span><br><span class="line">L2 &#x3D;[10,11,12,13,14]</span><br><span class="line">for x,y in zip(L1,L2):</span><br><span class="line">    print(x,y)</span><br><span class="line">L &#x3D; list(zip(L1,L2))</span><br><span class="line">print(L)</span><br></pre></td></tr></table></figure>

<p>3.4 匿名函数(lambda 表达式)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L6 &#x3D; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</span><br><span class="line">print(&quot;匿名函数:&quot;,L6) # &#x3D;&#x3D;&gt; [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f(x):</span><br><span class="line">return x * x</span><br><span class="line"></span><br><span class="line">f &#x3D; lambda x: x * x</span><br><span class="line"></span><br><span class="line">L6 &#x3D; list(map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</span><br><span class="line">print(L6) # &#x3D;&#x3D;&gt; [1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure>

<h4><span id="zhuang-shi-qi-decorator">装饰器(Decorator)</span><a href="#zhuang-shi-qi-decorator" class="header-anchor">#</a></h4><p>给已有函数增加额外的功能，而不需要改变原函数代码及其调用方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def handle():   # 原业务功能函数</span><br><span class="line">    print(&quot;处理主要的业务逻辑 -handle&quot;)</span><br><span class="line"></span><br><span class="line">handle()        # 原调用方式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">新加一个高阶函数，增加额外功能</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def log(func): # 装饰器，给函数 func 增加额外功能</span><br><span class="line">    counter &#x3D; 0</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        nonlocal counter</span><br><span class="line">        counter +&#x3D; 1</span><br><span class="line">        print(&quot;counter:%d，执行%s之前&quot; % (counter, func.__name__))</span><br><span class="line">        func()  # 调用原函数</span><br><span class="line">        print(&quot;counter:%d，执行%s之后&quot; % (counter, func.__name__))</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">def handle(): # 原业务功能函数</span><br><span class="line">    print(&quot;处理主要的业务逻辑 -handle&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">调用装饰器对已有函数进行装饰，左边的 handle&#x3D;wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">handle &#x3D; log(handle)    # 每次调用前都要这样做，比较麻烦，也违反开闭原则</span><br><span class="line">handle()                # 等价于: log(handle)()</span><br><span class="line"></span><br><span class="line">@log# handle &#x3D; log(handle)  使用log对handle进行封装，左边 handle&#x3D;wrapper</span><br><span class="line">def handle():   # 原业务功能函数</span><br><span class="line">    print(&quot;处理主要的业务逻辑 -handle&quot;)</span><br><span class="line">handle()        # 调用方式不变</span><br><span class="line">import time</span><br><span class="line">def log2(time):  # 装饰器函数</span><br><span class="line">    def decorator(func):</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            print(time.title())</span><br><span class="line">            print(&quot;执行%s之前&quot; % (func.__name__))</span><br><span class="line">            func()</span><br><span class="line">            print(&quot;执行%s之后&quot; % (func.__name__))</span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br><span class="line">@log2(time&#x3D;time.ctime()) # 加装饰器</span><br><span class="line">def handle2():</span><br><span class="line">    print(&quot;处理主要的业务逻辑 -handle2&quot;)</span><br><span class="line"></span><br><span class="line">handle2()    # 调用方式不变</span><br></pre></td></tr></table></figure>
<p>进一步阅读 <a href>https://blog.csdn.net/mall_lucy/article/details/108791699?utm_source=app</a></p>
<h4><span id="pian-han-shu">偏函数</span><a href="#pian-han-shu" class="header-anchor">#</a></h4><p>当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def power(base, exponent):</span><br><span class="line">    return base ** exponent</span><br><span class="line"></span><br><span class="line">from functools import partial</span><br><span class="line"></span><br><span class="line">square &#x3D; partial(power, exponent&#x3D;2) # power(base, exponent&#x3D;2)</span><br><span class="line">print(square(3), square(4))    # &#x3D;&#x3D;&gt; 9 16</span><br><span class="line">import functools</span><br></pre></td></tr></table></figure>
<p>通过偏函数声明一个函数名为int2的函数，实现转换成int类型并且参数要和base保持一致最后的结果是10进制的类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int2 &#x3D; functools.partial(int, base&#x3D;2)</span><br><span class="line">print(&quot;二进制的数:&quot;,int2(&quot;1000&quot;)) # &#x3D;&#x3D;&gt; 8</span><br></pre></td></tr></table></figure>

<p>参考文献：</p>
<p><a href="https://blog.csdn.net/weixin_42621370/article/details/102292467" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42621370/article/details/102292467</a><br><a href="https://docs.python.org/zh-cn/3.7/howto/functional.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3.7/howto/functional.html</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>详解Java中的抽象类与接口</title>
    <url>/2020/08/01/%E8%AF%A6%E8%A7%A3Java%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#shou-xian-lai-shuo-yi-shuo-zhe-liang-zhe-de-gai-nian">首先来说一说这两者的概念</a></li>
<li><a href="#yi-chou-xiang-lei-yu-chou-xiang-fang-fa-de-ding-yi">一、抽象类与抽象方法的定义</a><ul>
<li><a href="#chou-xiang-fang-fa">抽象方法</a></li>
<li><a href="#zuo-yong">作用</a></li>
</ul>
<ul>
<li><a href="#jie-kou">接口</a></li>
</ul>
<ul>
<li><a href="#zuo-yong-1">作用</a></li>
</ul>
<ul>
<li><a href="#chou-xiang-lei-yu-jie-kou-de-yi-tong">抽象类与接口的异同</a></li>
<li><a href="#shi-yong-chang-jing">使用场景</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h3><span id="shou-xian-lai-shuo-yi-shuo-zhe-liang-zhe-de-gai-nian">首先来说一说这两者的概念</span><a href="#shou-xian-lai-shuo-yi-shuo-zhe-liang-zhe-de-gai-nian" class="header-anchor">#</a></h3><h3><span id="yi-chou-xiang-lei-yu-chou-xiang-fang-fa-de-ding-yi">一、抽象类与抽象方法的定义</span><a href="#yi-chou-xiang-lei-yu-chou-xiang-fang-fa-de-ding-yi" class="header-anchor">#</a></h3><p>抽象方法和抽象类都必须被abstract关键字修饰。<br>抽象——abstract，抽象类的方法不一定是抽象的，但抽象方法出现的类一定是抽象类。抽象类也是可以与普通类那样，可以直接extends，区别在于抽象类不能直接实例化，可以通过实例化其子类，然后重写里面的抽象方法实现，抽象类一定要被继承实现的，否则毫无意义。子类可以不是抽象类，但要实现抽象父类中的所有抽象方法，否则必须定义为abstract类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Door &#123;</span><br><span class="line">    public abstract void opendoor();</span><br><span class="line">    public abstract void closedoor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="chou-xiang-fang-fa">抽象方法</span><a href="#chou-xiang-fang-fa" class="header-anchor">#</a></h4><p>抽象方法和空方法体的方法不是同一个概念。例如，public abstract void test();是一个抽象方法，它根本没方法体，即方法定义后面没有一对花括号；但public void test(){}方法是一个普通方法，它已经定义了方法体，只是方法体为空。<br>abstract不能用于修饰成员变量（Field），不能用于修饰局部变量，即没有抽象变量、没有抽象Field等说法；abstract也不能用于修饰构造器，没有抽象构造器，抽象类里定义的构造器只能是普通构造器。</p>
<h4><span id="zuo-yong">作用</span><a href="#zuo-yong" class="header-anchor">#</a></h4><p>抽象类是普通的类与接口之间的一种中庸之道。</p>
<p>抽象方法、抽象类可以使类的抽象性明确起来，告诉用户和编译器怎么使用它们；</p>
<p>同时，抽象类是很好的重构工具，在后期的工作中，可以实现重用性。</p>
<p>体现一种模板的效果，从一群相似的子类提炼出一个抽象类的感觉一样，提供了一种规范，子类可以在其原来的基础上进行扩展。</p>
<p>抽象父类可以只定义需要使用的某些方法，把不能实现的部分抽象成抽象方法，抽象类类似领导，领袖这一类角色，类中可以定义很多的抽象方法，就像是给子类制定了很多应该具备的功能，或指定了很多应该完成的目标。</p>
<h2><span id="jie-kou">接口</span><a href="#jie-kou" class="header-anchor">#</a></h2><p>为了实现多继承，引入了接口这个概念</p>
<p>接口通常被理解为一个组件，接口比抽象类更抽象，在接口中所有的方法都是抽象的。就不能像抽象类一样还可以有普通方法。Java中可以implements多个接口，多继承的含义便是接入多个接口实现（继承只能单继承），（abstract省略)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Lock &#123;</span><br><span class="line">    void openLock();</span><br><span class="line">    void closeLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TheftProofDoor extends Door implements Lock&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void opendoor() &#123;</span><br><span class="line">        System.out.println(&quot;门开了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void closedoor() &#123;</span><br><span class="line">        System.out.println(&quot;门关上了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void openLock() &#123;</span><br><span class="line">        System.out.println(&quot;所开了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void closeLock() &#123;</span><br><span class="line">        System.out.println(&quot;锁上了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="zuo-yong">作用</span><a href="#zuo-yong" class="header-anchor">#</a></h4><p>规范，在分配不同人的任务时，接口就像是总纲一样，告诉大家去实现哪些功能模块等。（命名规范都有限制到）</p>
<h2><span id="chou-xiang-lei-yu-jie-kou-de-yi-tong">抽象类与接口的异同</span><a href="#chou-xiang-lei-yu-jie-kou-de-yi-tong" class="header-anchor">#</a></h2><p>相同点：<br>（1）都不能被实例化<br>（2）接口和抽象类都可以包含抽象方法，只有实现了接口或抽象类中的方法后才能实例化。<br>不同点：  </p>
<ol>
<li>抽象类可以有普通方法。Java 8 之前接口中只有抽象方法，而 Java 8 之后接口中也可以声明具体方法，具体方法通过声明默认方法实现。</li>
<li>一个类可以实现多个接口，但一个类只能继承一个抽象类。接口解决了多重继承的问题</li>
<li>接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，</li>
<li>接口被用于常用的功能，便于日后维护和添加删除，而抽象类更倾向于充当公共类的角色，不适用于日后重新对立面的代码修改。功能需要累积时用抽象类，不需要累积时用接口。</li>
<li>一个类实现了一个或多个接口之后，这个类必须实现这些接口里所定义的全部抽象方法（也就是重写这些抽象方法）；否则，该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。</li>
<li>接口定义的是一种规范，因此接口里不能包含构造器和初始化块定义。接口里可以包含Field（只能是常量）、方法（只能是抽象实例方法）、内部类（包括内部接口、枚举）定义。但抽象类与普通类一样，可以有构造器，初始化模块等。</li>
</ol>
<h2><span id="shi-yong-chang-jing">使用场景</span><a href="#shi-yong-chang-jing" class="header-anchor">#</a></h2><p>接口多用于多重继承的时候（功能性强，规范性）</p>
<p>抽象类多用于底层基础功能模块不断改变（模板设计）</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>带你快速入门EL表达式和JSTL的使用</title>
    <url>/2020/08/01/%E5%B8%A6%E4%BD%A0%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8EL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8CJSTL%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#el-biao-da-shi">EL表达式</a><ul>
<li><a href="#jian-jie">简介</a></li>
<li><a href="#yu-fa-biao-da-shi">语法：${表达式}</a></li>
<li><a href="#gong-neng">功能：</a></li>
<li><a href="#yun-suan-fu">运算符</a></li>
<li><a href="#nei-zhi-dui-xiang">内置对象</a></li>
</ul>
</li>
<li><a href="#jstl">JSTL</a><ul>
<li><a href="#gai-nian">概念</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h2><span id="el-biao-da-shi">EL表达式</span><a href="#el-biao-da-shi" class="header-anchor">#</a></h2><h3><span id="jian-jie">简介</span><a href="#jian-jie" class="header-anchor">#</a></h3><p>Expression Language 表达式语言，为了使JSP写起来更加简单。表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法，让Jsp的代码更加简化。</p>
<h3><span id="yu-fa-biao-da-shi">语法：${表达式}</span><a href="#yu-fa-biao-da-shi" class="header-anchor">#</a></h3><p>忽略el,不会解析表达式，原因：</p>
<ul>
<li>page指令中定义 isElIgnored=”true” <ul>
<li>\${表达式}</li>
</ul>
</li>
</ul>
<h3><span id="gong-neng">功能：</span><a href="#gong-neng" class="header-anchor">#</a></h3><ul>
<li>简单的运算</li>
<li>取出域对象中的参数并在页面展示</li>
<li><h3><span id="yun-suan-fu">运算符</span><a href="#yun-suan-fu" class="header-anchor">#</a></h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.算术  + - * /(div)  %(mod)</span><br><span class="line"><span class="number">2</span>.比较  &gt;  &lt;  &gt;=  &lt;=  ==  !=</span><br><span class="line"><span class="number">3</span>.逻辑  &amp;&amp;(and)  ||(or)  !(not)</span><br><span class="line"><span class="number">4</span>.empty 判断字符串，数组，集合的对象是否为null,也可以判断长度是否为<span class="number">0</span></span><br><span class="line">	<span class="variable">$</span>&#123;empty list&#125; :null-<span class="literal">-true</span> </span><br><span class="line">    <span class="variable">$</span>&#123;empty <span class="string">""</span>&#125;  true</span><br><span class="line">    集合：<span class="variable">$</span>&#123;not empty list&#125;   list!=null&amp;&amp;list.size()!=<span class="number">0</span></span><br><span class="line">    字符串：<span class="variable">$</span>&#123;not empty str&#125;    str!=null&amp;&amp;str.length()!=<span class="number">0</span></span><br><span class="line">    数组：<span class="variable">$</span>&#123;not empty arr&#125;    arr!=null&amp;&amp;arr.length!=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3><span id="nei-zhi-dui-xiang">内置对象</span><a href="#nei-zhi-dui-xiang" class="header-anchor">#</a></h3></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">EL有11个内置对象，这里主要讲域属性相关的4个</span><br><span class="line">EL的11个内置对象，除了pageContext以外，其他10个内置对象的类型都是java.util.Map类型</span><br></pre></td></tr></table></figure>
   <table>
        <tr>
            <th>分类</th>
            <th>内置对象名称</th>
            <th>描述</th>
        </tr>
        <tr>
            <td rowspan="4">域对象</td>
            <td>pageScope</td>
            <td>page作用域</td>
        </tr>
        <tr>
            <td>requestScope</td>
            <td>request作用域</td>           
        </tr>
        <tr>
            <td>sessionScope</td>
            <td>session作用域</td>           
        </tr>
        <tr>
            <td>applicationScope</td>
            <td>application作用域</td>           
        </tr>
        <tr>
            <td rowspan="2">请求参数</td>
            <td>param</td>
            <td>用于获取请求参数的值，应用在参数值只有一个的情况。在应用param隐含对象时，返回结果为字符串。</td>           
        </tr>
        <tr>
            <td>paramValues</td>
            <td>用于当请求参数名对应多个值时获取参数的结果，在应用paramValues隐含对象时，返回结果为数组。</td>           
        </tr>
        <tr>
            <td rowspan="2">请求头</td>
            <td>header</td>
            <td>用于获取HTTP请求的一个具体的header的值。</td>           
        </tr>
        <tr>
            <td>headerValues</td>
            <td>用于获取HTTP请求的一个具体的header的值，但是在有些情况下，可能存在同一个header拥有多个不同的值的情况，这时就必须使用headerValues隐含对象。</td>           
        </tr>
        <tr>
            <td>JSP上下文对象</td>
            <td>pageContext</td>
            <td>页面上下文对象为pageContext，用于访问JSP内置对象（例如request、response、out、session、exception和page等，但不能用于获取application、config和pageContext对象）和servletContext。在获取到这些内置对象后，就可以获取其属性值。</td>           
        </tr>
        <tr>
        <td>全局初始化对象</td>
        <td>initParam</td>
        <td>用于获取Web应用初始化参数的值。</td>       
        </tr>
        <tr>
            <td>cookie</td>
            <td>cookie</td>
            <td>用于获取cookie对象，如果在cookie中已经设置一个名为username的值，那么可以使用 ${cookie.username} 来获取该cookie对象。但是如果要获取cookie中的值，需要使用cookie对象的value属性。</td>
        </tr>
    </table>

<ul>
<li>获取域对象中的参数<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">*   <span class="number">1</span>.pageScope</span><br><span class="line">    <span class="number">2</span>.requestScope</span><br><span class="line">    <span class="number">3</span>.sessionScope</span><br><span class="line">    <span class="number">4</span>.applicationScope</span><br><span class="line">* 取域中的数据</span><br><span class="line">    <span class="number">1</span>. <span class="variable">$</span>&#123;内置域对象.key&#125;</span><br><span class="line">    <span class="number">2</span>. <span class="variable">$</span>&#123;key&#125; 在四个域对象中从小到大的范围依次查找，如果没有数据，只显示空字符串，不会显示null</span><br></pre></td></tr></table></figure></li>
<li>获取域对象中的对象的值</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.域中存储的是javabean对象</span><br><span class="line">	<span class="variable">$</span>&#123;域名称.键值.对象属性名&#125;</span><br><span class="line"><span class="number">2</span>.域中存储的是list集合</span><br><span class="line">	<span class="variable">$</span>&#123;域名称.键值[索引]&#125;</span><br><span class="line"><span class="number">3</span>.域中存储的是map集合</span><br><span class="line">	<span class="variable">$</span>&#123;域名称.键值.key&#125; 或 <span class="variable">$</span>&#123;域名称.键值[<span class="string">"key"</span>]&#125;</span><br><span class="line"><span class="number">4</span>.域中存储的是数组</span><br><span class="line">	<span class="variable">$</span>&#123;域名称.键值[索引]&#125;</span><br></pre></td></tr></table></figure>
<p>实例代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//    案例一</span><br><span class="line">    Emps emps=new Emps();</span><br><span class="line">    emps.setName(<span class="string">"孙权"</span>);</span><br><span class="line">    emps.setAge(36);</span><br><span class="line">    Elephant elephant=new Elephant();</span><br><span class="line">    elephant.setName(<span class="string">"东东"</span>);</span><br><span class="line">    elephant.setAge(18);</span><br><span class="line">    emps.setElephant(elephant);</span><br><span class="line">    pageContext.setAttribute(<span class="string">"emps"</span>,emps);</span><br><span class="line"></span><br><span class="line">//    案例二</span><br><span class="line">    ArrayList&lt;Emps&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">    list.add(emps);</span><br><span class="line">    pageContext.setAttribute(<span class="string">"list"</span>,list);</span><br><span class="line"></span><br><span class="line">//    案例三</span><br><span class="line">    HashMap&lt;String,Emps&gt; map=new HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"three"</span>,emps);</span><br><span class="line">    pageContext.setAttribute(<span class="string">"map"</span>,map);</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line"><span class="variable">$&#123;pageScope.emps&#125;</span>&lt;br&gt;</span><br><span class="line"><span class="variable">$&#123;pageScope.emps.name&#125;</span>&lt;br&gt;</span><br><span class="line"><span class="variable">$&#123;pageScope.emps.age&#125;</span>&lt;br&gt;</span><br><span class="line"><span class="variable">$&#123;pageScope.emps.elephant&#125;</span>&lt;br&gt;</span><br><span class="line"><span class="variable">$&#123;pageScope.emps.elephant.name&#125;</span>&lt;br&gt;</span><br><span class="line"><span class="variable">$&#123;pageScope.emps.elephant.age&#125;</span>&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;h2&gt;案例二&lt;/h2&gt;</span><br><span class="line"><span class="variable">$&#123;pageScope.list[0]&#125;</span></span><br><span class="line">&lt;br&gt;</span><br><span class="line"><span class="variable">$&#123;pageScope.list.get(0)&#125;</span></span><br><span class="line"></span><br><span class="line">&lt;h2&gt;案例三&lt;/h2&gt;</span><br><span class="line"><span class="variable">$&#123;pageScope.map.three&#125;</span>&lt;br&gt;</span><br><span class="line"><span class="variable">$&#123;pageScope.map.three.elephant&#125;</span>&lt;br&gt;</span><br><span class="line"><span class="variable">$&#123;pageScope.map.three.elephant.name&#125;</span>&lt;br&gt;</span><br><span class="line"><span class="variable">$&#123;pageScope.map['three'].elephant&#125;</span>&lt;br&gt;</span><br><span class="line"><span class="variable">$&#123;pageScope.map['three'].elephant.age&#125;</span>&lt;br&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>其他重要内置对象<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.pageContext 获取jsp中其它<span class="number">8</span>个内置对象</span><br><span class="line">	*jsp页面动态获取虚拟路径(网络工程名) <span class="variable">$</span>&#123;pageContext.request.contextPath&#125;</span><br><span class="line">	</span><br><span class="line"><span class="number">2</span>.param  ==&gt; String value= request.getParameter(<span class="string">"参数名"</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.paramValues ==&gt; String [] values =  request.getParameterValues(<span class="string">"参数名"</span>);</span><br></pre></td></tr></table></figure>
<h2><span id="jstl">JSTL</span><a href="#jstl" class="header-anchor">#</a></h2><h3><span id="gai-nian">概念</span><a href="#gai-nian" class="header-anchor">#</a></h3>java Server Pages Tag Library   jsp中的标签库，可以嵌入在jsp页面中使用标签的形式完成业务逻辑等功能。jstl出现的目的同el一样也是要代替jsp页面中的脚本代码。JSTL标准标准标签库有5个子库，但随着发展，目前常使用的是他的核心库。<br><img src="https://img-blog.csdnimg.cn/20200725111509665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt><br>在使用前需要导入jar包,标准包能在tomcat安装目录找到。<br><img src="https://img-blog.csdnimg.cn/202007251123571.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200725111909230.png" alt></li>
</ul>
<p>主要：所有的jar包都要部署在服务器上。文件拷贝到 /WEB-INF/lib/ 下。</p>
<blockquote>
<p>&lt;%@taglib prefix=”c” uri=”<a href="http://java.sun.com/jsp/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core&quot;</a> %&gt;</p>
</blockquote>
<ul>
<li>if标签</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. &lt;c:<span class="keyword">if</span> test=<span class="string">"true"</span>&gt;</span><br><span class="line">   &lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">   </span><br><span class="line"><span class="number">2</span>. &lt;c:<span class="keyword">if</span> test=<span class="string">"<span class="variable">$</span>&#123;&#125;"</span>&gt;</span><br><span class="line">   &lt;/c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>choose标签</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;c:set var="m" value="11" scope="page"&gt;&lt;/c:set&gt;</span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">"$&#123;m&gt;=1 &amp;&amp; m&lt;=3&#125;"</span>&gt;</span><br><span class="line">        &lt;h3&gt;spring&lt;/h3&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">"$&#123;m&gt;=4 &amp;&amp; m&lt;=6&#125;"</span>&gt;</span><br><span class="line">        &lt;h3&gt;summer&lt;/h3&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">"$&#123;m&gt;=7 &amp;&amp; m&lt;=9&#125;"</span>&gt;</span><br><span class="line">        &lt;h3&gt;autumn&lt;/h3&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:otherwise&gt;</span><br><span class="line">        &lt;h3&gt;winter&lt;/h3&gt;</span><br><span class="line">    &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>foreach标签</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;c:forEach begin=<span class="string">"0"</span> end=<span class="string">"10"</span> step=<span class="string">"1"</span> <span class="keyword">var</span>=<span class="string">"i"</span>&gt; </span><br><span class="line">&lt;%--会自动将变量i存进pageContext域对象中--%&gt;</span><br><span class="line">    $&#123;pageScope.i&#125;  </span><br><span class="line">    - $&#123;requestScope.i&#125;  </span><br><span class="line">    - - $&#123;sessionScope.i&#125;</span><br><span class="line">    - - $&#123;applicationScope.i&#125; </span><br><span class="line">    - &lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">&lt;%--<span class="number">2</span>.增强<span class="keyword">for</span></span><br><span class="line">String [] arr=&#123;<span class="string">"abc"</span>,<span class="string">"haha"</span>,<span class="string">"hehe"</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String s:arr)&#123;</span><br><span class="line">   System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">--%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    String [] arr=&#123;<span class="string">"abc"</span>,<span class="string">"haha"</span>,<span class="string">"hehe"</span>&#125;;</span><br><span class="line">    request.setAttribute(<span class="string">"arr"</span>,arr);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">"s"</span> items=<span class="string">"$&#123;requestScope.arr&#125;"</span> varStatus=<span class="string">"vs"</span> &gt;</span><br><span class="line">&lt;%--会自动将变量s和对象vs 都存进pageContext域对象中--%&gt;</span><br><span class="line">    $&#123;s&#125; </span><br><span class="line">    -- $&#123;vs.count&#125;</span><br><span class="line">     -- $&#123;vs.index&#125;&lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">items属性：使用el从域对象中取出集合或数组</span><br><span class="line">forEach会遍历集合或数组，将每个值赋给<span class="keyword">var</span>中变量a</span><br><span class="line"><span class="keyword">var</span>属性：将变量s，存进pageConText域对象中，因此可以用$&#123;s&#125;取出域对象的参数值</span><br><span class="line">varStatus=“status”事实上定义了一个status名的对象作为varStatus的绑定值。</span><br><span class="line">该绑定值也就是status封装了当前遍历的状态。</span><br><span class="line">$&#123;status.index&#125;      输出行号，从<span class="number">0</span>开始。</span><br><span class="line">$&#123;status.count&#125;      输出行号，从<span class="number">1</span>开始。</span><br><span class="line">$&#123;status.current&#125;   当前这次迭代的（集合中的）项</span><br><span class="line">$&#123;status.first&#125;  判断当前项是否为集合中的第一项，返回值为<span class="keyword">true</span>或<span class="keyword">false</span></span><br><span class="line">$&#123;status.last&#125;   判断当前项是否为集合中的最后一项，返回值为<span class="keyword">true</span>或<span class="keyword">false</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot最快速使用入门</title>
    <url>/2020/08/01/SpringBoot%E6%9C%80%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#springboot-jian-jie">SpringBoot简介</a><ul>
<li><a href="#xian-lai-jie-shao-yi-xia-spring">先来介绍一下Spring</a></li>
<li><a href="#springboot-te-dian">Springboot特点</a></li>
</ul>
</li>
<li><a href="#zai-ideal-zhong-da-jian-springboot-gong-cheng">在ideal中搭建springboot工程</a><ul>
<li><a href="#pom-xml-jie-du">pom.xml解读</a></li>
</ul>
</li>
<li><a href="#springboot-zheng-he-ssm">Springboot整合ssm</a><ul>
<li><a href="#springmvc-he-mybatis-jian-jie">SpringMvc和Mybatis简介</a></li>
<li><a href="#springboot-zhi-chi-liang-chong-ge-shi-de-pei-zhi-wen-jian-properties-he-yml-ge-shi">SpringBoot支持两种格式的配置文件properties和yml格式.</a></li>
<li><a href="#gong-cheng-da-jian-bu-zou">工程搭建步骤</a></li>
</ul>
</li>
<li><a href="#springboot-zheng-he-thymeleaf">SpringBoot整合Thymeleaf</a><ul>
<li><a href="#thymeleaf-jian-jie">Thymeleaf简介</a></li>
<li><a href="#zheng-he-dao-spring-boot-bu-zou"><strong>整合到Spring boot步骤:</strong></a></li>
<li><a href="#thymeleaf-ji-ben-yu-fa">Thymeleaf基本语法</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h2><span id="springboot-jian-jie">SpringBoot简介</span><a href="#springboot-jian-jie" class="header-anchor">#</a></h2><h3><span id="xian-lai-jie-shao-yi-xia-spring">先来介绍一下Spring</span><a href="#xian-lai-jie-shao-yi-xia-spring" class="header-anchor">#</a></h3><p>Spring 诞生于2002年， 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。<br>缺点：<br>虽然Spring框架是轻量级的，但它的配置却是重量级的，jsp中要写很多代码、控制器过于灵活,缺少一个公用控制器。</p>
<p>Pivotal团队在原有Spring框架的基础上通过注解的方式进一步简化了Spring框架的使用，并基于Spring框架开发了全新的Spring Boot框架，于2014年4月正式推出了Spring Boot 1.0版本，同时在2018年3月又推出了Spring Boot 2.0版本。</p>
<p>SpringBoot 具有如下优点：</p>
<ol>
<li><p>快速创建独立运行的Spring项目以及与主流框架集成、</p>
</li>
<li><p>使用嵌入式的Servlet容器，应用无需打成WAR包</p>
</li>
<li><p>Starters自动依赖与版本控制</p>
</li>
<li><p>大量的自动配置，简化开发，也可修改默认值</p>
</li>
<li><p>无需配置XML，无代码生成，开箱即用</p>
</li>
<li><p>准生产环境的运行时应用监控</p>
</li>
<li><p>与云计算的天然集成<br><img src="https://img-blog.csdnimg.cn/2020073123000681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<h3><span id="springboot-te-dian">Springboot特点</span><a href="#springboot-te-dian" class="header-anchor">#</a></h3></li>
<li><p>创快速创建一个web工程</p>
</li>
<li><p>内嵌服务器tomcat，打成jar包即可</p>
</li>
<li><p>绝对没有代码生成，也无需 XML 配置</p>
<h2><span id="zai-ideal-zhong-da-jian-springboot-gong-cheng">在ideal中搭建springboot工程</span><a href="#zai-ideal-zhong-da-jian-springboot-gong-cheng" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/20200731232336252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt><br><img src="https://img-blog.csdnimg.cn/20200731232405791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt><br><img src="https://img-blog.csdnimg.cn/20200731232422583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020073123244441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt><br>工程结构图如下：<br><img src="https://img-blog.csdnimg.cn/20200731232555279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<h3><span id="pom-xml-jie-du">pom.xml解读</span><a href="#pom-xml-jie-du" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;!--1.继承一个父工程 starter-parent --&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.3.1.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--2.本工程的信息--&gt;</span><br><span class="line">    &lt;groupId&gt;com.yd&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springboot_01&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;name&gt;springboot_01&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--3.jdk编译版本--&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!--4.依赖坐标--&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--web启动器--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">       </span><br><span class="line">        &lt;!--springboot测试环境--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">            &lt;&#x2F;exclusions&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--测试打包工具--&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>
<p>启动项目<br><img src="https://img-blog.csdnimg.cn/20200731232933769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<h2><span id="springboot-zheng-he-ssm">Springboot整合ssm</span><a href="#springboot-zheng-he-ssm" class="header-anchor">#</a></h2><h3><span id="springmvc-he-mybatis-jian-jie">SpringMvc和Mybatis简介</span><a href="#springmvc-he-mybatis-jian-jie" class="header-anchor">#</a></h3></li>
<li><p>SpringMvc注解介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller @Service  @Repository 实例化类--创建对象，存入spring容器中,分别作用于Controller层、service层、mapper层</span><br><span class="line">@Autowired  从spring容器中取出对象</span><br><span class="line">@RequestMapping 映射请求路径，相当于@WebServlet</span><br><span class="line">@ResponseBody  响应数据给客户端，相当于 response.getWriter().write()</span><br></pre></td></tr></table></figure></li>
<li><p>Mybatis简介<br>MyBatis原本是Apache的一个开源项目iBatis，2010年这个项目由ApacheSoftware Foundation迁移到了Google Code，并且改名为MyBatis，实质上，MyBatis是对iBatis进行的一个完善和升级版本。</p>
<p>MyBatis是一个优秀的持久层框架，是Apache下的顶级项目。它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。</p>
</li>
</ol>
<p>Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。<br>如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;x.x.x&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h3><span id="springboot-zhi-chi-liang-chong-ge-shi-de-pei-zhi-wen-jian-properties-he-yml-ge-shi">SpringBoot支持两种格式的配置文件properties和yml格式.</span><a href="#springboot-zhi-chi-liang-chong-ge-shi-de-pei-zhi-wen-jian-properties-he-yml-ge-shi" class="header-anchor">#</a></h3><ul>
<li>比较两种配置形式,以配置spring数据源为例。</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#application.properties </span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/db</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#application.yml </span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="comment"># mybatis配置</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment">#输出sql</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>
<p>YAML文件格式是Spring Boot支持的一种JSON文件格式，相较于传统的Properties配置文件，YAML文件以数据为核心，是一种更为直观且容易被电脑识别的数据序列化格式。<br>application.yml配置文件的工作原理和application.properties是一样的，只不过yaml格式配置文件看起来更简洁一些。</p>
<p>application.yml文件使用 “key:（空格）value”格式配置属性，使用缩进控制层级关系。</p>
<p>yml文件还支持复杂数据类型，例如数组和集合</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.数组或单列集合类型</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">	<span class="attr">hobby:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">play</span></span><br><span class="line"> 		<span class="bullet">-</span> <span class="string">read</span></span><br><span class="line"> 		<span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">	<span class="attr">hobby:</span></span><br><span class="line"> 		<span class="string">play,</span></span><br><span class="line"> 		<span class="string">read,</span></span><br><span class="line"> 		<span class="string">sleep</span></span><br><span class="line"><span class="comment">#或者如下方式，推荐使用该方式，[]也可以省略 		</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">	<span class="attr">hobby:</span> <span class="string">[play,read,sleep]</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#2.map集合</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">	<span class="attr">map:</span></span><br><span class="line">		<span class="attr">k1:</span> <span class="string">v1</span></span><br><span class="line">		<span class="attr">k2:</span> <span class="string">v2</span></span><br><span class="line"><span class="comment">#或者使用行内方式		</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">	<span class="attr">map:</span> <span class="string">&#123;k1:</span> <span class="string">v1,k2:</span> <span class="string">v2&#125;</span></span><br></pre></td></tr></table></figure>
<h3><span id="gong-cheng-da-jian-bu-zou">工程搭建步骤</span><a href="#gong-cheng-da-jian-bu-zou" class="header-anchor">#</a></h3><p>1.导入依赖（mybatis,jdbc,mysql）<br>2.yml中加入数据源配置<br>3.编写mapper接口和方法<br>4.编写controller和方法<br>5.启动类上添加包扫描注解@MapperScan(“com.hp.mapper”)</p>
<h2><span id="springboot-zheng-he-thymeleaf">SpringBoot整合Thymeleaf</span><a href="#springboot-zheng-he-thymeleaf" class="header-anchor">#</a></h2><h3><span id="thymeleaf-jian-jie">Thymeleaf简介</span><a href="#thymeleaf-jian-jie" class="header-anchor">#</a></h3><p>Thymeleaf是适用于Web和独立环境的现代服务器端Java模板引擎，能够处理HTML，XML，JavaScript，CSS甚至纯文本。<br>Thymeleaf的主要目标是提供一种优雅且高度可维护的模板创建方式。为此，它以自然模板的概念为基础，以不影响模板用作设计原型的方式将其逻辑注入模板文件。这样可以改善设计沟通，并缩小设计团队与开发团队之间的差距。<br>thymeleaf是一个HTML5模板引擎，可用于Web环境中的应用开发。Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式。  </p>
<h3><span id="zheng-he-dao-spring-boot-bu-zou"><strong>整合到Spring boot步骤:</strong></span><a href="#zheng-he-dao-spring-boot-bu-zou" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.pom.xml中添加thymeleaf依赖</span><br><span class="line"></span><br><span class="line">2.application.yml配置文件中关闭thymeleaf缓存</span><br><span class="line"></span><br><span class="line">3.编写controller：1.向model中存值，2.跳转到html页面</span><br><span class="line"></span><br><span class="line">4.编写html,springboot推荐放在resources-&gt;templates包下.</span><br><span class="line">  html标签上加入名称空间 xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot; ,表示该页面是一个thymeleaf模板页面。</span><br><span class="line">  这样就可以在页面上使用th标签取出model中的值，类似于EL表达式。</span><br><span class="line"></span><br><span class="line">5.访问测试</span><br></pre></td></tr></table></figure>
<ul>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="comment">&lt;!--thymeleaf启动器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭thymeleaf缓存</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">在application.yml</span></span><br><span class="line"><span class="comment">#能让改动的页面及时生效，实现类似热部署效果</span></span><br><span class="line"><span class="meta">spring.thymeleaf.cache</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200801000416513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt></p>
<h3><span id="thymeleaf-ji-ben-yu-fa">Thymeleaf基本语法</span><a href="#thymeleaf-ji-ben-yu-fa" class="header-anchor">#</a></h3></li>
<li><p>常用属性</p>
<table>
<thead>
<tr>
<th>th：*属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>th:each</td>
<td>元素遍历（类似JSP中的c:forEach标签）</td>
</tr>
<tr>
<td>th:if</td>
<td>条件判断，如果为真</td>
</tr>
<tr>
<td>th:unless</td>
<td>条件判断，如果为假</td>
</tr>
<tr>
<td>th:value</td>
<td>属性值修改，指定标签属性值</td>
</tr>
<tr>
<td>th:href</td>
<td>用于设定链接地址</td>
</tr>
<tr>
<td>th:src</td>
<td>用于设定链接地址</td>
</tr>
<tr>
<td>th:text</td>
<td>用于指定标签显示的文本内容</td>
</tr>
<tr>
<td>使用步骤：</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<p>1.页面先引入Thymeleaf模板标签：<br>    <html lang="en" xmlns:th="http://www.thymeleaf.org"><br>2.使用Thymeleaf模板的相关标签动态填充页面内容。</html></p>
<ul>
<li><p>标准表达式</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>表达式语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>变量表达式</td>
<td>${…}</td>
<td>主要用于获取域对象中的变量值，类似EL表达式</td>
</tr>
<tr>
<td>链接URL表达式</td>
<td>@{…}</td>
<td>用于 th:src 和 th:href,th:action属性中</td>
</tr>
<tr>
<td>片段表达式</td>
<td>~{…}</td>
<td>使用th:insert或th:replace属性插入片段</td>
</tr>
<tr>
<td>例子：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>编写controller</td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class ThController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;thymeleaf&quot;)</span><br><span class="line">    public String HelloThymeleaf(Model model)&#123;</span><br><span class="line">        &#x2F;&#x2F;向model中存值</span><br><span class="line">        model.addAttribute(&quot;name&quot;,&quot;刘备&quot;);</span><br><span class="line">        model.addAttribute(&quot;age&quot;,&quot;18&quot;);</span><br><span class="line">        &#x2F;&#x2F;跳转到helloThymeleaf.html</span><br><span class="line">        return &quot;Thymeleaf&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thymeleaf.html页面</td>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot; xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p th:text&#x3D;&quot;&#39;我叫&#39;+$&#123;name&#125;+&#39;,今年&#39;+$&#123;age&#125;+&#39;岁了。&#39;&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--$&#123;&#125;只能独立的出现在th开头的属性值中，th:属性&#x3D;&quot;$&#123;&#125;&quot;--&gt;</span><br><span class="line">&lt;p&gt;我叫 &lt;span th:text&#x3D;&quot;$&#123;name&#125;&quot;&gt;&lt;&#x2F;span&gt;,今年 &lt;span th:text&#x3D;&quot;$&#123;age&#125;&quot;&gt;&lt;&#x2F;span&gt;岁了&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></td>
<td></td>
<td></td>
</tr>
<tr>
<td>src示例：</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>&lt;img th:src=”@{/img/research/{filename}(filename=${research.filename})}”&gt;</p>
</blockquote>
</li>
</ul>
<p>href示例：</p>
<pre><code>&lt;a th:href=&quot;@{&apos;https://&apos;+${url.url}}&quot; th:text=&quot;${url.urlName}&quot;&gt;&lt;/a&gt;</code></pre><p>th:each示例<br>对象遍历，功能类似jstl中的 &lt;c:forEach&gt; 标签</p>
<ul>
<li><p>controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">users</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">       <span class="comment">//list集合数据</span></span><br><span class="line">      List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">      users.add(<span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">"张三"</span>,<span class="string">"纽约"</span>));</span><br><span class="line">      users.add(<span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">"李四"</span>,<span class="string">"上海"</span>));</span><br><span class="line">      users.add(<span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">"王五"</span>,<span class="string">"伦敦"</span>));</span><br><span class="line">      model.addAttribute(<span class="string">"users"</span>,users);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//Map集合数据</span></span><br><span class="line">      Map&lt;String,Object&gt; dataMap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">      dataMap.put(<span class="string">"No"</span>,<span class="string">"123"</span>);</span><br><span class="line">      dataMap.put(<span class="string">"address"</span>,<span class="string">"深圳"</span>);</span><br><span class="line">      model.addAttribute(<span class="string">"dataMap"</span>,dataMap); </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> <span class="string">"helloThymeleaf"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>下标<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>住址<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"user:$&#123;users&#125;"</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!--user后加Stat表示状态变量--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;userStat.index&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.id&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.name&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.address&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:each</span>=<span class="string">"entry:$&#123;dataMap&#125;"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;entry&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;entry.key&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>:</span><br><span class="line">         <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;entry.value&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>/&gt;</span> </span><br><span class="line">         ==============================================</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>常用的时间格式化:</p>
</li>
<li><p>controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">model.addAttribute(<span class="string">"now"</span>,<span class="keyword">new</span> Date());</span><br></pre></td></tr></table></figure>
</li>
<li><p>html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.format(now,'yyyy-MM-dd HH:ss:mm')&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中的#dates是thymeleaf的内置工具对象。</p>
</li>
</ul>
<p><strong>在新建实体类时我们可以引入lombok这样就不需要setter,gettter,tostring方法</strong><br>使用步骤如下：<br>1.导入依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;!--lombok--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>2.IDea中安装lombok插件<br>3.在实体类上添加@Data注解</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JS中的BOM与DOM</title>
    <url>/2020/08/01/%E5%85%B3%E4%BA%8EJS%E4%B8%AD%E7%9A%84BOM%E4%B8%8EDOM/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#bom-jian-jie">BOM简介</a></li>
<li><a href="#bom-de-gou-cheng-bu-fen">BOM的构成部分</a><ul>
<li><a href="#1-window-dui-xiang">1.window对象</a></li>
<li><a href="#2-location-dui-xiang">2.location对象</a></li>
<li><a href="#3-history-dui-xiang">3.history对象</a></li>
<li><a href="#screen-dui-xiang">screen 对象</a></li>
<li><a href="#navigator-dui-xiang">navigator对象</a></li>
</ul>
</li>
<li><a href="#dom-jian-jie">DOM简介</a></li>
<li><a href="#dom-jie-gou-tu">DOM结构图</a></li>
<li><a href="#san-dom-chang-yong-dui-xiang-de-shi-yong">三、DOM常用对象的使用</a><ul>
<li><a href="#1-document-wen-dang-dui-xiang">1.Document文档对象</a></li>
<li><a href="#node-jie-dian-dui-xiang">node节点对象</a></li>
<li><a href="#element-dui-xiang">element对象</a></li>
</ul>
</li>
<li><a href="#chang-yong-shi-jian">常用事件</a></li>
</ul>
<!-- tocstop -->

</div>

<a id="more"></a>

<h2><span id="bom-jian-jie">BOM简介</span><a href="#bom-jian-jie" class="header-anchor">#</a></h2><p>Browser Object Model 是浏览器对象模型，浏览器对象模型提供了独立与内容的、可以与浏览器窗口进行互动的对象结构，BOM由多个对象构成，其中代表浏览器窗口的window对象是BOM的顶层对象，其他对象都是该对象的子对象。是JS访问浏览器窗口的一个接口。</p>
<h2><span id="bom-de-gou-cheng-bu-fen">BOM的构成部分</span><a href="#bom-de-gou-cheng-bu-fen" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/20200720215252144.png" alt></p>
<h3><span id="1-window-dui-xiang">1.window对象</span><a href="#1-window-dui-xiang" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">无需创建，直接使用</span><br><span class="line">1.弹框方法：</span><br><span class="line"> 	1.alert();   --警告框： 弹框页面只有一个确定按钮</span><br><span class="line"> 	2.confirm(); -- 确认框：弹框页面有一个确定按钮，一个取消按钮</span><br><span class="line"> 	3.prompt(); -- 输入框： 弹框页面有一个提示信息和输入框，还有一个确定按钮，一个取消按钮</span><br><span class="line"> </span><br><span class="line">2.打开和关闭窗口的方法：</span><br><span class="line">	1.open();  开启一个新的窗口 ，参数就是 新窗口的url，返回值就是一个新窗口对象</span><br><span class="line">			可以设置第三个参数，设置窗口的宽和高 <span class="string">"width=300px,height=300px"</span></span><br><span class="line">	2.close(); 关闭窗口，什么窗口对象调用该方法，就关闭什么窗口</span><br><span class="line">	</span><br><span class="line">3.定时器方法</span><br><span class="line">   1.setTimeOut(参数1，参数2):一次性定时器，</span><br><span class="line">   			参数1：js代码或函数名  参数2：毫秒数</span><br><span class="line">   			返回值 就是当前这个定时器的编号id</span><br><span class="line">   2.clearTimeOut(参数); 取消一次性定时器</span><br><span class="line">   			参数：某个一次性定时器的返回编号id</span><br><span class="line">   			</span><br><span class="line">   3.setInterval(参数1，参数2): 循环定时器</span><br><span class="line">  			参数1：js代码或函数名  参数2：毫秒数</span><br><span class="line">  			返回值 就是当前这个定时器的编号id</span><br><span class="line">   4.clearInterval(参数); 取消循环定时器	</span><br><span class="line">   			参数：某个循环定时器的返回编号id</span><br><span class="line">   			</span><br><span class="line">注意： setInterval(fun1,3000);			</span><br><span class="line">	  setInterval(<span class="string">"fun1()"</span>,3000);////全局作用域下正常执行</span><br><span class="line">      </span><br><span class="line">4.获取子对象</span><br><span class="line">	window.document;  -- dom</span><br><span class="line">	window.location;  -- bom	地址栏对象</span><br><span class="line">	window.history;   -- bom	浏览记录对象</span><br><span class="line">	window.navigator; -- bom	浏览器对象</span><br><span class="line">	window.screen;    -- bom	显示器屏幕对象</span><br><span class="line">	</span><br><span class="line"> // 不允许别人嵌套网页,防盗链</span><br><span class="line">        onload=<span class="function"><span class="title">function</span></span>()&#123;<span class="keyword">if</span>(window.self!=top) document.body.style.display=<span class="string">"none"</span>&#125;;</span><br><span class="line">        onload=<span class="function"><span class="title">function</span></span>()&#123;<span class="keyword">if</span>(window.self!=top) top.location=location&#125;;</span><br></pre></td></tr></table></figure>
<h3><span id="2-location-dui-xiang">2.location对象</span><a href="#2-location-dui-xiang" class="header-anchor">#</a></h3><p>表示网页的地址栏<br>方法：<br>    reload(); – 重新载入当前页面， 刷新网页<br>    assign(); – 载入一个新页面 ，跳转到其它页面 – 超链接也有该功能<br>属性：<br>    href – location.href=”url网址”; – 超链接也有该功能    </p>
<ul>
<li><p>案例–自动跳转首页</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;自动跳转首页&lt;&#x2F;title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"> p&#123;</span><br><span class="line">	text-align : center;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> span&#123;</span><br><span class="line">	color:red;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;time&quot;&gt;5&lt;&#x2F;span&gt;秒之后,自动跳转首页...</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F;获取倒计时秒数</span><br><span class="line">    var time &#x3D; document.getElementById(&quot;time&quot;);</span><br><span class="line">    var second &#x3D; 5;</span><br><span class="line">    function showTime()&#123;</span><br><span class="line">		second -- ;</span><br><span class="line">        if(second &lt;&#x3D; 0)&#123;</span><br><span class="line">            &#x2F;&#x2F;时间到了，跳转首页</span><br><span class="line">            location.href &#x3D; &quot;https:&#x2F;&#x2F;www.baidu.com&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">		&#x2F;&#x2F;把当前秒数放在span标签内容中显示</span><br><span class="line">        time.innerHTML &#x3D; second;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;&#x2F;设置定时器 -- 每一秒执行一个showTime函数</span><br><span class="line">    setInterval(showTime,1000);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3><span id="3-history-dui-xiang">3.history对象</span><a href="#3-history-dui-xiang" class="header-anchor">#</a></h3><p>记录并存储当前窗口的浏览的历史记录<br>方法：<br>  history.back();– 后退一页<br>  history.forward();– 前进一页<br>  history.go(参数);</p>
<pre><code>参数：1 相当于forward()
参数：-1 相当于back()</code></pre><h3><span id="screen-dui-xiang">screen 对象</span><a href="#screen-dui-xiang" class="header-anchor">#</a></h3><p>screen.availHeight //屏幕实际高度<br>screen.availWidth //屏幕实际宽度<br>screen.height //屏幕高度<br>screen.width //屏幕宽度　</p>
<h3><span id="navigator-dui-xiang">navigator对象</span><a href="#navigator-dui-xiang" class="header-anchor">#</a></h3><p>//判断用户浏览器的类型<br>console.log(window.navigator.userAgent);<br>//判断浏览器所在的系统平台<br>console.log(window.navigator.platform);</p>
<h2><span id="dom-jian-jie">DOM简介</span><a href="#dom-jian-jie" class="header-anchor">#</a></h2><p>Document Object Model 文档对象模型， 把文档抽象成对象的形式，对象给我们提供了属性和方法用来处理可标记语言，DOM是一种基于树形的结构</p>
<p>DOM定义了表示和修改文档所需的方法。</p>
</li>
</ul>
<p>DOM对象即为宿主对象，由浏览器厂商定义，用来操作html和xml功能的一类对象的集合，也有人称DOM是对HTML和XML的标准编程接口。</p>
<p>DOM修改不了CSS样式表，只能通过间接的方式修改HTML中的行间样式。</p>
<h2><span id="dom-jie-gou-tu">DOM结构图</span><a href="#dom-jie-gou-tu" class="header-anchor">#</a></h2><p><img src="https://img-blog.csdnimg.cn/20200720225937771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTEyNDQ4,size_16,color_FFFFFF,t_70" alt><br>文档： 一个网页可以称为文档<br>节点： 网页中所有内容都是节点（标签、 属性、 文本、 注释等）<br>元素： 网页中的标签<br>属性： 标签中的属性</p>
<p>DOM经常进行的操作</p>
<ol>
<li>获取元素</li>
<li>对元素进行操作（设置其属性或调用其方法）</li>
<li>动态创建元素</li>
<li>事件（什么时候做相应的操作）<h2><span id="san-dom-chang-yong-dui-xiang-de-shi-yong">三、DOM常用对象的使用</span><a href="#san-dom-chang-yong-dui-xiang-de-shi-yong" class="header-anchor">#</a></h2><h3><span id="1-document-wen-dang-dui-xiang">1.Document文档对象</span><a href="#1-document-wen-dang-dui-xiang" class="header-anchor">#</a></h3></li>
<li>直接访问文档中的节点对象：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementsById(&quot;id&quot;); 通过 id 属性获取节点对象</span><br><span class="line">document.getElementsByName(&quot;name&quot;); 通过 name 属性获取节点对象</span><br><span class="line">document&#x2F;element.getElementsByTagName(&quot;tag&quot;); 通过 tag 属性获取节点对象</span><br><span class="line">document&#x2F;element.getElementsByClassName(&quot;class1[ class2]&quot;); 通过 class 属性获取节点对象</span><br><span class="line">document&#x2F;element.querySelector(&quot;selector&quot;); 通过 css 选择器 获取首个节点对象</span><br><span class="line">document&#x2F;element.querySelectorAll(&quot;selector&quot;); 通过 css 选择器 获取所有节点对象</span><br></pre></td></tr></table></figure>
其中第一个最常用。</li>
<li>改变属性值 / 改变文本内容</li>
</ol>
<p>img –&gt; src<br>h1 –&gt;innerHTML</p>
<h3><span id="node-jie-dian-dui-xiang">node节点对象</span><a href="#node-jie-dian-dui-xiang" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父节点(parent node)</span><br><span class="line"></span><br><span class="line">parentNode&#x2F;parentElement 获取所属父节点对象</span><br><span class="line">ownerDocument 获取节点所属文档节点（根节点）对象</span><br><span class="line"></span><br><span class="line">兄弟节点(sibling nodes)</span><br><span class="line"></span><br><span class="line">nextSibling 获取前一个兄弟节点对象</span><br><span class="line">nextElementSibling 获取前一个兄弟元素节点对象</span><br><span class="line">previousSibling 获取后一个兄弟节点对象</span><br><span class="line">previousElementSibling 获取后一个兄弟元素节点对象</span><br><span class="line"></span><br><span class="line">子节点(child nodes)</span><br><span class="line"></span><br><span class="line">childNodes 获取所有子节点对象</span><br><span class="line">children 获取所有子元素节点对象</span><br><span class="line">hasChildNodes(); 判断是否包含子节点对象</span><br><span class="line">childElementCount 获取子元素节点对象数量</span><br><span class="line">firstChild 获取第一个子节点对象</span><br><span class="line">firstElementChild 获取第一个子元素节点对象</span><br><span class="line">lastChild 获取最后一个子节点对象</span><br><span class="line">lastElementChild 获取最后一个子元素节点对象</span><br></pre></td></tr></table></figure>
<p>操作节点对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建节点</span><br><span class="line"></span><br><span class="line">document.createElement(&quot;TAG&quot;); 创建一个元素节点</span><br><span class="line">document.createTextNode(&quot;#文本&quot;); 创建一个文本节点</span><br><span class="line">document.createComment(&quot;#注释&quot;); 创建一个注释节点</span><br><span class="line">document.createDocumentFragment(); 创建一个空白的文档片段节点</span><br><span class="line"></span><br><span class="line">插入节点</span><br><span class="line"></span><br><span class="line">parentNode.appendChild(newChild); 插入子节点（作为最后一个子节点）</span><br><span class="line">parentNode.insertBefore(newChild,refChild); 插入子节点（在指定子节点之前）</span><br><span class="line"></span><br><span class="line">删除节点</span><br><span class="line"></span><br><span class="line">parentNode.removeChild(oldChild); 删除指定的子节点</span><br><span class="line"></span><br><span class="line">替换节点</span><br><span class="line"></span><br><span class="line">parentNode.replaceChild(newChild,oldChild); 替换一个子节点</span><br><span class="line"></span><br><span class="line">克隆节点</span><br><span class="line"></span><br><span class="line">node.cloneNode(deep); 克隆一个节点</span><br></pre></td></tr></table></figure>
<h3><span id="element-dui-xiang">element对象</span><a href="#element-dui-xiang" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.设置属性：</span><br><span class="line">    1.setAttribute(参数1，参数2); --给某个元素设置某个属性，参数1：属性名  参数2：属性值</span><br><span class="line">    2.removeAttribute(参数);     --移除元素的某个属性，参数：属性名</span><br><span class="line"></span><br><span class="line">e.特性名称&#x3D;&quot;value&quot;; 获取&#x2F;设置特性值</span><br><span class="line">e.getAttributeNames()； 获取已设置的全部属性名称（非IE内核）</span><br><span class="line">e.getAttribute(&quot;特性名称&quot;); 获取特性值</span><br><span class="line">e.getAttributeNode(&quot;特性名称&quot;); 获取特性节点[特性名称&#x3D;特性值]</span><br><span class="line">e.setAttribute(&quot;特性名称&quot;,&quot;特性值&quot;); 设置特性值（不存在时新建该属性）</span><br><span class="line"></span><br><span class="line">2.操作节点对象的样式属性</span><br><span class="line"></span><br><span class="line">e.style.color[ &#x3D;&quot;颜色值&quot;]; 获取&#x2F;设置标签内样式（内嵌样式）</span><br><span class="line">window.getComputedStyle(e).color; 获取包括内嵌样式、&lt;style&gt;、&lt;link&gt;在内的最终样式（非IE内核 或 IE&gt;8）</span><br><span class="line">e.currentStyle.color; 获取包括内嵌样式、&lt;style&gt;、&lt;link&gt;在内的最终样式（IE内核）</span><br><span class="line"></span><br><span class="line">提前在head标签中定义style标签，将固定的样式显示写好。</span><br><span class="line">  在去获取某个元素对象，元素对象.calssName&#x3D;&quot;样式名&quot;;</span><br></pre></td></tr></table></figure>
<h2><span id="chang-yong-shi-jian">常用事件</span><a href="#chang-yong-shi-jian" class="header-anchor">#</a></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 点击事件：</span><br><span class="line">		1. onclick：单击事件</span><br><span class="line">		2. ondblclick：双击事件</span><br><span class="line">	2. 焦点事件</span><br><span class="line">		1. onblur：失去焦点</span><br><span class="line">		2. onfocus:元素获得焦点。</span><br><span class="line"></span><br><span class="line">	3. 加载事件：</span><br><span class="line">		1. onload：一张页面或一幅图像完成加载。</span><br><span class="line"></span><br><span class="line">	4. 鼠标事件：</span><br><span class="line">		1. onmousedown	鼠标按钮被按下。</span><br><span class="line">		2. onmouseup	鼠标按键被松开。</span><br><span class="line">		3. onmousemove	鼠标被移动。</span><br><span class="line">		4. onmouseover	鼠标移到某元素之上。</span><br><span class="line">		5. onmouseout	鼠标从某元素移开。</span><br><span class="line">	5. 键盘事件：</span><br><span class="line">		1. onkeydown	某个键盘按键被按下。	</span><br><span class="line">		2. onkeyup		某个键盘按键被松开。</span><br><span class="line">		3. onkeypress	某个键盘按键被按下并松开。</span><br><span class="line">	6. 选择和改变</span><br><span class="line">		1. onchange	域的内容被改变。</span><br><span class="line">		2. onselect	文本被选中。</span><br><span class="line">	7. 表单事件：</span><br><span class="line">		1. onsubmit	确认按钮被点击。</span><br><span class="line">		2. onreset	重置按钮被点击。</span><br></pre></td></tr></table></figure>
<p>最后演示一个实例：动态表格添加和删除功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;动态表格&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        table&#123;</span></span><br><span class="line"><span class="regexp">            border: 1px solid;</span></span><br><span class="line"><span class="regexp">            width: 600px;</span></span><br><span class="line"><span class="regexp">            border-collapse: collapse;</span></span><br><span class="line"><span class="regexp">            margin: auto;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        th,td,tr&#123;</span></span><br><span class="line"><span class="regexp">            text-align: center;</span></span><br><span class="line"><span class="regexp">            padding: 15px;</span></span><br><span class="line"><span class="regexp">            border:1px solid;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        div&#123;</span></span><br><span class="line"><span class="regexp">            text-align: center;</span></span><br><span class="line"><span class="regexp">            margin: 70px;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">&lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;input type="text" id="id" value="" placeholder="请输入编号"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;input type="text" id="name" value="" placeholder="请输入姓名"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;input type="text" id="gender" value="" placeholder="请输入性别"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;input type="button" value="添加" id="add"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;table id=<span class="string">"table"</span>&gt;</span><br><span class="line">        &lt;caption&gt;学生信息表&lt;<span class="regexp">/caption&gt;</span></span><br><span class="line"><span class="regexp">        &lt;tr&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th&gt;编号&lt;/</span>th&gt;</span><br><span class="line">            &lt;th&gt;姓名&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">            &lt;th&gt;性别&lt;/</span>th&gt;</span><br><span class="line">            &lt;th&gt;操作&lt;<span class="regexp">/th&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;<span class="number">1</span>&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">            &lt;td&gt;令狐冲&lt;/</span>td&gt;</span><br><span class="line">            &lt;td&gt;男&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">            &lt;td&gt;&lt;a href="#" onclick="del(this)"&gt;删除&lt;/</span>a&gt;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;<span class="number">2</span>&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">            &lt;td&gt;任我行&lt;/</span>td&gt;</span><br><span class="line">            &lt;td&gt;男&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">            &lt;td&gt;&lt;a href="javascript:void(0)" onclick="del(this)"&gt;删除&lt;/</span>a&gt;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;<span class="number">3</span>&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">            &lt;td&gt;岳不群&lt;/</span>td&gt;</span><br><span class="line">            &lt;td&gt;?&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">            &lt;td&gt;&lt;a href="javascript:void(0)" onclick="del()"&gt;删除&lt;/</span>a&gt;&lt;<span class="regexp">/td&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>tr&gt;</span><br><span class="line">    &lt;<span class="regexp">/table&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> table = <span class="built_in">document</span>.getElementById(<span class="string">"table"</span>);</span><br><span class="line">    <span class="comment">//1.给添加按钮绑定点击事件</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"add"</span>).onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//2.获取编号值</span></span><br><span class="line">        <span class="keyword">var</span> id = <span class="built_in">document</span>.getElementById(<span class="string">"id"</span>).value;</span><br><span class="line">        <span class="keyword">var</span> name=<span class="built_in">document</span>.getElementById(<span class="string">'name'</span>).value;</span><br><span class="line">        <span class="keyword">var</span> gender=<span class="built_in">document</span>.getElementById(<span class="string">'gender'</span>).value;</span><br><span class="line">        <span class="comment">//3.创建一个文本节点</span></span><br><span class="line">        <span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(id);</span><br><span class="line">        <span class="keyword">var</span> text1 = <span class="built_in">document</span>.createTextNode(name);</span><br><span class="line">        <span class="keyword">var</span> text2 = <span class="built_in">document</span>.createTextNode(gender);</span><br><span class="line">        <span class="comment">//4.创建一个td元素对象</span></span><br><span class="line">        <span class="keyword">var</span> td = <span class="built_in">document</span>.createElement(<span class="string">"td"</span>);</span><br><span class="line">        <span class="keyword">var</span> td1 = <span class="built_in">document</span>.createElement(<span class="string">"td"</span>);</span><br><span class="line">        <span class="keyword">var</span> td2 = <span class="built_in">document</span>.createElement(<span class="string">"td"</span>);</span><br><span class="line">        <span class="keyword">var</span> td3 = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">        td3.text=<span class="string">"删除"</span>;</span><br><span class="line">         td3.href=<span class="string">"#"</span>;</span><br><span class="line">         td3.onclick=del1;</span><br><span class="line">        <span class="comment">// a.setAttribute("onclick","delTr(this)");</span></span><br><span class="line">        <span class="comment">//5.创建一个tr元素对象</span></span><br><span class="line">        <span class="keyword">var</span> tr = <span class="built_in">document</span>.createElement(<span class="string">"tr"</span>);</span><br><span class="line">        <span class="comment">//6.将text放进td中，td放进tr中，tr放进table中</span></span><br><span class="line">        td.appendChild(text);</span><br><span class="line">        td1.appendChild(text1);</span><br><span class="line">        td2.appendChild(text2);</span><br><span class="line">        tr.appendChild(td);</span><br><span class="line">        tr.appendChild(td1);</span><br><span class="line">        tr.appendChild(td2);</span><br><span class="line">        tr.appendChild(td3);</span><br><span class="line">        table.appendChild(tr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除 table.removeChild(tr);</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tr=<span class="keyword">this</span>.parentNode.parentNode;</span><br><span class="line">        <span class="keyword">var</span> table=<span class="keyword">this</span>.parentNode.parentNode.parentNode;</span><br><span class="line">        table.removeChild(tr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">del1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tr=<span class="keyword">this</span>.parentNode;</span><br><span class="line">        <span class="keyword">var</span> table=<span class="keyword">this</span>.parentNode.parentNode;</span><br><span class="line">        table.removeChild(tr);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面这种方法有点复杂了，还可以用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;id&quot; placeholder&#x3D;&quot;请输入编号&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot;  placeholder&#x3D;&quot;请输入姓名&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;gender&quot;  placeholder&#x3D;&quot;请输入性别&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;添加&quot; id&#x3D;&quot;btn_add&quot;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;table id&#x3D;&quot;table&quot;&gt;</span><br><span class="line">    &lt;caption&gt;学生信息表&lt;&#x2F;caption&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;编号&lt;&#x2F;th&gt;</span><br><span class="line">        &lt;th&gt;姓名&lt;&#x2F;th&gt;</span><br><span class="line">        &lt;th&gt;性别&lt;&#x2F;th&gt;</span><br><span class="line">        &lt;th&gt;操作&lt;&#x2F;th&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;1&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;小明&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;男&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;&lt;a href&#x3D;&quot;javascript:void(0);&quot; onclick&#x3D;&quot;delTr(this);&quot;&gt;删除&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F;使用innerHTML添加</span><br><span class="line">    document.getElementById(&quot;btn_add&quot;).onclick &#x3D; function() &#123;</span><br><span class="line">        &#x2F;&#x2F;2.获取文本框的内容</span><br><span class="line">        var id &#x3D; document.getElementById(&quot;id&quot;).value;</span><br><span class="line">        var name &#x3D; document.getElementById(&quot;name&quot;).value;</span><br><span class="line">        var gender &#x3D; document.getElementById(&quot;gender&quot;).value;</span><br><span class="line"></span><br><span class="line">        var table&#x3D;document.getElementById(&quot;table&quot;);</span><br><span class="line">        var count&#x3D;table.rows.length;</span><br><span class="line">        var str&#x3D;table.insertRow(count);</span><br><span class="line">        str.innerHTML&#x3D;&#39;&lt;td&gt;&#39;+id+&#39;&lt;&#x2F;td&gt;&lt;td&gt;&#39;+name+&#39;&lt;&#x2F;td&gt;&lt;td&gt;&#39;+gender+&#39;&lt;&#x2F;td&gt;&lt;td&gt;&lt;a href&#x3D;&quot;javascript:void(0)&quot; onclick&#x3D;&quot;delTr(this)&quot;&gt;delete&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;删除方法</span><br><span class="line">    function delTr(obj)&#123;</span><br><span class="line">        var table &#x3D; obj.parentNode.parentNode.parentNode;</span><br><span class="line">        var tr &#x3D; obj.parentNode.parentNode;</span><br><span class="line">        table.removeChild(tr);</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>元胞自动机</title>
    <url>/2021/02/10/%E5%85%83%E8%83%9E%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#yuan-bao-zi-dong-ji">元胞自动机</a><ul>
<li><a href="#gai-nian">概念</a></li>
<li><a href="#jiang-suo-you-yuan-bao-zi-dong-ji-de-dong-li-xue-xing-wei-gui-na-wei-si-da-lei-wolfram-s-1986">将所有元胞自动机的动力学行为归纳为四大类（Wolfram. S.，1986):</a></li>
<li><a href="#chu-deng-yuan-bao-zi-dong-ji-elementary-cellular-automata-eca-de-ji-ben-yao-su-ru-xia">初等元胞自动机（ Elementary Cellular Automata， ECA)的基本要素如下：</a></li>
<li><a href="#te-zheng">特征</a></li>
<li><a href="#184-hao-mo-xing">184号模型</a></li>
<li><a href="#nasch-mo-xing">NaSch模型</a></li>
<li><a href="#python-shi-xian-zui-jian-dan-de-yuan-bao-zi-dong-ji">Python 实现最简单的元胞自动机</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h2><span id="yuan-bao-zi-dong-ji">元胞自动机</span><a href="#yuan-bao-zi-dong-ji" class="header-anchor">#</a></h2><p>元胞自动机（ Cellular Automata） 是 20 世纪 50 年代初由计算机之父冯·诺依曼为了模拟生命系统所具有的自复制功能而提出来的网格动力学模型。</p>
<a id="more"></a>

<h3><span id="gai-nian">概念</span><a href="#gai-nian" class="header-anchor">#</a></h3><p><strong>元胞自动机采用离散的空间布局和离散的时间间隔，将元胞分成有限种状态，元胞个体状态的演变仅与其当前状态以及其某个局部邻域的状态有关。</strong></p>
<h3><span id="jiang-suo-you-yuan-bao-zi-dong-ji-de-dong-li-xue-xing-wei-gui-na-wei-si-da-lei-wolfram-s-1986">将所有元胞自动机的动力学行为归纳为四大类（Wolfram. S.，1986):</span><a href="#jiang-suo-you-yuan-bao-zi-dong-ji-de-dong-li-xue-xing-wei-gui-na-wei-si-da-lei-wolfram-s-1986" class="header-anchor">#</a></h3><p>⑴ 平稳型:自任何初始状态开始，经过一定时间运行后，元胞空间趋于一个空间平稳的构形，这里空间平稳即指每一个元胞处于固定状态。不随时间变化而变化。</p>
<p>⑵ 周期型：经过一定时间运行后，元胞空间趋于一系列简单的固定结构（Stable Patterns）或周期结构（Perlodical Patterns)。由于这些结构可看作是一种滤波器（Filter），故可应用到图像处理的研究中。</p>
<p>⑶ 混沌型：自任何初始状态开始，经过一定时间运行后，元胞自动机表现出混沌的非周期行为，所生成的结构的统计特征不再变止，通常表现为分形分维特征。</p>
<p>⑷ 复杂型：出现复杂的局部结构，或者说是局部的混沌，其中有些会不断地传播。</p>
<h3><span id="chu-deng-yuan-bao-zi-dong-ji-elementary-cellular-automata-eca-de-ji-ben-yao-su-ru-xia">初等元胞自动机（ Elementary Cellular Automata， ECA)的基本要素如下：</span><a href="#chu-deng-yuan-bao-zi-dong-ji-elementary-cellular-automata-eca-de-ji-ben-yao-su-ru-xia" class="header-anchor">#</a></h3><ul>
<li>元胞空间：元胞在空间分布的空间格点的集合，如一维直线上等间距的点。可为某区间上的整数点的集合。二维的元胞自动机通常有三种划分方式（三角形、正方形、正六边形）</li>
</ul>
<table>
<thead>
<tr>
<th>网格类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>三角形</td>
<td>拥有相对较少的邻居数目，易于处理复杂边界</td>
<td>在计算机的表达与显示不方便，需要转换为四方网格</td>
</tr>
<tr>
<td>正方形</td>
<td>直观简单，而且适合于在现有计算机环境下进行表达显示</td>
<td>不能较好地模拟各向同性的现象</td>
</tr>
<tr>
<td>正六边形</td>
<td>能够较好地模拟各向同性的现象，因此，模型更更加自然而真实</td>
<td>在表达显示上较为困难、复杂</td>
</tr>
<tr>
<td>元胞空间的边界条件</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>理论上，元胞空间是无限的，实际应用中无法达到这一理想条件。常用的边界条件有以下几种：周期型、定值型、绝热型、反射型</p>
<ol>
<li><p>周期型边界条件(Periodic Boundary)<br>是指相对边界连接起来的元胞空间，对于一维空间，首尾相接形成一个圆环；<br>对于二维空间，上下相接、左右相接，形成一个拓扑圆环面，形似车胎<br><img src="https://img-blog.csdnimg.cn/img_convert/5e3397e94b69cfa5497f013c55babb73.png" alt="20201026203011"></p>
</li>
<li><p>定值型边界条件(Constant Boundary)<br>所有边界外元胞均取某一固定常量<br><img src="https://img-blog.csdnimg.cn/img_convert/329594b564f8c47d295857c7347c6477.png" alt="20201026203024"></p>
</li>
<li><p>绝热型边界条件(Adiabatic Boundary)<br>在指边界外邻居元胞的状态始终和边界元胞的状态保持一致，即具有状态的零梯度。<img src="https://img-blog.csdnimg.cn/img_convert/5bcbfc8ebeba09a634b653b0dce64bbb.png" alt="20201026203036"></p>
</li>
<li><p>反射型边界条件(Constant Boundary)<br>在边界外邻居的元胞状态是以边界元胞为轴的镜面反射<br><img src="https://img-blog.csdnimg.cn/img_convert/93a86e66787be6d876cbd94352df1446.png" alt="20201026214406"></p>
</li>
</ol>
<ul>
<li>状态集：S={s1,s2} 即只有两种不同的状态。这两种不同的状态可将其分别编码为0 与 1；若用图形表示，则可对应“黑”与“白” 或者其他两种不同的颜色。</li>
<li>邻居：若一维邻居半径r=1，即每个元胞最多只有“左邻右舍”两个邻居。</li>
</ul>
<ol>
<li>冯诺依曼型<br>邻居数目=2d</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4c1609fe11627a3c94315dc7ef91dcd8.png" alt="20201026202842"><br>2. 摩尔型<br>邻居数目=3^d-1<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-zK0qkYQ5-1604564226207)(<a href="https://i.loli.net/2020/10/26/IO2TqoRk316LJpH.png)]" target="_blank" rel="noopener">https://i.loli.net/2020/10/26/IO2TqoRk316LJpH.png)]</a><br>3. 扩展摩尔型<br>邻居数目=(2r+1)^d-1<br><img src="https://img-blog.csdnimg.cn/img_convert/6c1aedb0704ad83f749e294b0903781f.png" alt="20201026202932"><br>4. 马格勒斯型(Margolus)<br>主要区别：以2*2的元胞块为单元进行处理，而不是单独处理<br>主要应用领域：格子气流体、颗粒流</p>
<ul>
<li>演化规则：任意设定， 最多2^8=256种不同的设定方式。元胞以相邻的8个元胞为邻居。即Moore邻居；一个元胞的生死由其在该时刻本身的生死状态和周围八个邻居的状态决定。根据元胞及其邻居元胞的状态，决定下一时刻该元胞状态的动力学函数，也可以是状态转移方程或局部映射。</li>
</ul>
<p>从数学上来定义，有限自动机是一个五元组:</p>
<p>FA=(Q，S，δ，q0，F)</p>
<pre><code>其中，Q是控制器的有限状态集、S是输入符号约有限集、δ是控制状态转移规律的Q×S到Q的映射 (可用状态转移图或状态转移表表示)，q0是初始状态、F是终止状态集。若δ是单值映射，则称M为确定性有限自动机;若δ是多值映射，则称M为非确定性 有限自动机。</code></pre><h3><span id="te-zheng">特征</span><a href="#te-zheng" class="header-anchor">#</a></h3><p>（1）同质性、齐性：同质性反映在元胞空间内的每个元胞都服从相同的规则；齐性指的是元胞的分布方式相同，大小形状相同，空间分布整齐。</p>
<p>（2）空间离散：元胞分布在按一定规则划分的离散的元胞空间上。</p>
<p>（3）时间离散：系统的演化是按等时间间隔分步进行的。t时刻的状态只对t+1时刻的状态产生影响。</p>
<p>（4）状态离散、有限：元胞自动机的状态参量只能取有限个离散值。</p>
<p>（5）同步计算（并行性）：元胞自动机的处理是同步进行的。</p>
<p>（6）时空局域性：每个元胞在t+1时刻的状态，取决于其邻居的元胞在t时刻的状态。</p>
<p>（7）维数高：动力系统中一般将变量的个数成为维数。任何完备元胞自动机的元胞空间是在空间上的无穷集，每个元胞的状态是这个动力学系统的变量，因此元胞自动机是一类无穷维动力系统。</p>
<p>应用：<br><strong>生物学领域</strong></p>
<p>肿瘤细胞的增长机理和过程模拟<br>人类大脑的机理探索<br>艾滋病病毒HIV的感染过程<br>自组织、自繁殖等生命现象的研究<br>克隆技术<br>模拟植物的生长<br>贝壳上色素的沉积图案<br><strong>生态学领域</strong></p>
<p>生态系统动态变化过程的模拟<br>蚂蚁的行走路线，大雁、鱼类洄游动物的群体行为的模拟<br>生物群落的扩散模拟</p>
<p><strong>物理学模拟</strong></p>
<p>LGA 格子气自动机<br>LBM格子-玻尔兹曼法<br>流体领域，在多孔介质、多相流、微小尺寸具有独特的优越性<br>LBM同样被成功用于磁场、电场、热扩散、热传导的模拟<br>雪花等枝晶的形成<br>液态金属材料的凝固结晶过程<br>颗粒材料的垮塌现象<br><strong>交通科学领域</strong><br>两条主线：<br>1）Nagel-Schreckenberg模型<br>对城市道路交通流的研究<br>2）BML模型<br>对城市交通网络的研究</p>
<p><strong>计算机科学与信息学领域</strong></p>
<p>研究信息的保存、传递、扩散<br>图像处理和模式识别</p>
<h3><span id="184-hao-mo-xing">184号模型</span><a href="#184-hao-mo-xing" class="header-anchor">#</a></h3><ul>
<li>道路被划分为等距格子，每个格点表示一个元胞；</li>
<li>某个时刻，元胞或者是空的，或者被一辆车占据；</li>
<li>所有车辆的行进方向都是一致的（如向右）；</li>
<li>在每一个时间步内：若第n辆车的前方元胞是空的，则该车可以向前行驶一步；</li>
<li>若前面的元胞被另一辆车n+1所占据，即使第n+1辆车在本时间步内离开此元胞，第n辆车也停在原地不动；</li>
<li>整个系统采用周期性边界条件以确保车辆数守恒。<br><img src="https://img-blog.csdnimg.cn/img_convert/d705565438f566c63c9d23fe1482b2fc.png" alt="20201031202559"><h3><span id="nasch-mo-xing">NaSch模型</span><a href="#nasch-mo-xing" class="header-anchor">#</a></h3>NaSch模型是对184号模型的推广，1992年Nagle和Schreckenberg提出了著名的NaSch模型</li>
</ul>
<h3><span id="python-shi-xian-zui-jian-dan-de-yuan-bao-zi-dong-ji">Python 实现最简单的元胞自动机</span><a href="#python-shi-xian-zui-jian-dan-de-yuan-bao-zi-dong-ji" class="header-anchor">#</a></h3><p>选取的元胞状态只有两种，分别为 0 和 1。每一层由 64 个元胞组成，若元胞状态为 1，那么控制台将打印星号(*)；如果元胞状态为 0，那么控制台将打印连字符(-)。也就是说，每一行由 64 个混合星号与连字符的图案组成。</p>
<p>状态更新规则：若当前元胞的前一个元胞的状态为 1，或者前一个元胞的左右两边的元胞的状态有且只有一个值为 1， 那么该元胞的状态就为 1。反之，元胞的状态设为 0。对于第一列和最后一列，我们只需分别考虑右元胞和左元胞即可。对于中间部分的元胞来说，若其领域元胞的状态为[0,1,0]、[0,0,1]、[1,0,0]、[1,1,0]等状态时，当前元胞的状态就为 1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">def print_seq(seq, speed&#x3D;0.5):</span><br><span class="line">    for item in seq:</span><br><span class="line">        if item:</span><br><span class="line">            print(&#39;*&#39;, end&#x3D;&#39;&#39;)</span><br><span class="line">        else:</span><br><span class="line">            print(&#39;-&#39;, end&#x3D;&#39;&#39;)</span><br><span class="line">    print(&#39;&#39;)</span><br><span class="line">    time.sleep(speed)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cell:</span><br><span class="line">    def __init__(self, deepth&#x3D;31):</span><br><span class="line">        self.ca &#x3D; [0 if i !&#x3D; 31 else 1 for i in range(64)]</span><br><span class="line">        self.ca_new &#x3D; []</span><br><span class="line">        self.deepth &#x3D; deepth</span><br><span class="line"></span><br><span class="line">    def process(self):</span><br><span class="line">        print_seq(self.ca)</span><br><span class="line">        for i in range(self.deepth):</span><br><span class="line">            self._rule()</span><br><span class="line">            print_seq(self.ca_new)</span><br><span class="line">            self.ca &#x3D; self.ca_new</span><br><span class="line">            self.ca_new &#x3D; []</span><br><span class="line"></span><br><span class="line">    def _rule(self):</span><br><span class="line">        for i in range(64):</span><br><span class="line">            if 0 &lt; i &lt; 63:</span><br><span class="line">                if self.ca[i - 1] &#x3D;&#x3D; self.ca[i + 1]:</span><br><span class="line">                    self.ca_new.append(0)</span><br><span class="line">                else:</span><br><span class="line">                    self.ca_new.append(1)</span><br><span class="line">            elif i &#x3D;&#x3D; 0:</span><br><span class="line">                if self.ca[1]:</span><br><span class="line">                    self.ca_new.append(1)</span><br><span class="line">                else:</span><br><span class="line">                    self.ca_new.append(0)</span><br><span class="line">            else:</span><br><span class="line">                if self.ca[62]:</span><br><span class="line">                    self.ca_new.append(1)</span><br><span class="line">                else:</span><br><span class="line">                    self.ca_new.append(0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    cell &#x3D; Cell()</span><br><span class="line">    cell.process()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4cd77641d3377924c9fc6a26094d3ff6.png" alt="20201105160200"></p>
<p>参考文章：</p>
<ol>
<li><a href="http://swarmagents.cn.13442.m8849.cn/complex/models/ca/ca5.htm" target="_blank" rel="noopener">元胞自动机研究的相关理论方法</a></li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
